<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bilistream æ§åˆ¶é¢æ¿</title>
  <link rel="icon"
    href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸ“º</text></svg>">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    .header {
      text-align: center;
      color: white;
      margin-bottom: 30px;
    }

    .header h1 {
      font-size: 2.5em;
      margin-bottom: 10px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
    }

    .header p {
      font-size: 1.1em;
      opacity: 0.9;
    }

    .dashboard {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }

    .card {
      background: white;
      border-radius: 12px;
      padding: 25px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }

    .card:hover {
      transform: translateY(-5px);
      box-shadow: 0 15px 40px rgba(0, 0, 0, 0.3);
    }

    .card h2 {
      color: #667eea;
      margin-bottom: 15px;
      font-size: 1.5em;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .status-indicator {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      display: inline-block;
    }

    .status-live {
      background: #10b981;
      box-shadow: 0 0 10px #10b981;
    }

    .status-offline {
      background: #ef4444;
    }

    .info-row {
      display: flex;
      justify-content: space-between;
      padding: 10px 0;
      border-bottom: 1px solid #f0f0f0;
    }

    .info-row:last-child {
      border-bottom: none;
    }

    .info-label {
      color: #666;
      font-weight: 500;
    }

    .info-value {
      color: #333;
      font-weight: 600;
    }

    .controls {
      background: white;
      border-radius: 12px;
      padding: 25px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
    }

    .controls h2 {
      color: #667eea;
      margin-bottom: 20px;
      font-size: 1.5em;
    }

    .control-group {
      margin-bottom: 20px;
    }

    .control-group label {
      display: block;
      margin-bottom: 8px;
      color: #555;
      font-weight: 500;
    }

    .control-group input,
    .control-group select,
    .control-group textarea {
      width: 100%;
      padding: 12px;
      border: 2px solid #e5e7eb;
      border-radius: 8px;
      font-size: 14px;
      transition: border-color 0.3s ease;
    }

    .control-group input:focus,
    .control-group select:focus,
    .control-group textarea:focus {
      outline: none;
      border-color: #667eea;
    }

    .button-group {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 10px;
      margin-top: 20px;
    }

    button {
      padding: 12px 24px;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .btn-primary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }

    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
    }

    .btn-success {
      background: #10b981;
      color: white;
    }

    .btn-success:hover {
      background: #059669;
      transform: translateY(-2px);
    }

    .btn-danger {
      background: #ef4444;
      color: white;
    }

    .btn-danger:hover {
      background: #dc2626;
      transform: translateY(-2px);
    }

    .btn-secondary {
      background: #6b7280;
      color: white;
    }

    .btn-secondary:hover {
      background: #4b5563;
      transform: translateY(-2px);
    }

    .notification {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 15px 20px;
      border-radius: 8px;
      color: white;
      font-weight: 500;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      animation: slideIn 0.3s ease;
      z-index: 1000;
    }

    .notification.success {
      background: #10b981;
    }

    .notification.error {
      background: #ef4444;
    }

    @keyframes slideIn {
      from {
        transform: translateX(400px);
        opacity: 0;
      }

      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    .loading {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(255, 255, 255, .3);
      border-radius: 50%;
      border-top-color: white;
      animation: spin 1s ease-in-out infinite;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    @media (max-width: 768px) {
      .header h1 {
        font-size: 2em;
      }

      .dashboard {
        grid-template-columns: 1fr;
      }
    }

    /* Setup page styles */
    .setup-page {
      display: none;
    }

    .setup-page.active {
      display: block;
    }

    .main-page {
      display: block;
    }

    .main-page.hidden {
      display: none;
    }

    .setup-card {
      background: white;
      border-radius: 16px;
      padding: 40px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      max-width: 700px;
      margin: 50px auto;
    }

    .setup-icon {
      font-size: 64px;
      text-align: center;
      margin-bottom: 20px;
    }

    .setup-title {
      font-size: 2em;
      color: #667eea;
      text-align: center;
      margin-bottom: 20px;
    }

    .setup-description {
      color: #666;
      line-height: 1.8;
      margin-bottom: 30px;
      text-align: center;
    }

    .missing-files {
      background: #fff3cd;
      border: 2px solid #ffc107;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 30px;
    }

    .missing-files h3 {
      color: #856404;
      margin-bottom: 10px;
    }

    .missing-files ul {
      list-style: none;
      padding: 0;
    }

    .missing-files li {
      color: #856404;
      padding: 5px 0;
      padding-left: 25px;
      position: relative;
    }

    .missing-files li:before {
      content: "âš ï¸";
      position: absolute;
      left: 0;
    }

    .setup-steps {
      background: #f8f9fa;
      border-radius: 8px;
      padding: 25px;
      margin-bottom: 30px;
    }

    .setup-steps h3 {
      color: #333;
      margin-bottom: 15px;
    }

    .setup-steps ol {
      padding-left: 20px;
      color: #555;
      line-height: 2;
    }

    .setup-steps code {
      background: #e9ecef;
      padding: 2px 8px;
      border-radius: 4px;
      font-family: 'Courier New', monospace;
      color: #d63384;
    }

    .command-box {
      background: #2d3748;
      color: #48bb78;
      padding: 20px;
      border-radius: 8px;
      font-family: 'Courier New', monospace;
      font-size: 16px;
      margin-bottom: 20px;
      position: relative;
    }

    .command-box:before {
      content: "$";
      color: #48bb78;
      margin-right: 10px;
    }

    .refresh-button {
      width: 100%;
      padding: 15px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s;
    }

    .refresh-button:hover {
      transform: translateY(-2px);
    }
  </style>
</head>

<body>
  <!-- Setup Page -->
  <div class="setup-page" id="setup-page">
    <div class="container">
      <div class="setup-card">
        <div class="setup-icon">ğŸš€</div>
        <h1 class="setup-title">æ¬¢è¿ä½¿ç”¨ Bilistream</h1>
        <p class="setup-description">
          æ£€æµ‹åˆ°ç³»ç»Ÿå°šæœªå®Œæˆåˆå§‹é…ç½®ã€‚è¯·æŒ‰ç…§ä»¥ä¸‹æ­¥éª¤å®Œæˆè®¾ç½®åï¼Œå³å¯å¼€å§‹ä½¿ç”¨ Web æ§åˆ¶é¢æ¿ã€‚
        </p>

        <div class="missing-files" id="missing-files-box">
          <h3>ç¼ºå°‘ä»¥ä¸‹æ–‡ä»¶ï¼š</h3>
          <ul id="missing-files-list"></ul>
        </div>

        <div class="setup-steps">
          <h3>ğŸ“‹ è®¾ç½®æ­¥éª¤</h3>
          <ol>
            <li>æ‰“å¼€ç»ˆç«¯ï¼Œè¿›å…¥ Bilistream æ‰€åœ¨ç›®å½•</li>
            <li>è¿è¡Œä¸‹æ–¹çš„è®¾ç½®å‘½ä»¤</li>
            <li>æŒ‰ç…§äº¤äº’å¼å‘å¯¼å®Œæˆé…ç½®</li>
            <li>é…ç½®å®Œæˆåï¼Œç‚¹å‡»ä¸‹æ–¹æŒ‰é’®åˆ·æ–°é¡µé¢</li>
          </ol>
        </div>

        <div class="command-box" id="setup-command">./bilistream setup</div>

        <button class="refresh-button" onclick="checkSetupAndRefresh()">
          ğŸ”„ æˆ‘å·²å®Œæˆè®¾ç½®ï¼Œåˆ·æ–°é¡µé¢
        </button>

        <p style="text-align: center; color: #999; margin-top: 20px; font-size: 14px;">
          éœ€è¦å¸®åŠ©ï¼ŸæŸ¥çœ‹ <a href="https://github.com/Detteee/bilistream" target="_blank" style="color: #667eea;">æ–‡æ¡£</a>
        </p>
      </div>
    </div>
  </div>

  <!-- Main Page -->
  <div class="main-page" id="main-page">
    <div class="container">
      <div class="header">
        <h1>ğŸ¬ Bilistream æ§åˆ¶é¢æ¿</h1>
        <p>å®æ—¶ç›‘æ§å’Œæ§åˆ¶ä½ çš„ç›´æ’­è½¬æ’­</p>
      </div>

      <div class="dashboard">
        <div class="card">
          <h2>
            <span class="status-indicator" id="bili-status"></span>
            å“”å“©å“”å“©
          </h2>
          <div class="info-row">
            <span class="info-label">çŠ¶æ€</span>
            <span class="info-value" id="bili-live-status">åŠ è½½ä¸­...</span>
          </div>
          <div class="info-row">
            <span class="info-label">æ ‡é¢˜</span>
            <span class="info-value" id="bili-title">-</span>
          </div>
          <div class="info-row">
            <span class="info-label">åˆ†åŒº</span>
            <span class="info-value" id="bili-area">-</span>
          </div>
          <div class="info-row" id="bili-stream-quality-row" style="display: none;">
            <span class="info-label">æµè´¨é‡</span>
            <span class="info-value" id="bili-stream-quality">-</span>
          </div>
        </div>

        <div class="card">
          <h2>
            <span class="status-indicator" id="yt-status"></span>
            YouTube
          </h2>
          <div class="info-row">
            <span class="info-label">é¢‘é“</span>
            <span class="info-value" id="yt-channel-name">-</span>
          </div>
          <div class="info-row">
            <span class="info-label">çŠ¶æ€</span>
            <span class="info-value" id="yt-live-status">åŠ è½½ä¸­...</span>
          </div>
          <div class="info-row">
            <span class="info-label">æ ‡é¢˜</span>
            <span class="info-value" id="yt-title">-</span>
          </div>
          <div class="info-row">
            <span class="info-label">åˆ†åŒº</span>
            <span class="info-value" id="yt-topic">-</span>
          </div>
        </div>

        <div class="card">
          <h2>
            <span class="status-indicator" id="tw-status"></span>
            Twitch
          </h2>
          <div class="info-row">
            <span class="info-label">é¢‘é“</span>
            <span class="info-value" id="tw-channel-name">-</span>
          </div>
          <div class="info-row">
            <span class="info-label">çŠ¶æ€</span>
            <span class="info-value" id="tw-live-status">åŠ è½½ä¸­...</span>
          </div>
          <div class="info-row">
            <span class="info-label">æ ‡é¢˜</span>
            <span class="info-value" id="tw-title">-</span>
          </div>
          <div class="info-row">
            <span class="info-label">æ¸¸æˆ</span>
            <span class="info-value" id="tw-game">-</span>
          </div>
        </div>
      </div>

      <div class="controls">
        <h2>âš™ï¸ æ§åˆ¶é¢æ¿</h2>

        <div class="control-group">
          <label>å‘é€å¼¹å¹•</label>
          <input type="text" id="danmaku-input" placeholder="è¾“å…¥å¼¹å¹•å†…å®¹...">
        </div>

        <div class="control-group">
          <label>æ›´æ–°åˆ†åŒº</label>
          <select id="area-input">
            <option value="">é€‰æ‹©åˆ†åŒº...</option>
          </select>
        </div>

        <div class="button-group">
          <button class="btn-success" onclick="startStream()">å¼€å§‹ç›´æ’­</button>
          <button class="btn-danger" onclick="stopStream()">åœæ­¢ç›´æ’­</button>
          <button class="btn-primary" onclick="sendDanmaku()">å‘é€å¼¹å¹•</button>
          <button class="btn-secondary" onclick="updateArea()">æ›´æ–°åˆ†åŒº</button>
          <button class="btn-primary" onclick="refreshStatus()">åˆ·æ–°çŠ¶æ€</button>
        </div>
      </div>

      <div class="controls" style="margin-top: 20px;">
        <h2>ğŸ“º é¢‘é“ç®¡ç†</h2>

        <div class="control-group">
          <label>å¹³å°</label>
          <select id="platform-select" onchange="updateChannelList()">
            <option value="youtube">YouTube</option>
            <option value="twitch">Twitch</option>
          </select>
        </div>

        <div class="control-group">
          <label>é€‰æ‹©é¢‘é“ (å¯é€‰)</label>
          <select id="channel-select" onchange="updateChannelInfo()">
            <option value="">é€‰æ‹©é¢„è®¾é¢‘é“æˆ–æ‰‹åŠ¨è¾“å…¥...</option>
          </select>
        </div>

        <div class="control-group">
          <label>é¢‘é“ID (å¿…å¡«)</label>
          <input type="text" id="channel-id-input" placeholder="è¾“å…¥é¢‘é“IDæˆ–ä»ä¸Šæ–¹é€‰æ‹©">
        </div>

        <div class="control-group">
          <label>é¢‘é“åç§° (å¿…å¡«)</label>
          <input type="text" id="channel-name-input" placeholder="è¾“å…¥é¢‘é“åç§°æˆ–ä»ä¸Šæ–¹é€‰æ‹©">
        </div>

        <div class="control-group">
          <label>åˆ†åŒº (å¯é€‰)</label>
          <select id="area-select">
            <option value="">ä¸ä¿®æ”¹åˆ†åŒº</option>
          </select>
        </div>

        <div class="control-group">
          <label>ç”»è´¨ (å¯é€‰)</label>
          <select id="quality-select" onchange="updateQualityOptions()">
            <option value="">ä¸ä¿®æ”¹ç”»è´¨</option>
            <option value="best">best - æœ€ä½³ç”»è´¨ (æ¨è)</option>
            <option value="720p">720p - é«˜æ¸…</option>
            <option value="480p">480p - æ ‡æ¸…</option>
            <option value="360p" data-platform="youtube">360p - æµç•… (ä»…YouTube)</option>
            <option value="worst">worst - æœ€ä½ç”»è´¨</option>
          </select>
        </div>

        <div class="button-group">
          <button class="btn-primary" onclick="applyChannelChange()">åº”ç”¨æ›´æ”¹</button>
          <button class="btn-secondary" onclick="loadChannelData()">åˆ·æ–°é¢‘é“åˆ—è¡¨</button>
        </div>
      </div>

      <div class="controls" style="margin-top: 20px;">
        <h2 style="cursor: pointer; user-select: none;" onclick="toggleLogs()">
          ğŸ“‹ ç³»ç»Ÿæ—¥å¿— <span id="log-toggle">â–¼</span>
        </h2>
        <div id="log-container" style="display: none;">
          <div
            style="background: #1e1e1e; color: #d4d4d4; padding: 15px; border-radius: 8px; font-family: 'SF Mono', 'Consolas', 'Liberation Mono', 'Menlo', 'Courier New', monospace; font-size: 14px; max-height: 400px; overflow-y: auto; line-height: 1.4; white-space: pre; overflow-x: auto;">
            <div id="log-output">ç­‰å¾…æ—¥å¿—...</div>
          </div>
          <div style="margin-top: 10px; display: flex; gap: 10px;">
            <button class="btn-secondary" onclick="clearLogs()">æ¸…ç©ºæ—¥å¿—</button>
            <button class="btn-primary" onclick="refreshLogs()">åˆ·æ–°æ—¥å¿—</button>
            <label style="display: flex; align-items: center; gap: 5px; color: #666;">
              <input type="checkbox" id="auto-scroll-checkbox" checked> è‡ªåŠ¨æ»šåŠ¨
            </label>
          </div>
        </div>
      </div>

      <div style="text-align: center; color: white; margin-top: 40px; padding: 20px; opacity: 0.8;">
        <p style="margin-bottom: 10px;">Bilistream v0.3.4</p>
        <p>
          <a href="https://github.com/Detteee/bilistream" target="_blank"
            style="color: white; text-decoration: none; border-bottom: 1px solid rgba(255,255,255,0.5); padding-bottom: 2px;">
            â­ GitHub
          </a>
          <span style="margin: 0 10px;">|</span>
          <a href="https://github.com/Detteee/bilistream/issues" target="_blank"
            style="color: white; text-decoration: none; border-bottom: 1px solid rgba(255,255,255,0.5); padding-bottom: 2px;">
            ğŸ› æŠ¥å‘Šé—®é¢˜
          </a>
        </p>
      </div>
    </div>

    <script>
      // Global data
      let channelsData = null;
      let areasData = null;
      let logLines = [];
      let maxLogLines = 500;
      let statusRefreshInterval = 60000; // Default 60 seconds
      let statusIntervalId = null;

      // Auto refresh logs every 2 seconds
      setInterval(refreshLogs, 2000);

      // Load config and set up status refresh interval
      async function initStatusRefresh() {
        try {
          const response = await fetch('/api/config');
          if (response.ok) {
            const config = await response.json();
            if (config.interval) {
              statusRefreshInterval = config.interval * 1000; // Convert to milliseconds
              console.log('Status refresh interval set to', config.interval, 'seconds');
            }
          }
        } catch (error) {
          console.log('Failed to load config, using default interval:', error);
        }

        // Start status refresh with configured interval
        if (statusIntervalId) {
          clearInterval(statusIntervalId);
        }
        statusIntervalId = setInterval(refreshStatus, statusRefreshInterval);

        // Initial refresh
        refreshStatus();
      }

      function toggleLogs() {
        const container = document.getElementById('log-container');
        const toggle = document.getElementById('log-toggle');
        if (container.style.display === 'none') {
          container.style.display = 'block';
          toggle.textContent = 'â–²';
          refreshLogs();
        } else {
          container.style.display = 'none';
          toggle.textContent = 'â–¼';
        }
      }

      function clearLogs() {
        logLines = [];
        document.getElementById('log-output').innerHTML = 'æ—¥å¿—å·²æ¸…ç©º';
      }

      async function refreshLogs() {
        try {
          const response = await fetch('/api/logs');
          if (!response.ok) return;

          const data = await response.json();
          if (data.success && data.logs) {
            // Add new logs
            const newLogs = data.logs.split('\n').filter(line => line.trim());
            newLogs.forEach(line => {
              if (!logLines.includes(line)) {
                logLines.push(line);
              }
            });

            // Keep only last maxLogLines
            if (logLines.length > maxLogLines) {
              logLines = logLines.slice(-maxLogLines);
            }

            // Format and display logs
            const logOutput = document.getElementById('log-output');
            logOutput.innerHTML = logLines.map(line => {
              // Escape HTML to prevent XSS
              const escaped = line
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
              // Don't replace spaces - let white-space: pre handle it

              // Color code log levels
              let coloredLine = escaped;
              if (line.includes('ERROR') || line.includes('âŒ')) {
                coloredLine = `<span style="color: #f87171;">${escaped}</span>`;
              } else if (line.includes('WARN') || line.includes('âš ï¸')) {
                coloredLine = `<span style="color: #fbbf24;">${escaped}</span>`;
              } else if (line.includes('INFO') || line.includes('âœ…') || line.includes('ğŸš€')) {
                coloredLine = `<span style="color: #60a5fa;">${escaped}</span>`;
              } else if (line.includes('DEBUG') || line.includes('ğŸ”„')) {
                coloredLine = `<span style="color: #a78bfa;">${escaped}</span>`;
              }
              return coloredLine;
            }).join('\n');

            // Auto scroll if enabled
            if (document.getElementById('auto-scroll-checkbox').checked) {
              logOutput.parentElement.scrollTop = logOutput.parentElement.scrollHeight;
            }
          }
        } catch (error) {
          // Silently fail - logs are optional
          console.log('Failed to fetch logs:', error);
        }
      }

      function showNotification(message, type = 'success') {
        const notification = document.createElement('div');
        notification.className = `notification ${type}`;
        notification.textContent = message;
        document.body.appendChild(notification);

        setTimeout(() => {
          notification.remove();
        }, 3000);
      }

      async function refreshStatus() {
        try {
          const response = await fetch('/api/status');

          if (!response.ok) {
            const errorText = await response.text();
            console.error('API Error:', response.status, errorText);
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }

          const text = await response.text();
          console.log('API Response Text:', text); // Debug log

          if (!text) {
            throw new Error('Empty response from server');
          }

          const data = JSON.parse(text);
          console.log('Parsed Data:', data); // Debug log

          if (!data.success) {
            // API returned an error
            throw new Error(data.message || 'æœåŠ¡å™¨è¿”å›é”™è¯¯');
          }

          if (data.success && data.data) {
            // Update Bilibili status
            const bili = data.data.bilibili;
            document.getElementById('bili-status').className =
              `status-indicator ${bili.is_live ? 'status-live' : 'status-offline'}`;
            document.getElementById('bili-live-status').textContent =
              bili.is_live ? 'ç›´æ’­ä¸­' : 'æœªç›´æ’­';
            document.getElementById('bili-title').textContent = bili.title || '-';
            document.getElementById('bili-area').textContent =
              bili.area_name ? `${bili.area_name} (${bili.area_id})` : (bili.area_id || '-');

            // Update stream quality
            const qualityRow = document.getElementById('bili-stream-quality-row');
            const qualityElement = document.getElementById('bili-stream-quality');
            if (bili.is_live && bili.stream_quality) {
              qualityRow.style.display = '';
              const speedText = bili.stream_speed ? ` (${bili.stream_speed.toFixed(2)}x)` : '';
              qualityElement.textContent = bili.stream_quality + speedText;

              // Set color based on quality
              if (bili.stream_quality === 'æµç•…') {
                qualityElement.style.color = '#10b981'; // green
              } else if (bili.stream_quality === 'æ³¢åŠ¨') {
                qualityElement.style.color = '#f59e0b'; // orange
              } else if (bili.stream_quality === 'å¡é¡¿') {
                qualityElement.style.color = '#ef4444'; // red
              }
            } else {
              qualityRow.style.display = 'none';
            }

            // Update YouTube status
            if (data.data.youtube) {
              const yt = data.data.youtube;
              document.getElementById('yt-status').className =
                `status-indicator ${yt.is_live ? 'status-live' : 'status-offline'}`;
              document.getElementById('yt-channel-name').textContent = yt.channel_name || '-';
              document.getElementById('yt-live-status').textContent =
                yt.is_live ? 'ç›´æ’­ä¸­' : 'æœªç›´æ’­';
              document.getElementById('yt-title').textContent = yt.title || '-';
              document.getElementById('yt-topic').textContent = yt.topic || '-';
            } else {
              document.getElementById('yt-status').className = 'status-indicator status-offline';
              document.getElementById('yt-channel-name').textContent = '-';
              document.getElementById('yt-live-status').textContent = 'æœªé…ç½®';
              document.getElementById('yt-title').textContent = '-';
              document.getElementById('yt-topic').textContent = '-';
            }

            // Update Twitch status
            if (data.data.twitch) {
              const tw = data.data.twitch;
              document.getElementById('tw-status').className =
                `status-indicator ${tw.is_live ? 'status-live' : 'status-offline'}`;
              document.getElementById('tw-channel-name').textContent = tw.channel_name || '-';
              document.getElementById('tw-live-status').textContent =
                tw.is_live ? 'ç›´æ’­ä¸­' : 'æœªç›´æ’­';
              document.getElementById('tw-title').textContent = tw.title || '-';
              document.getElementById('tw-game').textContent = tw.game || '-';
            } else {
              document.getElementById('tw-status').className = 'status-indicator status-offline';
              document.getElementById('tw-channel-name').textContent = '-';
              document.getElementById('tw-live-status').textContent = 'æœªé…ç½®';
              document.getElementById('tw-title').textContent = '-';
              document.getElementById('tw-game').textContent = '-';
            }
          } else {
            console.error('Invalid API response:', data);
            showNotification('è·å–çŠ¶æ€å¤±è´¥ï¼šå“åº”æ ¼å¼é”™è¯¯', 'error');
            // Show error state
            document.getElementById('bili-live-status').textContent = 'æ•°æ®é”™è¯¯';
            document.getElementById('yt-live-status').textContent = 'æ•°æ®é”™è¯¯';
            document.getElementById('tw-live-status').textContent = 'æ•°æ®é”™è¯¯';
          }
        } catch (error) {
          console.error('Failed to refresh status:', error);

          // Suppress network errors (when server is down)
          if (error.message && error.message.includes('NetworkError')) {
            console.log('Server appears to be down, suppressing error notification');
            return;
          }

          // Show more helpful error messages for other errors
          let errorMsg = error.message;
          if (errorMsg.includes('æƒé™é”™è¯¯') || errorMsg.includes('Permission denied')) {
            errorMsg = 'é…ç½®æ–‡ä»¶æƒé™é”™è¯¯ï¼è¯·åœ¨å¯æ‰§è¡Œæ–‡ä»¶æ‰€åœ¨ç›®å½•è¿è¡Œç¨‹åºã€‚';
          } else if (errorMsg.includes('ä¸å­˜åœ¨') || errorMsg.includes('No such file')) {
            errorMsg = 'é…ç½®æ–‡ä»¶ä¸å­˜åœ¨ï¼è¯·å…ˆè¿è¡Œ "bilistream setup" åˆ›å»ºé…ç½®ã€‚';
          } else if (errorMsg.includes('Failed to fetch')) {
            // Also suppress generic fetch failures
            console.log('Connection failed, suppressing error notification');
            return;
          }

          showNotification(errorMsg, 'error');

          // Show connection error state
          document.getElementById('bili-live-status').textContent = 'é…ç½®é”™è¯¯';
          document.getElementById('yt-live-status').textContent = 'é…ç½®é”™è¯¯';
          document.getElementById('tw-live-status').textContent = 'é…ç½®é”™è¯¯';
        }
      }

      async function startStream() {
        try {
          const response = await fetch('/api/start', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({})
          });
          const data = await response.json();
          showNotification(data.message || 'ç›´æ’­å·²å¼€å§‹', 'success');
          setTimeout(refreshStatus, 2000);
        } catch (error) {
          showNotification('æ“ä½œå¤±è´¥: ' + error.message, 'error');
        }
      }

      async function stopStream() {
        try {
          const response = await fetch('/api/stop', {
            method: 'POST'
          });
          const data = await response.json();
          showNotification(data.message || 'ç›´æ’­å·²åœæ­¢', 'success');
          setTimeout(refreshStatus, 2000);
        } catch (error) {
          showNotification('æ“ä½œå¤±è´¥: ' + error.message, 'error');
        }
      }

      async function sendDanmaku() {
        const message = document.getElementById('danmaku-input').value;
        if (!message) {
          showNotification('è¯·è¾“å…¥å¼¹å¹•å†…å®¹', 'error');
          return;
        }

        try {
          const response = await fetch('/api/danmaku', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ message })
          });
          const data = await response.json();
          showNotification(data.message || 'å¼¹å¹•å·²å‘é€', 'success');
          document.getElementById('danmaku-input').value = '';
        } catch (error) {
          showNotification('å‘é€å¤±è´¥: ' + error.message, 'error');
        }
      }

      async function updateArea() {
        const areaId = parseInt(document.getElementById('area-input').value);
        if (!areaId) {
          showNotification('è¯·é€‰æ‹©åˆ†åŒº', 'error');
          return;
        }

        try {
          const response = await fetch('/api/area', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ area_id: areaId })
          });
          const data = await response.json();
          showNotification(data.message || 'åˆ†åŒºå·²æ›´æ–°', 'success');
          document.getElementById('area-input').value = '';
          setTimeout(refreshStatus, 2000);
        } catch (error) {
          showNotification('æ›´æ–°å¤±è´¥: ' + error.message, 'error');
        }
      }

      // Channel management functions
      async function loadChannelData() {
        try {
          // Load channels
          const channelsResponse = await fetch('/api/channels');
          channelsData = await channelsResponse.json();
          console.log('Channels loaded:', channelsData);

          // Load areas
          const areasResponse = await fetch('/api/areas');
          areasData = await areasResponse.json();
          console.log('Areas loaded:', areasData);

          // Populate area select
          const areaSelect = document.getElementById('area-select');
          areaSelect.innerHTML = '<option value="">ä¸ä¿®æ”¹åˆ†åŒº</option>';

          // Handle both array and object responses
          let areasList = [];
          if (Array.isArray(areasData)) {
            areasList = areasData;
          } else if (areasData && areasData.areas) {
            areasList = areasData.areas;
          }

          if (areasList.length > 0) {
            console.log('Populating areas, count:', areasList.length);

            // Populate channel management area select
            areasList.forEach(area => {
              const option = document.createElement('option');
              option.value = area.id;
              option.textContent = `${area.name} (${area.id})`;
              areaSelect.appendChild(option);
            });

            // Also populate control panel area select
            const controlAreaSelect = document.getElementById('area-input');
            if (controlAreaSelect) {
              controlAreaSelect.innerHTML = '<option value="">é€‰æ‹©åˆ†åŒº...</option>';
              areasList.forEach(area => {
                const option = document.createElement('option');
                option.value = area.id;
                option.textContent = `${area.name} (${area.id})`;
                controlAreaSelect.appendChild(option);
              });
            }

            console.log('Successfully populated', areasList.length, 'areas');
          } else {
            console.error('No areas data found:', areasData);
            showNotification('æœªæ‰¾åˆ°åˆ†åŒºæ•°æ®', 'error');
          }

          // Update channel list
          updateChannelList();
        } catch (error) {
          console.error('Failed to load channel data:', error);
          showNotification('åŠ è½½é¢‘é“æ•°æ®å¤±è´¥: ' + error.message, 'error');
        }
      }

      function updateChannelList() {
        const platform = document.getElementById('platform-select').value;
        const channelSelect = document.getElementById('channel-select');

        channelSelect.innerHTML = '<option value="">é€‰æ‹©é¢„è®¾é¢‘é“æˆ–æ‰‹åŠ¨è¾“å…¥...</option>';

        // Only populate if channels data is available
        if (channelsData && channelsData.channels) {
          channelsData.channels.forEach(channel => {
            if (channel.platforms && channel.platforms[platform]) {
              const option = document.createElement('option');
              option.value = JSON.stringify({
                id: channel.platforms[platform],
                name: channel.name
              });
              option.textContent = channel.name;
              channelSelect.appendChild(option);
            }
          });
        }

        // Don't clear inputs - allow manual entry to persist
        // Update quality options based on platform
        updateQualityOptions();
      }

      function updateQualityOptions() {
        const platform = document.getElementById('platform-select').value;
        const qualitySelect = document.getElementById('quality-select');
        const options = qualitySelect.querySelectorAll('option');

        options.forEach(option => {
          const platformRestriction = option.getAttribute('data-platform');
          if (platformRestriction) {
            // Show/hide 360p option based on platform
            if (platform === 'youtube' && platformRestriction === 'youtube') {
              option.style.display = '';
              option.disabled = false;
            } else if (platform === 'twitch' && platformRestriction === 'youtube') {
              option.style.display = 'none';
              option.disabled = true;
              // Reset selection if 360p was selected for Twitch
              if (qualitySelect.value === '360p') {
                qualitySelect.value = '';
              }
            }
          }
        });
      }

      function updateChannelInfo() {
        const channelSelect = document.getElementById('channel-select');
        const selectedValue = channelSelect.value;

        if (!selectedValue) {
          document.getElementById('channel-id-input').value = '';
          document.getElementById('channel-name-input').value = '';
          return;
        }

        try {
          const channelInfo = JSON.parse(selectedValue);
          document.getElementById('channel-id-input').value = channelInfo.id;
          document.getElementById('channel-name-input').value = channelInfo.name;
        } catch (error) {
          console.error('Failed to parse channel info:', error);
        }
      }

      async function applyChannelChange() {
        const platform = document.getElementById('platform-select').value;
        const channelId = document.getElementById('channel-id-input').value.trim();
        const channelName = document.getElementById('channel-name-input').value.trim();
        const areaId = document.getElementById('area-select').value;
        const quality = document.getElementById('quality-select').value;

        if (!channelId || !channelName) {
          showNotification('è¯·è¾“å…¥é¢‘é“IDå’Œé¢‘é“åç§°', 'error');
          return;
        }

        try {
          const payload = {
            platform: platform,
            channel_id: channelId,
            channel_name: channelName
          };

          if (areaId) {
            payload.area_id = parseInt(areaId);
          }

          if (quality) {
            payload.quality = quality;
          }

          const response = await fetch('/api/channel', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });

          const data = await response.json();
          showNotification(data.message || 'é¢‘é“å·²æ›´æ–°', 'success');
          setTimeout(refreshStatus, 2000);
        } catch (error) {
          showNotification('æ›´æ–°å¤±è´¥: ' + error.message, 'error');
        }
      }

      // Setup check functions
      async function checkSetupStatus() {
        try {
          const response = await fetch('/api/setup-status');
          const data = await response.json();

          if (data.needs_setup) {
            // Show setup page
            document.getElementById('setup-page').classList.add('active');
            document.getElementById('main-page').classList.add('hidden');

            // Populate missing files
            const missingFilesList = document.getElementById('missing-files-list');
            missingFilesList.innerHTML = '';
            data.missing_files.forEach(file => {
              const li = document.createElement('li');
              li.textContent = file;
              missingFilesList.appendChild(li);
            });

            // Update setup command
            const setupCommandBox = document.getElementById('setup-command');
            if (setupCommandBox && data.setup_command) {
              setupCommandBox.textContent = data.setup_command;
            }
          } else {
            // Show main page
            document.getElementById('setup-page').classList.remove('active');
            document.getElementById('main-page').classList.remove('hidden');
          }

          return data.needs_setup;
        } catch (error) {
          console.error('Failed to check setup status:', error);
          // On error, show main page
          document.getElementById('setup-page').classList.remove('active');
          document.getElementById('main-page').classList.remove('hidden');
          return false;
        }
      }

      async function checkSetupAndRefresh() {
        const needsSetup = await checkSetupStatus();
        if (!needsSetup) {
          showNotification('è®¾ç½®å®Œæˆï¼æ­£åœ¨åŠ è½½æ§åˆ¶é¢æ¿...', 'success');
          setTimeout(() => {
            location.reload();
          }, 1000);
        } else {
          showNotification('è¯·å…ˆå®Œæˆè®¾ç½®æ­¥éª¤', 'error');
        }
      }

      // Check setup status on page load
      checkSetupStatus().then(needsSetup => {
        if (!needsSetup) {
          // Only load data if setup is complete
          initStatusRefresh(); // This will load config and start auto-refresh
          loadChannelData();
        }
      });
    </script>
  </div> <!-- Close main-page -->
</body>

</html>