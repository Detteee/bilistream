<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bilistream</title>
  <link rel="icon"
    href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'><g><path d='M0 2A2 2 0 0 1 3 .3l15.5 9.3a2 2 0 0 1 0 3.5L3.1 22.4A2 2 0 0 1 0 20.7V2Z' fill='url(%23b)'/><path d='M4.57 2a2 2 0 0 1 3-1.7L23 9.6a2 2 0 0 1 0 3.5L7.6 22.4a2 2 0 0 1-3-1.7V2Z' fill='url(%23a)'/></g><defs><linearGradient id='a' x1='.2' y1='2.8' x2='19.3' y2='18.5' gradientUnits='userSpaceOnUse'><stop stop-color='%23FD0031'/><stop offset='1' stop-color='%23FC4085'/></linearGradient><linearGradient id='b' x1='-4.4' y1='2.8' x2='19.5' y2='11.3' gradientUnits='userSpaceOnUse'><stop stop-color='%2355ACEE'/><stop offset='0.6' stop-color='%238264E5' stop-opacity='.3'/></linearGradient></defs></svg>">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      /* Catppuccin Mocha Dark Theme */
      --bg-gradient-start: #1e1e2e;
      --bg-gradient-mid: #181825;
      --bg-gradient-end: #11111b;
      --card-bg: #1e1e2e;
      --card-border: #313244;
      --text-primary: #cdd6f4;
      --text-secondary: #bac2de;
      --text-muted: #6c7086;
      --header-text: #cdd6f4;
      --input-bg: #313244;
      --input-border: #45475a;
      --input-focus: #89b4fa;
      --shadow: rgba(0, 0, 0, 0.4);
      --shadow-hover: rgba(0, 0, 0, 0.6);
      --info-border: #313244;
      --heading-color: #89b4fa;
      --button-hover-bg: #45475a;
      --accent-pink: #f5c2e7;
      --accent-mauve: #cba6f7;
      --accent-red: #f38ba8;
      --accent-green: #a6e3a1;
      --accent-yellow: #f9e2af;
      --accent-teal: #94e2d5;
    }

    body.light-theme {
      /* Light Theme */
      --bg-gradient-start: #667eea;
      --bg-gradient-mid: #764ba2;
      --bg-gradient-end: #8e54e9;
      --card-bg: #ffffff;
      --card-border: #e5e7eb;
      --text-primary: #333333;
      --text-secondary: #666666;
      --text-muted: #999999;
      --header-text: #ffffff;
      --input-bg: #ffffff;
      --input-border: #e5e7eb;
      --input-focus: #667eea;
      --shadow: rgba(0, 0, 0, 0.2);
      --shadow-hover: rgba(0, 0, 0, 0.3);
      --info-border: #f0f0f0;
      --heading-color: #667eea;
      --button-hover-bg: #e5e7eb;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-mid) 50%, var(--bg-gradient-end) 100%);
      min-height: 100vh;
      padding: 20px;
      transition: background 0.3s ease;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    .header {
      text-align: center;
      color: white;
      margin-bottom: 30px;
    }

    .header h1 {
      font-size: 2.5em;
      margin-bottom: 10px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
    }

    .header p {
      font-size: 1.1em;
      opacity: 0.9;
    }

    .dashboard {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }

    .card {
      background: var(--card-bg);
      border-radius: 12px;
      padding: 25px;
      box-shadow: 0 10px 30px var(--shadow);
      transition: transform 0.3s ease, box-shadow 0.3s ease, background 0.3s ease;
      border: 1px solid var(--card-border);
    }

    .card:hover {
      transform: translateY(-5px);
      box-shadow: 0 15px 40px var(--shadow-hover);
    }

    .card h2 {
      color: var(--heading-color);
      margin-bottom: 15px;
      font-size: 1.5em;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .status-indicator {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      display: inline-block;
    }

    .status-live {
      background: #a6e3a1;
      box-shadow: 0 0 10px #a6e3a1;
    }

    .status-offline {
      background: #f38ba8;
    }

    .info-row {
      display: flex;
      justify-content: space-between;
      padding: 10px 0;
      border-bottom: 1px solid var(--info-border);
    }

    .info-row:last-child {
      border-bottom: none;
    }

    .info-label {
      color: var(--text-secondary);
      font-weight: 500;
    }

    .info-value {
      color: var(--text-primary);
      font-weight: 600;
    }

    .controls {
      background: var(--card-bg);
      border-radius: 12px;
      padding: 25px;
      box-shadow: 0 10px 30px var(--shadow);
      border: 1px solid var(--card-border);
      transition: background 0.3s ease;
    }

    .controls h2 {
      color: var(--heading-color);
      margin-bottom: 20px;
      font-size: 1.5em;
    }

    .control-group {
      margin-bottom: 20px;
    }

    .control-group label {
      display: block;
      margin-bottom: 8px;
      color: var(--text-secondary);
      font-weight: 500;
    }

    .control-group input,
    .control-group select,
    .control-group textarea {
      width: 100%;
      padding: 12px;
      border: 2px solid var(--input-border);
      border-radius: 8px;
      font-size: 14px;
      transition: border-color 0.3s ease, background 0.3s ease;
      background: var(--input-bg);
      color: var(--text-primary);
    }

    .control-group input:focus,
    .control-group select:focus,
    .control-group textarea:focus {
      outline: none;
      border-color: var(--input-focus);
    }

    .button-group {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 10px;
      margin-top: 20px;
    }

    button {
      padding: 12px 24px;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    button:hover:not(:disabled) {
      filter: brightness(1.1);
    }

    .btn-primary {
      background: linear-gradient(135deg, #89b4fa 0%, #cba6f7 100%);
      color: #1e1e2e;
    }

    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(137, 180, 250, 0.4);
    }

    .btn-success {
      background: #a6e3a1;
      color: #1e1e2e;
    }

    .btn-success:hover {
      background: #94d89e;
      transform: translateY(-2px);
    }

    .btn-danger {
      background: #f38ba8;
      color: #1e1e2e;
    }

    .btn-danger:hover {
      background: #f17a9a;
      transform: translateY(-2px);
    }

    .btn-secondary {
      background: #6c7086;
      color: #cdd6f4;
    }

    .btn-secondary:hover {
      background: #585b70;
      transform: translateY(-2px);
    }

    .notification {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 15px 20px;
      border-radius: 8px;
      color: white;
      font-weight: 500;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      animation: slideIn 0.3s ease;
      z-index: 1000;
    }

    .notification.success {
      background: #a6e3a1;
      color: #1e1e2e;
    }

    .notification.error {
      background: #f38ba8;
      color: #1e1e2e;
    }

    @keyframes slideIn {
      from {
        transform: translateX(400px);
        opacity: 0;
      }

      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    .loading {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(255, 255, 255, .3);
      border-radius: 50%;
      border-top-color: white;
      animation: spin 1s ease-in-out infinite;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    small {
      color: var(--text-muted);
    }

    a {
      color: var(--heading-color);
      transition: opacity 0.3s ease;
    }

    a:hover {
      opacity: 0.8;
    }

    @media (max-width: 768px) {
      .header h1 {
        font-size: 2em;
      }

      .dashboard {
        grid-template-columns: 1fr;
      }
    }

    /* Setup page styles */
    .setup-page {
      display: none;
    }

    .setup-page.active {
      display: block;
    }

    .main-page {
      display: block;
    }

    .main-page.hidden {
      display: none;
    }

    .setup-card {
      background: var(--card-bg);
      border-radius: 16px;
      padding: 40px;
      box-shadow: 0 20px 60px var(--shadow);
      max-width: 700px;
      margin: 50px auto;
      border: 1px solid var(--card-border);
      transition: background 0.3s ease;
    }

    .setup-icon {
      font-size: 64px;
      text-align: center;
      margin-bottom: 20px;
    }

    .setup-title {
      font-size: 2em;
      color: var(--heading-color);
      text-align: center;
      margin-bottom: 20px;
    }

    .setup-description {
      color: var(--text-secondary);
      line-height: 1.8;
      margin-bottom: 30px;
      text-align: center;
    }

    .missing-files {
      background: #fff3cd;
      border: 2px solid #ffc107;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 30px;
    }

    .missing-files h3 {
      color: #856404;
      margin-bottom: 10px;
    }

    .missing-files ul {
      list-style: none;
      padding: 0;
    }

    .missing-files li {
      color: #856404;
      padding: 5px 0;
      padding-left: 25px;
      position: relative;
    }

    .missing-files li:before {
      content: "âš ï¸";
      position: absolute;
      left: 0;
    }

    .setup-steps {
      background: var(--input-bg);
      border-radius: 8px;
      padding: 25px;
      margin-bottom: 30px;
      border: 1px solid var(--card-border);
    }

    .setup-steps h3 {
      color: var(--text-primary);
      margin-bottom: 15px;
    }

    .setup-steps ol {
      padding-left: 20px;
      color: var(--text-secondary);
      line-height: 2;
    }

    .setup-steps code {
      background: var(--card-border);
      padding: 2px 8px;
      border-radius: 4px;
      font-family: 'Courier New', monospace;
      color: #f5c2e7;
    }

    .command-box {
      background: #181825;
      color: #a6e3a1;
      padding: 20px;
      border-radius: 8px;
      font-family: 'Courier New', monospace;
      font-size: 16px;
      margin-bottom: 20px;
      position: relative;
      border: 1px solid #313244;
    }

    .command-box:before {
      content: "$";
      color: #89b4fa;
      margin-right: 10px;
    }

    .refresh-button {
      width: 100%;
      padding: 15px;
      background: linear-gradient(135deg, #89b4fa 0%, #cba6f7 100%);
      color: #1e1e2e;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s;
    }

    .refresh-button:hover {
      transform: translateY(-2px);
      filter: brightness(1.1);
    }

    /* Setup wizard styles */
    .step-dot {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: #313244;
      color: #6c7086;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      transition: all 0.3s ease;
      border: 2px solid #45475a;
    }

    .step-dot.active {
      background: linear-gradient(135deg, #89b4fa 0%, #cba6f7 100%);
      color: #1e1e2e;
      box-shadow: 0 4px 12px rgba(137, 180, 250, 0.4);
      border-color: transparent;
    }

    .setup-step {
      animation: fadeIn 0.3s ease;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
  </style>
</head>

<body>
  <!-- Setup Page -->
  <div class="setup-page" id="setup-page">
    <div class="container">
      <div class="setup-card">
        <div class="setup-icon">ğŸš€</div>
        <h1 class="setup-title">æ¬¢è¿ä½¿ç”¨ Bilistream</h1>
        <p class="setup-description">
          é€šè¿‡ Web ç•Œé¢å®Œæˆåˆå§‹é…ç½®ï¼Œæ— éœ€ä½¿ç”¨å‘½ä»¤è¡Œ
        </p>

        <!-- Step Indicator -->
        <div style="display: flex; justify-content: center; gap: 10px; margin-bottom: 30px;">
          <div class="step-dot active" id="step-dot-1">1</div>
          <div class="step-dot" id="step-dot-2">2</div>
          <div class="step-dot" id="step-dot-3">3</div>
        </div>

        <!-- Step 1: Login -->
        <div class="setup-step" id="setup-step-1">
          <h3 style="color: #667eea; margin-bottom: 20px;">æ­¥éª¤ 1: ç™»å½• Bilibili</h3>
          <p style="color: #666; margin-bottom: 20px;">
            ä½¿ç”¨ Bilibili APP æ‰«æä¸‹æ–¹äºŒç»´ç ç™»å½•
          </p>
          <div id="login-status" style="padding: 15px; background: #f0f0f0; border-radius: 8px; margin-bottom: 20px;">
            <span id="login-status-text">æ£€æŸ¥ç™»å½•çŠ¶æ€...</span>
          </div>

          <!-- QR Code Display -->
          <div id="qr-code-container" style="display: none; text-align: center; margin-bottom: 20px;">
            <div
              style="background: white; padding: 20px; border-radius: 8px; display: inline-block; box-shadow: 0 4px 12px rgba(0,0,0,0.1);">
              <div id="qr-code-display"></div>
              <p style="color: #666; margin-top: 15px; font-size: 14px;">è¯·ä½¿ç”¨ Bilibili APP æ‰«ç ç™»å½•</p>
              <p id="qr-status" style="color: #667eea; margin-top: 10px; font-weight: 600;">ç­‰å¾…æ‰«ç ...</p>
            </div>
          </div>

          <div style="display: flex; gap: 10px;">
            <button class="btn-primary" onclick="showQrCode()" id="show-qr-btn" style="flex: 1;">
              ğŸ” æ˜¾ç¤ºç™»å½•äºŒç»´ç 
            </button>
            <button class="btn-secondary" onclick="checkLoginStatus()"
              style="flex: 1; display: flex; align-items: center; justify-content: center; gap: 6px;">
              <svg fill="currentColor" width="14" height="14" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path
                  d="M19.146 4.854l-1.489 1.489A8 8 0 1 0 12 20a8.094 8.094 0 0 0 7.371-4.886 1 1 0 1 0-1.842-.779A6.071 6.071 0 0 1 12 18a6 6 0 1 1 4.243-10.243l-1.39 1.39a.5.5 0 0 0 .354.854H19.5A.5.5 0 0 0 20 9.5V5.207a.5.5 0 0 0-.854-.353z" />
              </svg>
              <span>åˆ·æ–°çŠ¶æ€</span>
            </button>
          </div>
          <button class="btn-success" onclick="goToStep(2)" style="width: 100%; margin-top: 15px;">
            ä¸‹ä¸€æ­¥ â†’
          </button>
        </div>

        <!-- Step 2: Basic Config -->
        <div class="setup-step" id="setup-step-2" style="display: none;">
          <h3 style="color: #667eea; margin-bottom: 20px;">æ­¥éª¤ 2: åŸºç¡€é…ç½®</h3>

          <div class="control-group">
            <label>Bç«™ç›´æ’­é—´å· *</label>
            <input type="number" id="setup-room" placeholder="è¾“å…¥ä½ çš„ç›´æ’­é—´å·" required>
          </div>

          <div class="control-group">
            <label>æ£€æµ‹é—´éš” (ç§’)</label>
            <input type="number" id="setup-interval" value="60" min="10">
          </div>

          <div class="control-group">
            <label style="display: flex; align-items: center; gap: 10px;">
              <input type="checkbox" id="setup-auto-cover" checked>
              <span>è‡ªåŠ¨æ›´æ¢å°é¢</span>
            </label>
          </div>

          <div class="control-group">
            <label style="display: flex; align-items: center; gap: 10px;">
              <input type="checkbox" id="setup-danmaku-command" checked>
              <span>å¯ç”¨å¼¹å¹•æŒ‡ä»¤</span>
            </label>
          </div>

          <div class="control-group">
            <label style="display: flex; align-items: center; gap: 10px;">
              <input type="checkbox" id="setup-anti-collision">
              <span>å¯ç”¨æ’è½¦ç›‘æ§</span>
            </label>
          </div>

          <div class="control-group">
            <label>ä»£ç†åœ°å€ (å¯é€‰)</label>
            <input type="text" id="setup-proxy" placeholder="http://host:port">
            <small style="color: #888;">å¦‚éœ€è®¿é—® YouTube/Twitch éœ€è¦ä»£ç†ï¼Œè¯·å¡«å†™</small>
          </div>

          <div style="display: flex; gap: 10px; margin-top: 20px;">
            <button class="btn-secondary" onclick="goToStep(1)" style="flex: 1;">
              â† ä¸Šä¸€æ­¥
            </button>
            <button class="btn-success" onclick="goToStep(3)" style="flex: 1;">
              ä¸‹ä¸€æ­¥ â†’
            </button>
          </div>
        </div>

        <!-- Step 3: Platform Config -->
        <div class="setup-step" id="setup-step-3" style="display: none;">
          <h3 style="color: #667eea; margin-bottom: 20px;">æ­¥éª¤ 3: å¹³å°é…ç½® (å¯é€‰)</h3>

          <!-- YouTube Config -->
          <div style="border: 2px solid #e5e7eb; border-radius: 8px; padding: 20px; margin-bottom: 20px;">
            <h4 style="color: #667eea; margin-bottom: 15px;">ğŸ“º YouTube</h4>

            <div class="control-group">
              <label>é¢‘é“åç§°</label>
              <input type="text" id="setup-yt-name" placeholder="ç•™ç©ºè¡¨ç¤ºä¸é…ç½®">
            </div>

            <div class="control-group">
              <label>é¢‘é“ ID</label>
              <input type="text" id="setup-yt-id" placeholder="YouTube Channel ID">
            </div>

            <div class="control-group">
              <label>Bç«™åˆ†åŒº</label>
              <select id="setup-yt-area">
                <option value="235">å…¶ä»–å•æœº (235)</option>
              </select>
            </div>

            <div class="control-group">
              <label>æµè´¨é‡</label>
              <select id="setup-yt-quality">
                <option value="best">best - æœ€ä½³è´¨é‡ (æ¨è)</option>
                <option value="720p">720p - é«˜æ¸…</option>
                <option value="480p">480p - æ ‡æ¸…</option>
                <option value="360p">360p - æµç•…</option>
                <option value="worst">worst - æœ€ä½è´¨é‡</option>
              </select>
            </div>
          </div>

          <!-- Twitch Config -->
          <div style="border: 2px solid #e5e7eb; border-radius: 8px; padding: 20px; margin-bottom: 20px;">
            <h4 style="color: #9146ff; margin-bottom: 15px;">ğŸ® Twitch</h4>

            <div class="control-group">
              <label>é¢‘é“åç§°</label>
              <input type="text" id="setup-tw-name" placeholder="ç•™ç©ºè¡¨ç¤ºä¸é…ç½®">
            </div>

            <div class="control-group">
              <label>é¢‘é“ ID (ç”¨æˆ·å)</label>
              <input type="text" id="setup-tw-id" placeholder="Twitch ç”¨æˆ·å">
            </div>

            <div class="control-group">
              <label>Bç«™åˆ†åŒº</label>
              <select id="setup-tw-area">
                <option value="235">å…¶ä»–å•æœº (235)</option>
              </select>
            </div>

            <div class="control-group">
              <label>OAuth Token (å¯é€‰)</label>
              <input type="text" id="setup-tw-oauth" placeholder="ç”¨äº streamlink è®¤è¯">
            </div>

            <div class="control-group">
              <label>ä»£ç†åŒºåŸŸ</label>
              <select id="setup-tw-region">
                <option value="as">as - äºšæ´²</option>
                <option value="na">na - åŒ—ç¾</option>
                <option value="eu">eu - æ¬§æ´²</option>
              </select>
            </div>

            <div class="control-group">
              <label>æµè´¨é‡</label>
              <select id="setup-tw-quality">
                <option value="best">best - æœ€ä½³è´¨é‡ (æ¨è)</option>
                <option value="720p">720p - é«˜æ¸…</option>
                <option value="480p">480p - æ ‡æ¸…</option>
                <option value="worst">worst - æœ€ä½è´¨é‡</option>
              </select>
            </div>
          </div>

          <!-- Advanced Options -->
          <div style="border: 2px solid #e5e7eb; border-radius: 8px; padding: 20px; margin-bottom: 20px;">
            <h4 style="color: #667eea; margin-bottom: 15px;">âš™ï¸ é«˜çº§é€‰é¡¹</h4>

            <div class="control-group">
              <label>Holodex API Key (å¯é€‰)</label>
              <input type="text" id="setup-holodex" placeholder="ç”¨äº YouTube ç›´æ’­çŠ¶æ€æ£€æµ‹">
              <small style="color: #888;">è·å–: <a href="https://holodex.net/login"
                  target="_blank">holodex.net</a></small>
            </div>

            <div class="control-group">
              <label style="display: flex; align-items: center; gap: 10px;">
                <input type="checkbox" id="setup-lol-monitor" onchange="toggleRiotApiKey()">
                <span>å¯ç”¨è‹±é›„è”ç›Ÿç©å®¶IDç›‘æ§</span>
              </label>
            </div>

            <div class="control-group" id="riot-api-group" style="display: none;">
              <label>Riot API Key</label>
              <input type="text" id="setup-riot" placeholder="ç”¨äºç›‘æ§æ¸¸æˆå†…è¿ç¦è¯æ±‡">
              <small style="color: #888;">è·å–: <a href="https://developer.riotgames.com/"
                  target="_blank">developer.riotgames.com</a></small>
            </div>
          </div>

          <div style="display: flex; gap: 10px; margin-top: 20px;">
            <button class="btn-secondary" onclick="goToStep(2)" style="flex: 1;">
              â† ä¸Šä¸€æ­¥
            </button>
            <button class="btn-success" onclick="saveSetupConfig()" style="flex: 1;">
              âœ… å®Œæˆè®¾ç½®
            </button>
          </div>
        </div>

        <p style="text-align: center; color: #999; margin-top: 20px; font-size: 14px;">
          éœ€è¦å¸®åŠ©ï¼ŸæŸ¥çœ‹ <a href="https://github.com/Detteee/bilistream" target="_blank" style="color: #667eea;">æ–‡æ¡£</a>
        </p>
      </div>
    </div>
  </div>

  <!-- Main Page -->
  <div class="main-page" id="main-page">
    <div class="container">
      <div class="header">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
          <h1 style="margin: 0;">
            <svg width="48" height="48" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"
              style="vertical-align: middle; margin-right: 10px;">
              <g>
                <path d="M0 2A2 2 0 0 1 3 .3l15.5 9.3a2 2 0 0 1 0 3.5L3.1 22.4A2 2 0 0 1 0 20.7V2Z" fill="url(#b)" />
                <path d="M4.57 2a2 2 0 0 1 3-1.7L23 9.6a2 2 0 0 1 0 3.5L7.6 22.4a2 2 0 0 1-3-1.7V2Z" fill="url(#a)" />
              </g>
              <defs>
                <linearGradient id="a" x1=".2" y1="2.8" x2="19.3" y2="18.5" gradientUnits="userSpaceOnUse">
                  <stop stop-color="#FD0031" />
                  <stop offset="1" stop-color="#FC4085" />
                </linearGradient>
                <linearGradient id="b" x1="-4.4" y1="2.8" x2="19.5" y2="11.3" gradientUnits="userSpaceOnUse">
                  <stop stop-color="#55ACEE" />
                  <stop offset="0.6" stop-color="#8264E5" stop-opacity=".3" />
                </linearGradient>
              </defs>
            </svg>
            Bilistream
          </h1>
          <button onclick="toggleTheme()" id="theme-toggle"
            style="padding: 10px 20px; background: rgba(255,255,255,0.2); color: white; border: 1px solid rgba(255,255,255,0.3); border-radius: 8px; cursor: pointer; font-size: 14px; font-weight: 600; transition: all 0.3s ease; backdrop-filter: blur(10px);">
            ğŸŒ™ æš—è‰²
          </button>
        </div>
        <p style="color: var(--header-text);">å®æ—¶ç›‘æ§å’Œæ§åˆ¶ä½ çš„è½¬æ’­</p>
      </div>

      <div class="dashboard">
        <div class="card">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
            <h2 style="margin: 0;">
              <span class="status-indicator" id="bili-status"></span>
              å“”å“©å“”å“©
            </h2>
            <button onclick="refreshBilibiliStatus()"
              style="padding: 8px; background: linear-gradient(135deg, #89b4fa 0%, #cba6f7 100%); color: #1e1e2e; border: none; border-radius: 6px; cursor: pointer; transition: all 0.3s ease; display: flex; align-items: center; justify-content: center;">
              <svg fill="currentColor" width="16" height="16" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path
                  d="M19.146 4.854l-1.489 1.489A8 8 0 1 0 12 20a8.094 8.094 0 0 0 7.371-4.886 1 1 0 1 0-1.842-.779A6.071 6.071 0 0 1 12 18a6 6 0 1 1 4.243-10.243l-1.39 1.39a.5.5 0 0 0 .354.854H19.5A.5.5 0 0 0 20 9.5V5.207a.5.5 0 0 0-.854-.353z" />
              </svg>
            </button>
          </div>
          <div class="info-row">
            <span class="info-label">çŠ¶æ€</span>
            <span class="info-value" id="bili-live-status">åŠ è½½ä¸­...</span>
          </div>
          <div class="info-row">
            <span class="info-label">æ ‡é¢˜</span>
            <span class="info-value" id="bili-title">-</span>
          </div>
          <div class="info-row">
            <span class="info-label">åˆ†åŒº</span>
            <span class="info-value" id="bili-area">-</span>
          </div>
          <div class="info-row" id="bili-stream-quality-row" style="display: none;">
            <span class="info-label">æµè´¨é‡</span>
            <span class="info-value" id="bili-stream-quality">-</span>
          </div>
        </div>

        <div class="card">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
            <h2 style="margin: 0;">
              <span class="status-indicator" id="yt-status"></span>
              YouTube
            </h2>
            <button onclick="refreshYouTubeStatus()"
              style="padding: 8px; background: linear-gradient(135deg, #89b4fa 0%, #cba6f7 100%); color: #1e1e2e; border: none; border-radius: 6px; cursor: pointer; transition: all 0.3s ease; display: flex; align-items: center; justify-content: center;">
              <svg fill="currentColor" width="16" height="16" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path
                  d="M19.146 4.854l-1.489 1.489A8 8 0 1 0 12 20a8.094 8.094 0 0 0 7.371-4.886 1 1 0 1 0-1.842-.779A6.071 6.071 0 0 1 12 18a6 6 0 1 1 4.243-10.243l-1.39 1.39a.5.5 0 0 0 .354.854H19.5A.5.5 0 0 0 20 9.5V5.207a.5.5 0 0 0-.854-.353z" />
              </svg>
            </button>
          </div>
          <div class="info-row">
            <span class="info-label">é¢‘é“</span>
            <span class="info-value" id="yt-channel-name">-</span>
          </div>
          <div class="info-row">
            <span class="info-label">çŠ¶æ€</span>
            <span class="info-value" id="yt-live-status">åŠ è½½ä¸­...</span>
          </div>
          <div class="info-row">
            <span class="info-label">æ ‡é¢˜</span>
            <span class="info-value" id="yt-title">-</span>
          </div>
          <div class="info-row">
            <span class="info-label">åˆ†åŒº</span>
            <span class="info-value" id="yt-topic">-</span>
          </div>
        </div>

        <div class="card">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
            <h2 style="margin: 0;">
              <span class="status-indicator" id="tw-status"></span>
              Twitch
            </h2>
            <button onclick="refreshTwitchStatus()"
              style="padding: 8px; background: linear-gradient(135deg, #89b4fa 0%, #cba6f7 100%); color: #1e1e2e; border: none; border-radius: 6px; cursor: pointer; transition: all 0.3s ease; display: flex; align-items: center; justify-content: center;">
              <svg fill="currentColor" width="16" height="16" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path
                  d="M19.146 4.854l-1.489 1.489A8 8 0 1 0 12 20a8.094 8.094 0 0 0 7.371-4.886 1 1 0 1 0-1.842-.779A6.071 6.071 0 0 1 12 18a6 6 0 1 1 4.243-10.243l-1.39 1.39a.5.5 0 0 0 .354.854H19.5A.5.5 0 0 0 20 9.5V5.207a.5.5 0 0 0-.854-.353z" />
              </svg>
            </button>
          </div>
          <div class="info-row">
            <span class="info-label">é¢‘é“</span>
            <span class="info-value" id="tw-channel-name">-</span>
          </div>
          <div class="info-row">
            <span class="info-label">çŠ¶æ€</span>
            <span class="info-value" id="tw-live-status">åŠ è½½ä¸­...</span>
          </div>
          <div class="info-row">
            <span class="info-label">æ ‡é¢˜</span>
            <span class="info-value" id="tw-title">-</span>
          </div>
          <div class="info-row">
            <span class="info-label">æ¸¸æˆ</span>
            <span class="info-value" id="tw-game">-</span>
          </div>
        </div>
      </div>

      <div class="controls">
        <h2>âš™ï¸ æ§åˆ¶é¢æ¿</h2>

        <div class="control-group">
          <label>å‘é€å¼¹å¹•</label>
          <div style="display: flex; gap: 10px;">
            <input type="text" id="danmaku-input" placeholder="è¾“å…¥å¼¹å¹•å†…å®¹..." style="flex: 1;">
            <button class="btn-primary" onclick="sendDanmaku()">å‘é€</button>
          </div>
        </div>

        <div class="control-group">
          <label>æ›´æ–°åˆ†åŒº</label>
          <div style="display: flex; gap: 10px;">
            <select id="area-input" style="flex: 1;">
              <option value="">é€‰æ‹©åˆ†åŒº...</option>
            </select>
            <button class="btn-secondary" onclick="updateArea()">æ›´æ–°</button>
          </div>
        </div>

        <div class="button-group">
          <button class="btn-success" onclick="startStream()">å¼€å§‹ç›´æ’­</button>
          <button class="btn-danger" onclick="stopStream()">åœæ­¢ç›´æ’­</button>
          <button class="btn-primary" onclick="restartStream()"
            style="display: flex; align-items: center; justify-content: center; gap: 6px;">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16" fill="none"
              stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path
                d="M22 12c0 6-4.39 10-9.806 10C7.792 22 4.24 19.665 3 16m-1-4C2 6 6.39 2 11.807 2C16.208 2 19.758 4.335 21 8" />
              <path d="m7 17l-4-1l-1 4M17 7l4 1l1-4" />
            </svg>
            <span>é‡å¯æµ</span>
          </button>
        </div>
      </div>

      <div class="controls" style="margin-top: 20px;">
        <h2 style="cursor: pointer; user-select: none;" onclick="toggleChannelManagement()">
          ğŸ“º é¢‘é“ç®¡ç† <span id="channel-toggle">â–¼</span>
        </h2>

        <div id="channel-management-container" style="display: none;">
          <div class="control-group">
            <label>å¹³å°</label>
            <select id="platform-select" onchange="updateChannelList()">
              <option value="youtube">YouTube</option>
              <option value="twitch">Twitch</option>
            </select>
          </div>

          <div class="control-group">
            <label>é€‰æ‹©é¢‘é“ (å¯é€‰)</label>
            <select id="channel-select" onchange="updateChannelInfo()">
              <option value="">é€‰æ‹©é¢„è®¾é¢‘é“æˆ–æ‰‹åŠ¨è¾“å…¥...</option>
            </select>
          </div>

          <div class="control-group">
            <label>é¢‘é“ID (å¿…å¡«)</label>
            <input type="text" id="channel-id-input" placeholder="è¾“å…¥é¢‘é“IDæˆ–ä»ä¸Šæ–¹é€‰æ‹©">
          </div>

          <div class="control-group">
            <label>é¢‘é“åç§° (å¿…å¡«)</label>
            <input type="text" id="channel-name-input" placeholder="è¾“å…¥é¢‘é“åç§°æˆ–ä»ä¸Šæ–¹é€‰æ‹©">
          </div>

          <div class="control-group">
            <label>åˆ†åŒº (å¯é€‰)</label>
            <select id="area-select" onchange="toggleLolMonitorInputs()">
              <option value="">ä¸ä¿®æ”¹åˆ†åŒº</option>
            </select>
          </div>

          <div class="control-group" id="lol-monitor-group" style="display: none;">
            <label style="display: flex; align-items: center; gap: 10px;">
              <input type="checkbox" id="enable-lol-monitor-inline" onchange="toggleRiotApiKeyInputInline()">
              <span>å¯ç”¨è‹±é›„è”ç›Ÿç©å®¶IDç›‘æ§</span>
            </label>
            <small style="color: #888; display: block; margin-top: 5px;">
              ç›‘æ§æ¸¸æˆå†…ç©å®¶IDæ˜¯å¦åŒ…å«è¿ç¦è¯æ±‡
            </small>
          </div>

          <div class="control-group" id="riot-api-key-group" style="display: none;">
            <label>Riot API Key</label>
            <input type="text" id="riot-api-key-input" placeholder="ç•™ç©ºè¡¨ç¤ºä¸ä¿®æ”¹">
            <small style="color: #888; display: block; margin-top: 5px;">
              è·å–: <a href="https://developer.riotgames.com/" target="_blank">developer.riotgames.com</a>
            </small>
          </div>

          <div class="control-group">
            <label>ç”»è´¨ (å¯é€‰)</label>
            <select id="quality-select" onchange="updateQualityOptions()">
              <option value="">ä¸ä¿®æ”¹ç”»è´¨</option>
              <option value="best">best - æœ€ä½³ç”»è´¨ (æ¨è)</option>
              <option value="720p">720p - é«˜æ¸…</option>
              <option value="480p">480p - æ ‡æ¸…</option>
              <option value="360p" data-platform="youtube">360p - æµç•… (ä»…YouTube)</option>
              <option value="worst">worst - æœ€ä½ç”»è´¨</option>
            </select>
          </div>

          <div class="button-group">
            <button class="btn-primary" onclick="applyChannelChange()">åº”ç”¨æ›´æ”¹</button>
            <button class="btn-secondary" onclick="loadChannelData()">åˆ·æ–°é¢‘é“åˆ—è¡¨</button>
          </div>
        </div>
      </div>

      <div class="controls" id="holodex-section" style="margin-top: 20px; display: none;">
        <h2 style="cursor: pointer; user-select: none; display: flex; align-items: center; gap: 8px;"
          onclick="toggleHolodex()">
          <svg viewBox="0 0 24 24" focusable="false" style="width: 24px; height: 24px;">
            <g>
              <path d="M4.5 2a2 2 0 0 1 3-1.7L23 9.6a2 2 0 0 1 0 3.5L7.6 22.4a2 2 0 0 1-3-1.7V2Z"
                fill="url(#holodex-a)">
              </path>
              <path d="M0 2A2 2 0 0 1 3 .3l15.5 9.3a2 2 0 0 1 0 3.5L3.1 22.4A2 2 0 0 1 0 20.7V2Z"
                fill="url(#holodex-b)">
              </path>
            </g>
            <defs>
              <linearGradient id="holodex-a" x1=".2" y1="2.8" x2="19.3" y2="18.5" gradientUnits="userSpaceOnUse">
                <stop stop-color="#F06292"></stop>
                <stop offset="1" stop-color="#FF3A81"></stop>
              </linearGradient>
              <linearGradient id="holodex-b" x1="-4.4" y1="2.8" x2="19.5" y2="11.3" gradientUnits="userSpaceOnUse">
                <stop stop-color="#5DA2F2"></stop>
                <stop offset="1" stop-color="#715BF7" stop-opacity=".8"></stop>
              </linearGradient>
            </defs>
          </svg>
          <span>Holodex ç›´æ’­ç›‘æ§</span>
          <span id="holodex-toggle">â–¼</span>
        </h2>
        <div id="holodex-container" style="display: none;">
          <div id="holodex-status"
            style="padding: 15px; background: #f0f0f0; border-radius: 8px; margin-bottom: 15px; text-align: center;">
            åŠ è½½ä¸­...
          </div>
          <div id="holodex-streams"
            style="display: grid; grid-template-columns: repeat(auto-fill, minmax(min(100%, 320px), 1fr)); gap: 15px; margin-bottom: 15px;">
            <!-- Streams will be populated here -->
          </div>
          <button class="btn-primary" onclick="refreshHolodexStreams()"
            style="width: 100%; display: flex; align-items: center; justify-content: center; gap: 8px;">
            <svg fill="currentColor" width="16" height="16" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
              <path
                d="M19.146 4.854l-1.489 1.489A8 8 0 1 0 12 20a8.094 8.094 0 0 0 7.371-4.886 1 1 0 1 0-1.842-.779A6.071 6.071 0 0 1 12 18a6 6 0 1 1 4.243-10.243l-1.39 1.39a.5.5 0 0 0 .354.854H19.5A.5.5 0 0 0 20 9.5V5.207a.5.5 0 0 0-.854-.353z" />
            </svg>
            <span>åˆ·æ–°ç›´æ’­åˆ—è¡¨</span>
          </button>
        </div>
      </div>

      <div class="controls" style="margin-top: 20px;">
        <h2 style="cursor: pointer; user-select: none;" onclick="toggleLogs()">
          ğŸ“‹ ç³»ç»Ÿæ—¥å¿— <span id="log-toggle">â–¼</span>
        </h2>
        <div id="log-container" style="display: none;">
          <div
            style="background: #1e1e1e; color: #d4d4d4; padding: 15px; border-radius: 8px; font-family: 'SF Mono', 'Consolas', 'Liberation Mono', 'Menlo', 'Courier New', monospace; font-size: 14px; max-height: 400px; overflow-y: auto; line-height: 1.4; white-space: pre; overflow-x: auto;">
            <div id="log-output">ç­‰å¾…æ—¥å¿—...</div>
          </div>
          <div style="margin-top: 10px; display: flex; gap: 10px;">
            <button class="btn-secondary" onclick="clearLogs()">æ¸…ç©ºæ—¥å¿—</button>
            <button class="btn-primary" onclick="refreshLogs()" style="display: flex; align-items: center; gap: 6px;">
              <svg fill="currentColor" width="14" height="14" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path
                  d="M19.146 4.854l-1.489 1.489A8 8 0 1 0 12 20a8.094 8.094 0 0 0 7.371-4.886 1 1 0 1 0-1.842-.779A6.071 6.071 0 0 1 12 18a6 6 0 1 1 4.243-10.243l-1.39 1.39a.5.5 0 0 0 .354.854H19.5A.5.5 0 0 0 20 9.5V5.207a.5.5 0 0 0-.854-.353z" />
              </svg>
              <span>åˆ·æ–°æ—¥å¿—</span>
            </button>
            <label style="display: flex; align-items: center; gap: 5px; color: #666;">
              <input type="checkbox" id="auto-scroll-checkbox" checked> è‡ªåŠ¨æ»šåŠ¨
            </label>
          </div>
        </div>
      </div>

      <div style="text-align: center; color: white; margin-top: 40px; padding: 20px; opacity: 0.8;">
        <p style="margin-bottom: 10px;">
          <span id="version-display">Bilistream</span>
          <button onclick="checkForUpdates()"
            style="margin-left: 10px; padding: 5px 15px; background: rgba(255,255,255,0.2); color: white; border: 1px solid rgba(255,255,255,0.5); border-radius: 5px; cursor: pointer; font-size: 12px; display: inline-flex; align-items: center; gap: 6px;">
            <svg fill="currentColor" width="14" height="14" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
              <path
                d="M19.146 4.854l-1.489 1.489A8 8 0 1 0 12 20a8.094 8.094 0 0 0 7.371-4.886 1 1 0 1 0-1.842-.779A6.071 6.071 0 0 1 12 18a6 6 0 1 1 4.243-10.243l-1.39 1.39a.5.5 0 0 0 .354.854H19.5A.5.5 0 0 0 20 9.5V5.207a.5.5 0 0 0-.854-.353z" />
            </svg>
            <span>æ£€æŸ¥æ›´æ–°</span>
          </button>
        </p>
        <div id="update-notification"
          style="display: none; margin: 15px auto; padding: 15px; max-width: 600px; background: rgba(16, 185, 129, 0.9); border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.3);">
          <p style="margin: 0 0 10px 0; font-weight: 600; font-size: 16px;">ğŸ‰ å‘ç°æ–°ç‰ˆæœ¬ï¼</p>
          <p id="update-message" style="margin: 0 0 10px 0; font-size: 14px;"></p>
          <div style="display: flex; gap: 10px; margin-top: 10px;">
            <button id="auto-update-btn" onclick="autoInstallUpdate()"
              style="flex: 1; padding: 8px 20px; background: white; color: #667eea; border: none; border-radius: 5px; font-weight: 600; cursor: pointer;">
              ğŸš€ è‡ªåŠ¨æ›´æ–°
            </button>
            <a id="update-link" href="#" target="_blank"
              style="flex: 1; padding: 8px 20px; background: rgba(255,255,255,0.3); color: white; text-decoration: none; border-radius: 5px; font-weight: 600; text-align: center;">
              ğŸ“¥ æ‰‹åŠ¨ä¸‹è½½
            </a>
          </div>
          <p id="update-progress"
            style="margin: 10px 0 0 0; font-size: 12px; color: rgba(255,255,255,0.9); display: none;"></p>
        </div>
        <p>
          <a href="https://github.com/Detteee/bilistream" target="_blank"
            style="color: white; text-decoration: none; border-bottom: 1px solid rgba(255,255,255,0.5); padding-bottom: 2px;">
            â­ GitHub
          </a>
          <span style="margin: 0 10px;">|</span>
          <a href="https://github.com/Detteee/bilistream/issues" target="_blank"
            style="color: white; text-decoration: none; border-bottom: 1px solid rgba(255,255,255,0.5); padding-bottom: 2px;">
            ğŸ› æŠ¥å‘Šé—®é¢˜
          </a>
        </p>
      </div>
    </div>

    <!-- Area Selection Modal -->
    <div id="area-modal"
      style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; align-items: center; justify-content: center;">
      <div
        style="background: white; border-radius: 12px; padding: 30px; max-width: 500px; width: 90%; box-shadow: 0 20px 60px rgba(0,0,0,0.3);">
        <h3 style="color: #667eea; margin-bottom: 20px;">é€‰æ‹©åˆ†åŒº</h3>
        <p style="color: #666; margin-bottom: 20px;">æœªèƒ½è‡ªåŠ¨æ£€æµ‹åˆ†åŒºï¼Œè¯·æ‰‹åŠ¨é€‰æ‹©ï¼š</p>
        <select id="modal-area-select"
          style="width: 100%; padding: 12px; border: 2px solid #e5e7eb; border-radius: 8px; font-size: 14px; margin-bottom: 20px;">
          <option value="">åŠ è½½ä¸­...</option>
        </select>
        <div style="display: flex; gap: 10px;">
          <button onclick="confirmAreaSelection()"
            style="flex: 1; padding: 12px; background: #667eea; color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer;">
            ç¡®è®¤
          </button>
          <button onclick="closeAreaModal()"
            style="flex: 1; padding: 12px; background: #6b7280; color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer;">
            å–æ¶ˆ
          </button>
        </div>
      </div>
    </div>

    <script>
      // Global data
      let channelsData = null;
      let areasData = null;
      let logLines = [];
      let maxLogLines = 500;
      let statusRefreshInterval = 60000; // Default 60 seconds
      let statusIntervalId = null;

      // Global config data for access across functions
      window.configData = {
        enable_lol_monitor: false,
        riot_api_key: ''
      };

      // Auto refresh logs every 2 seconds
      setInterval(refreshLogs, 2000);

      // Load config and set up status refresh interval
      async function initStatusRefresh() {
        try {
          const response = await fetch('/api/config');
          if (response.ok) {
            const config = await response.json();

            // Store config globally
            window.configData = {
              enable_lol_monitor: config.enable_lol_monitor || false,
              riot_api_key: config.riot_api_key || '',
              holodex_api_key: config.holodex_api_key || ''
            };

            // Show/hide Holodex section based on API key configuration
            const holodexSection = document.getElementById('holodex-section');
            if (config.holodex_api_key && config.holodex_api_key.trim() !== '') {
              holodexSection.style.display = 'block';
            } else {
              holodexSection.style.display = 'none';
            }

            if (config.interval) {
              statusRefreshInterval = config.interval * 1000; // Convert to milliseconds
              console.log('Status refresh interval set to', config.interval, 'seconds');
            }

            console.log('LOL Monitor enabled:', window.configData.enable_lol_monitor);
            console.log('Holodex API configured:', !!config.holodex_api_key);
          }
        } catch (error) {
          console.log('Failed to load config, using default interval:', error);
        }

        // Start status refresh with configured interval
        if (statusIntervalId) {
          clearInterval(statusIntervalId);
        }
        statusIntervalId = setInterval(refreshStatus, statusRefreshInterval);

        // Initial refresh
        refreshStatus();
      }

      function toggleChannelManagement() {
        const container = document.getElementById('channel-management-container');
        const toggle = document.getElementById('channel-toggle');
        if (container.style.display === 'none') {
          container.style.display = 'block';
          toggle.textContent = 'â–²';
        } else {
          container.style.display = 'none';
          toggle.textContent = 'â–¼';
        }
      }

      function toggleHolodex() {
        const container = document.getElementById('holodex-container');
        const toggle = document.getElementById('holodex-toggle');
        if (container.style.display === 'none') {
          container.style.display = 'block';
          toggle.textContent = 'â–²';
          refreshHolodexStreams();
        } else {
          container.style.display = 'none';
          toggle.textContent = 'â–¼';
        }
      }

      async function refreshHolodexStreams() {
        const statusDiv = document.getElementById('holodex-status');
        const streamsDiv = document.getElementById('holodex-streams');

        statusDiv.innerHTML = 'â³ åŠ è½½ä¸­...';
        statusDiv.style.background = '#89b4fa';
        statusDiv.style.color = '#1e1e2e';
        streamsDiv.innerHTML = '';

        try {
          const response = await fetch('/api/holodex/streams');
          const data = await response.json();

          if (!data.success) {
            statusDiv.innerHTML = `âš ï¸ ${data.message}`;
            statusDiv.style.background = '#f9e2af';
            statusDiv.style.color = '#1e1e2e';
            return;
          }

          const streams = data.data || [];

          if (streams.length === 0) {
            statusDiv.innerHTML = 'âœ… å·²è¿æ¥ Holodex API - å½“å‰æ— ç›´æ’­æˆ–é¢„å‘Š';
            statusDiv.style.background = '#a6e3a1';
            statusDiv.style.color = '#1e1e2e';
            return;
          }

          // Separate live and scheduled streams
          const liveStreams = streams.filter(s => s.status === 'live');
          const scheduledStreams = streams.filter(s => s.status !== 'live');

          statusDiv.innerHTML = `âœ… æ‰¾åˆ° ${liveStreams.length} ä¸ªç›´æ’­, ${scheduledStreams.length} ä¸ªé¢„å‘Š`;
          statusDiv.style.background = '#a6e3a1';
          statusDiv.style.color = '#1e1e2e';

          // Render live streams first
          liveStreams.forEach(stream => {
            streamsDiv.appendChild(createStreamCard(stream, true));
          });

          // Add divider if both live and scheduled exist
          if (liveStreams.length > 0 && scheduledStreams.length > 0) {
            const divider = document.createElement('div');
            divider.style.cssText = 'grid-column: 1 / -1; height: 2px; background: linear-gradient(to right, transparent, var(--heading-color), transparent); margin: 10px 0; position: relative;';
            divider.innerHTML = '<span style="position: absolute; top: -10px; left: 50%; transform: translateX(-50%); background: var(--card-bg); padding: 0 15px; color: var(--heading-color); font-size: 12px; font-weight: 600;">é¢„å‘Š</span>';
            streamsDiv.appendChild(divider);
          }

          // Render scheduled streams
          scheduledStreams.forEach(stream => {
            streamsDiv.appendChild(createStreamCard(stream, false));
          });

        } catch (error) {
          statusDiv.innerHTML = `âŒ è¯·æ±‚å¤±è´¥: ${error.message}`;
          statusDiv.style.background = '#f38ba8';
          statusDiv.style.color = '#1e1e2e';
        }
      }

      function createStreamCard(stream, isLive) {
        const streamCard = document.createElement('div');
        streamCard.style.cssText = 'background: var(--card-bg); border: 2px solid var(--card-border); border-radius: 8px; padding: 15px; transition: all 0.2s; min-width: 0; overflow: hidden;';
        streamCard.onmouseenter = () => {
          streamCard.style.transform = 'translateY(-2px)';
          streamCard.style.boxShadow = '0 4px 12px var(--shadow-hover)';
        };
        streamCard.onmouseleave = () => {
          streamCard.style.transform = 'translateY(0)';
          streamCard.style.boxShadow = 'none';
        };

        const statusBadge = isLive
          ? '<span style="background: #f38ba8; color: #1e1e2e; padding: 3px 8px; border-radius: 4px; font-size: 12px; font-weight: 600;">ğŸ”´ ç›´æ’­ä¸­</span>'
          : '<span style="background: #89b4fa; color: #1e1e2e; padding: 3px 8px; border-radius: 4px; font-size: 12px; font-weight: 600;">ğŸ“… é¢„å‘Š</span>';

        const viewers = stream.live_viewers ? `${stream.live_viewers.toLocaleString()} è§‚çœ‹` : '';
        const scheduledTime = stream.start_scheduled ? new Date(stream.start_scheduled).toLocaleString('zh-CN') : '';
        const actualTime = stream.start_actual ? new Date(stream.start_actual).toLocaleString('zh-CN') : '';

        let areaInfo = '';
        if (stream.suggested_area_id && stream.suggested_area_name) {
          areaInfo = `<p style="color: #a6e3a1; font-size: 12px; margin: 5px 0;">ğŸ¯ å»ºè®®åˆ†åŒº: ${stream.suggested_area_name}</p>`;
        }

        streamCard.innerHTML = `
          <div style="margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center;">
            <div>
              ${statusBadge}
              ${viewers ? `<span style="margin-left: 10px; color: var(--text-secondary); font-size: 14px;">${viewers}</span>` : ''}
            </div>
          </div>
          ${stream.channel_name ? `<p style="color: var(--text-muted); font-size: 12px; margin: 5px 0; font-weight: 500; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">ğŸ‘¤ ${stream.channel_name}</p>` : ''}
          <h4 style="margin: 10px 0; color: var(--text-primary); font-size: 14px; line-height: 1.4; font-weight: 600; word-wrap: break-word; overflow-wrap: break-word;">${stream.title}</h4>
          ${stream.topic_id ? `<p style="color: var(--heading-color); font-size: 12px; margin: 5px 0;">ğŸ® ${stream.topic_id}</p>` : ''}
          ${areaInfo}
          ${isLive && actualTime ? `<p style="color: var(--text-secondary); font-size: 12px; margin: 5px 0;">â° å¼€å§‹: ${actualTime}</p>` : ''}
          ${!isLive && scheduledTime ? `<p style="color: var(--text-secondary); font-size: 12px; margin: 5px 0;">â° é¢„å®š: ${scheduledTime}</p>` : ''}
          <div style="margin-top: 12px; display: flex; gap: 8px;">
            <a href="https://www.youtube.com/watch?v=${stream.id}" target="_blank" 
               style="flex: 1; padding: 6px 12px; background: linear-gradient(135deg, #89b4fa 0%, #cba6f7 100%); color: #1e1e2e; text-decoration: none; border-radius: 4px; font-size: 12px; text-align: center; font-weight: 600;">
              ğŸ“º è§‚çœ‹
            </a>
            <button onclick="switchToHolodexStream('${stream.channel_id}', ${stream.suggested_area_id || 'null'})" 
               style="flex: 1; padding: 6px 12px; background: #a6e3a1; color: #1e1e2e; border: none; border-radius: 4px; font-size: 12px; cursor: pointer; font-weight: 600; display: flex; align-items: center; justify-content: center; gap: 4px;">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 12c0 6-4.39 10-9.806 10C7.792 22 4.24 19.665 3 16m-1-4C2 6 6.39 2 11.807 2C16.208 2 19.758 4.335 21 8"/><path d="m7 17l-4-1l-1 4M17 7l4 1l1-4"/></svg>
              <span>åˆ‡æ¢</span>
            </button>
          </div>
        `;

        return streamCard;
      }

      // Store pending switch data
      let pendingSwitchData = null;

      async function switchToHolodexStream(channelId, suggestedAreaId) {
        if (!suggestedAreaId) {
          // Show modal for area selection
          pendingSwitchData = { channelId, areaId: null };
          await showAreaModal();
        } else {
          // Direct switch with suggested area
          await performSwitch(channelId, suggestedAreaId);
        }
      }

      async function showAreaModal() {
        const modal = document.getElementById('area-modal');
        const select = document.getElementById('modal-area-select');

        // Load areas if not already loaded
        if (!areasData) {
          try {
            const response = await fetch('/api/areas');
            const data = await response.json();
            areasData = data;
          } catch (error) {
            showNotification('åŠ è½½åˆ†åŒºåˆ—è¡¨å¤±è´¥', 'error');
            return;
          }
        }

        // Populate select
        select.innerHTML = '<option value="">é€‰æ‹©åˆ†åŒº...</option>';
        if (areasData && areasData.areas) {
          areasData.areas.forEach(area => {
            const option = document.createElement('option');
            option.value = area.id;
            option.textContent = `${area.name} (${area.id})`;
            select.appendChild(option);
          });
        }

        modal.style.display = 'flex';
      }

      function closeAreaModal() {
        document.getElementById('area-modal').style.display = 'none';
        pendingSwitchData = null;
      }

      async function confirmAreaSelection() {
        const select = document.getElementById('modal-area-select');
        const areaId = parseInt(select.value);

        if (!areaId) {
          showNotification('è¯·é€‰æ‹©åˆ†åŒº', 'error');
          return;
        }

        if (!pendingSwitchData) {
          console.error('No pending switch data');
          closeAreaModal();
          return;
        }

        const channelId = pendingSwitchData.channelId;
        closeAreaModal();
        await performSwitch(channelId, areaId);
      }

      async function performSwitch(channelId, areaId) {
        try {
          console.log('Switching to channel:', channelId, 'area:', areaId);
          const response = await fetch('/api/holodex/switch', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              channel_id: channelId,
              area_id: areaId
            })
          });

          console.log('Response status:', response.status);
          const data = await response.json();
          console.log('Response data:', data);

          if (data.success) {
            showNotification(data.message || 'é¢‘é“åˆ‡æ¢æˆåŠŸï¼', 'success');
            setTimeout(() => refreshStatus(), 2000);
          } else {
            showNotification(data.message || 'åˆ‡æ¢å¤±è´¥', 'error');
            console.error('Switch failed:', data.message);
          }
        } catch (error) {
          showNotification('åˆ‡æ¢å¤±è´¥: ' + error.message, 'error');
          console.error('Switch error:', error);
        }
      }

      function toggleLogs() {
        const container = document.getElementById('log-container');
        const toggle = document.getElementById('log-toggle');
        if (container.style.display === 'none') {
          container.style.display = 'block';
          toggle.textContent = 'â–²';
          refreshLogs();
        } else {
          container.style.display = 'none';
          toggle.textContent = 'â–¼';
        }
      }

      function clearLogs() {
        logLines = [];
        document.getElementById('log-output').innerHTML = 'æ—¥å¿—å·²æ¸…ç©º';
      }

      async function refreshLogs() {
        try {
          const response = await fetch('/api/logs');
          if (!response.ok) return;

          const data = await response.json();
          if (data.success && data.logs) {
            // Add new logs
            const newLogs = data.logs.split('\n').filter(line => line.trim());
            newLogs.forEach(line => {
              if (!logLines.includes(line)) {
                logLines.push(line);
              }
            });

            // Keep only last maxLogLines
            if (logLines.length > maxLogLines) {
              logLines = logLines.slice(-maxLogLines);
            }

            // Format and display logs
            const logOutput = document.getElementById('log-output');
            logOutput.innerHTML = logLines.map(line => {
              // Escape HTML to prevent XSS
              const escaped = line
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
              // Don't replace spaces - let white-space: pre handle it

              // Color code log levels
              let coloredLine = escaped;
              if (line.includes('ERROR') || line.includes('âŒ')) {
                coloredLine = `<span style="color: #f87171;">${escaped}</span>`;
              } else if (line.includes('WARN') || line.includes('âš ï¸')) {
                coloredLine = `<span style="color: #fbbf24;">${escaped}</span>`;
              } else if (line.includes('INFO') || line.includes('âœ…') || line.includes('ğŸš€')) {
                coloredLine = `<span style="color: #60a5fa;">${escaped}</span>`;
              } else if (line.includes('DEBUG') || line.includes('ğŸ”„')) {
                coloredLine = `<span style="color: #a78bfa;">${escaped}</span>`;
              }
              return coloredLine;
            }).join('\n');

            // Auto scroll if enabled
            if (document.getElementById('auto-scroll-checkbox').checked) {
              logOutput.parentElement.scrollTop = logOutput.parentElement.scrollHeight;
            }
          }
        } catch (error) {
          // Silently fail - logs are optional
          console.log('Failed to fetch logs:', error);
        }
      }

      function showNotification(message, type = 'success') {
        const notification = document.createElement('div');
        notification.className = `notification ${type}`;
        notification.textContent = message;
        document.body.appendChild(notification);

        setTimeout(() => {
          notification.remove();
        }, 3000);
      }

      async function refreshBilibiliStatus() {
        // Bilibili status is always fetched fresh, just refresh the display
        await refreshStatus();
      }

      async function refreshYouTubeStatus() {
        // YouTube status comes from cache updated by main loop
        await refreshStatus();
      }

      async function refreshTwitchStatus() {
        // Twitch status comes from cache updated by main loop
        await refreshStatus();
      }

      async function refreshStatus() {
        try {
          const response = await fetch('/api/status');

          if (!response.ok) {
            const errorText = await response.text();
            console.error('API Error:', response.status, errorText);
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }

          const text = await response.text();
          console.log('API Response Text:', text); // Debug log

          if (!text) {
            throw new Error('Empty response from server');
          }

          const data = JSON.parse(text);
          console.log('Parsed Data:', data); // Debug log

          if (!data.success) {
            // API returned an error
            throw new Error(data.message || 'æœåŠ¡å™¨è¿”å›é”™è¯¯');
          }

          if (data.success && data.data) {
            // Update Bilibili status
            const bili = data.data.bilibili;
            document.getElementById('bili-status').className =
              `status-indicator ${bili.is_live ? 'status-live' : 'status-offline'}`;
            document.getElementById('bili-live-status').textContent =
              bili.is_live ? 'ç›´æ’­ä¸­' : 'æœªç›´æ’­';
            document.getElementById('bili-title').textContent = bili.title || '-';
            document.getElementById('bili-area').textContent =
              bili.area_name ? `${bili.area_name} (${bili.area_id})` : (bili.area_id || '-');

            // Update stream quality
            const qualityRow = document.getElementById('bili-stream-quality-row');
            const qualityElement = document.getElementById('bili-stream-quality');
            if (bili.is_live && bili.stream_quality) {
              qualityRow.style.display = '';
              const speedText = bili.stream_speed ? ` (${bili.stream_speed.toFixed(2)}x)` : '';
              qualityElement.textContent = bili.stream_quality + speedText;

              // Set color based on quality
              if (bili.stream_quality === 'æµç•…') {
                qualityElement.style.color = '#10b981'; // green
              } else if (bili.stream_quality === 'æ³¢åŠ¨') {
                qualityElement.style.color = '#f59e0b'; // orange
              } else if (bili.stream_quality === 'å¡é¡¿') {
                qualityElement.style.color = '#ef4444'; // red
              }
            } else {
              qualityRow.style.display = 'none';
            }

            // Update YouTube status
            if (data.data.youtube) {
              const yt = data.data.youtube;
              document.getElementById('yt-status').className =
                `status-indicator ${yt.is_live ? 'status-live' : 'status-offline'}`;
              document.getElementById('yt-channel-name').textContent = yt.channel_name || '-';
              document.getElementById('yt-live-status').textContent =
                yt.is_live ? 'ç›´æ’­ä¸­' : 'æœªç›´æ’­';
              document.getElementById('yt-title').textContent = yt.title || '-';
              document.getElementById('yt-topic').textContent = yt.topic || '-';
            } else {
              document.getElementById('yt-status').className = 'status-indicator status-offline';
              document.getElementById('yt-channel-name').textContent = '-';
              document.getElementById('yt-live-status').textContent = 'æœªé…ç½®';
              document.getElementById('yt-title').textContent = '-';
              document.getElementById('yt-topic').textContent = '-';
            }

            // Update Twitch status
            if (data.data.twitch) {
              const tw = data.data.twitch;
              document.getElementById('tw-status').className =
                `status-indicator ${tw.is_live ? 'status-live' : 'status-offline'}`;
              document.getElementById('tw-channel-name').textContent = tw.channel_name || '-';
              document.getElementById('tw-live-status').textContent =
                tw.is_live ? 'ç›´æ’­ä¸­' : 'æœªç›´æ’­';
              document.getElementById('tw-title').textContent = tw.title || '-';
              document.getElementById('tw-game').textContent = tw.game || '-';
            } else {
              document.getElementById('tw-status').className = 'status-indicator status-offline';
              document.getElementById('tw-channel-name').textContent = '-';
              document.getElementById('tw-live-status').textContent = 'æœªé…ç½®';
              document.getElementById('tw-title').textContent = '-';
              document.getElementById('tw-game').textContent = '-';
            }
          } else {
            console.error('Invalid API response:', data);
            showNotification('è·å–çŠ¶æ€å¤±è´¥ï¼šå“åº”æ ¼å¼é”™è¯¯', 'error');
            // Show error state
            document.getElementById('bili-live-status').textContent = 'æ•°æ®é”™è¯¯';
            document.getElementById('yt-live-status').textContent = 'æ•°æ®é”™è¯¯';
            document.getElementById('tw-live-status').textContent = 'æ•°æ®é”™è¯¯';
          }
        } catch (error) {
          console.error('Failed to refresh status:', error);

          // Suppress network errors (when server is down)
          if (error.message && error.message.includes('NetworkError')) {
            console.log('Server appears to be down, suppressing error notification');
            return;
          }

          // Show more helpful error messages for other errors
          let errorMsg = error.message;
          if (errorMsg.includes('æƒé™é”™è¯¯') || errorMsg.includes('Permission denied')) {
            errorMsg = 'é…ç½®æ–‡ä»¶æƒé™é”™è¯¯ï¼è¯·åœ¨å¯æ‰§è¡Œæ–‡ä»¶æ‰€åœ¨ç›®å½•è¿è¡Œç¨‹åºã€‚';
          } else if (errorMsg.includes('ä¸å­˜åœ¨') || errorMsg.includes('No such file')) {
            errorMsg = 'é…ç½®æ–‡ä»¶ä¸å­˜åœ¨ï¼è¯·å…ˆè¿è¡Œ "bilistream setup" åˆ›å»ºé…ç½®ã€‚';
          } else if (errorMsg.includes('Failed to fetch')) {
            // Also suppress generic fetch failures
            console.log('Connection failed, suppressing error notification');
            return;
          }

          showNotification(errorMsg, 'error');

          // Show connection error state
          document.getElementById('bili-live-status').textContent = 'é…ç½®é”™è¯¯';
          document.getElementById('yt-live-status').textContent = 'é…ç½®é”™è¯¯';
          document.getElementById('tw-live-status').textContent = 'é…ç½®é”™è¯¯';
        }
      }

      async function startStream() {
        try {
          const response = await fetch('/api/start', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({})
          });
          const data = await response.json();
          showNotification(data.message || 'ç›´æ’­å·²å¼€å§‹', 'success');
          setTimeout(refreshStatus, 2000);
        } catch (error) {
          showNotification('æ“ä½œå¤±è´¥: ' + error.message, 'error');
        }
      }

      async function stopStream() {
        try {
          const response = await fetch('/api/stop', {
            method: 'POST'
          });
          const data = await response.json();
          showNotification(data.message || 'ç›´æ’­å·²åœæ­¢', 'success');
          setTimeout(refreshStatus, 2000);
        } catch (error) {
          showNotification('æ“ä½œå¤±è´¥: ' + error.message, 'error');
        }
      }

      async function restartStream() {
        if (!confirm('ç¡®å®šè¦åœæ­¢å½“å‰æµå¹¶é‡æ–°åŠ è½½é…ç½®å—ï¼Ÿ')) {
          return;
        }

        try {
          const response = await fetch('/api/restart', {
            method: 'POST'
          });
          const data = await response.json();
          showNotification(data.message || 'å·²é‡å¯æµ', 'success');
          setTimeout(refreshStatus, 2000);
        } catch (error) {
          showNotification('æ“ä½œå¤±è´¥: ' + error.message, 'error');
        }
      }

      async function sendDanmaku() {
        const message = document.getElementById('danmaku-input').value;
        if (!message) {
          showNotification('è¯·è¾“å…¥å¼¹å¹•å†…å®¹', 'error');
          return;
        }

        try {
          const response = await fetch('/api/danmaku', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ message })
          });
          const data = await response.json();
          showNotification(data.message || 'å¼¹å¹•å·²å‘é€', 'success');
          document.getElementById('danmaku-input').value = '';
        } catch (error) {
          showNotification('å‘é€å¤±è´¥: ' + error.message, 'error');
        }
      }

      async function updateArea() {
        const areaId = parseInt(document.getElementById('area-input').value);
        if (!areaId) {
          showNotification('è¯·é€‰æ‹©åˆ†åŒº', 'error');
          return;
        }

        try {
          const response = await fetch('/api/area', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ area_id: areaId })
          });
          const data = await response.json();
          showNotification(data.message || 'åˆ†åŒºå·²æ›´æ–°', 'success');
          document.getElementById('area-input').value = '';
          setTimeout(refreshStatus, 2000);
        } catch (error) {
          showNotification('æ›´æ–°å¤±è´¥: ' + error.message, 'error');
        }
      }

      // Channel management functions
      async function loadChannelData() {
        try {
          // Load channels
          const channelsResponse = await fetch('/api/channels');
          channelsData = await channelsResponse.json();
          console.log('Channels loaded:', channelsData);

          // Load areas
          const areasResponse = await fetch('/api/areas');
          areasData = await areasResponse.json();
          console.log('Areas loaded:', areasData);

          // Populate area select
          const areaSelect = document.getElementById('area-select');
          areaSelect.innerHTML = '<option value="">ä¸ä¿®æ”¹åˆ†åŒº</option>';

          // Handle both array and object responses
          let areasList = [];
          if (Array.isArray(areasData)) {
            areasList = areasData;
          } else if (areasData && areasData.areas) {
            areasList = areasData.areas;
          }

          if (areasList.length > 0) {
            console.log('Populating areas, count:', areasList.length);

            // Sort areas: å…¶ä»–å•æœº (235) first, then others
            const sortedAreas = [...areasList].sort((a, b) => {
              if (a.id === 235) return -1;
              if (b.id === 235) return 1;
              return 0;
            });

            // Populate channel management area select
            sortedAreas.forEach(area => {
              const option = document.createElement('option');
              option.value = area.id;
              option.textContent = `${area.name} (${area.id})`;
              areaSelect.appendChild(option);
            });

            // Also populate control panel area select
            const controlAreaSelect = document.getElementById('area-input');
            if (controlAreaSelect) {
              controlAreaSelect.innerHTML = '<option value="">é€‰æ‹©åˆ†åŒº...</option>';
              sortedAreas.forEach(area => {
                const option = document.createElement('option');
                option.value = area.id;
                option.textContent = `${area.name} (${area.id})`;
                controlAreaSelect.appendChild(option);
              });
            }

            console.log('Successfully populated', areasList.length, 'areas');
          } else {
            console.error('No areas data found:', areasData);
            showNotification('æœªæ‰¾åˆ°åˆ†åŒºæ•°æ®', 'error');
          }

          // Update channel list
          updateChannelList();
        } catch (error) {
          console.error('Failed to load channel data:', error);
          showNotification('åŠ è½½é¢‘é“æ•°æ®å¤±è´¥: ' + error.message, 'error');
        }
      }

      function updateChannelList() {
        const platform = document.getElementById('platform-select').value;
        const channelSelect = document.getElementById('channel-select');

        channelSelect.innerHTML = '<option value="">é€‰æ‹©é¢„è®¾é¢‘é“æˆ–æ‰‹åŠ¨è¾“å…¥...</option>';

        // Only populate if channels data is available
        if (channelsData && channelsData.channels) {
          channelsData.channels.forEach(channel => {
            if (channel.platforms && channel.platforms[platform]) {
              const option = document.createElement('option');
              option.value = JSON.stringify({
                id: channel.platforms[platform],
                name: channel.name
              });
              option.textContent = channel.name;
              channelSelect.appendChild(option);
            }
          });
        }

        // Don't clear inputs - allow manual entry to persist
        // Update quality options based on platform
        updateQualityOptions();
      }

      function updateQualityOptions() {
        const platform = document.getElementById('platform-select').value;
        const qualitySelect = document.getElementById('quality-select');
        const options = qualitySelect.querySelectorAll('option');

        options.forEach(option => {
          const platformRestriction = option.getAttribute('data-platform');
          if (platformRestriction) {
            // Show/hide 360p option based on platform
            if (platform === 'youtube' && platformRestriction === 'youtube') {
              option.style.display = '';
              option.disabled = false;
            } else if (platform === 'twitch' && platformRestriction === 'youtube') {
              option.style.display = 'none';
              option.disabled = true;
              // Reset selection if 360p was selected for Twitch
              if (qualitySelect.value === '360p') {
                qualitySelect.value = '';
              }
            }
          }
        });
      }

      function updateChannelInfo() {
        const channelSelect = document.getElementById('channel-select');
        const selectedValue = channelSelect.value;

        if (!selectedValue) {
          document.getElementById('channel-id-input').value = '';
          document.getElementById('channel-name-input').value = '';
          return;
        }

        try {
          const channelInfo = JSON.parse(selectedValue);
          document.getElementById('channel-id-input').value = channelInfo.id;
          document.getElementById('channel-name-input').value = channelInfo.name;
        } catch (error) {
          console.error('Failed to parse channel info:', error);
        }
      }

      function toggleLolMonitorInputs() {
        const areaId = document.getElementById('area-select').value;
        const lolMonitorGroup = document.getElementById('lol-monitor-group');
        const riotApiKeyGroup = document.getElementById('riot-api-key-group');
        const enableCheckbox = document.getElementById('enable-lol-monitor-inline');

        // Show LOL monitor checkbox if area is 86 (è‹±é›„è”ç›Ÿ)
        if (areaId === '86') {
          lolMonitorGroup.style.display = 'block';

          // Load current enable_lol_monitor state
          if (window.configData) {
            enableCheckbox.checked = window.configData.enable_lol_monitor || false;
          }

          // Show Riot API Key input if checkbox is checked
          if (enableCheckbox.checked) {
            riotApiKeyGroup.style.display = 'block';
          } else {
            riotApiKeyGroup.style.display = 'none';
          }
        } else {
          lolMonitorGroup.style.display = 'none';
          riotApiKeyGroup.style.display = 'none';
        }
      }

      function toggleRiotApiKeyInputInline() {
        const enableCheckbox = document.getElementById('enable-lol-monitor-inline');
        const riotApiKeyGroup = document.getElementById('riot-api-key-group');

        // Show/hide Riot API Key input based on checkbox
        if (enableCheckbox.checked) {
          riotApiKeyGroup.style.display = 'block';
        } else {
          riotApiKeyGroup.style.display = 'none';
        }
      }

      async function applyChannelChange() {
        const platform = document.getElementById('platform-select').value;
        const channelId = document.getElementById('channel-id-input').value.trim();
        const channelName = document.getElementById('channel-name-input').value.trim();
        const areaId = document.getElementById('area-select').value;
        const quality = document.getElementById('quality-select').value;
        const riotApiKey = document.getElementById('riot-api-key-input').value.trim();
        const enableLolMonitor = document.getElementById('enable-lol-monitor-inline').checked;

        if (!channelId || !channelName) {
          showNotification('è¯·è¾“å…¥é¢‘é“IDå’Œé¢‘é“åç§°', 'error');
          return;
        }

        try {
          // First, update channel info
          const channelPayload = {
            platform: platform,
            channel_id: channelId,
            channel_name: channelName
          };

          if (areaId) {
            channelPayload.area_id = parseInt(areaId);

            // Include Riot API Key if area is 86 and key is provided
            if (areaId === '86' && riotApiKey) {
              channelPayload.riot_api_key = riotApiKey;
            }
          }

          if (quality) {
            channelPayload.quality = quality;
          }

          const channelResponse = await fetch('/api/channel', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(channelPayload)
          });

          const channelData = await channelResponse.json();

          // If area is 86, also update enable_lol_monitor setting
          if (areaId === '86') {
            const configPayload = {
              enable_lol_monitor: enableLolMonitor
            };

            // Include Riot API Key in config update if provided
            if (riotApiKey) {
              configPayload.riot_api_key = riotApiKey;
            }

            await fetch('/api/config', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(configPayload)
            });

            // Update global config
            window.configData.enable_lol_monitor = enableLolMonitor;
          }

          showNotification(channelData.message || 'é¢‘é“å·²æ›´æ–°', 'success');

          // Clear Riot API Key input after successful update
          if (riotApiKey) {
            document.getElementById('riot-api-key-input').value = '';
          }

          setTimeout(refreshStatus, 2000);
        } catch (error) {
          showNotification('æ›´æ–°å¤±è´¥: ' + error.message, 'error');
        }
      }

      // Setup wizard functions
      let currentStep = 1;

      function goToStep(step) {
        // Hide all steps
        for (let i = 1; i <= 3; i++) {
          document.getElementById(`setup-step-${i}`).style.display = 'none';
          document.getElementById(`step-dot-${i}`).classList.remove('active');
        }

        // Show target step
        document.getElementById(`setup-step-${step}`).style.display = 'block';
        document.getElementById(`step-dot-${step}`).classList.add('active');
        currentStep = step;
      }

      function toggleRiotApiKey() {
        const checkbox = document.getElementById('setup-lol-monitor');
        const group = document.getElementById('riot-api-group');
        group.style.display = checkbox.checked ? 'block' : 'none';
      }

      async function checkLoginStatus() {
        try {
          const response = await fetch('/api/setup/login-status');
          const data = await response.json();

          const statusDiv = document.getElementById('login-status');
          const statusText = document.getElementById('login-status-text');

          if (data.logged_in) {
            statusDiv.style.background = '#d1fae5';
            statusDiv.style.color = '#065f46';
            statusText.textContent = 'âœ… å·²ç™»å½• Bilibili';
          } else {
            statusDiv.style.background = '#fee2e2';
            statusDiv.style.color = '#991b1b';
            statusText.textContent = 'âŒ æœªç™»å½•ï¼Œè¯·ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®ç™»å½•';
          }
        } catch (error) {
          console.error('Failed to check login status:', error);
          showNotification('æ£€æŸ¥ç™»å½•çŠ¶æ€å¤±è´¥', 'error');
        }
      }

      let loginPollInterval = null;
      let currentAuthCode = null;

      async function showQrCode() {
        try {
          // Get QR code from API
          const response = await fetch('/api/setup/qrcode');
          const data = await response.json();

          if (!data.success || !data.data) {
            showNotification(data.message || 'è·å–äºŒç»´ç å¤±è´¥', 'error');
            return;
          }

          const { qr_url, auth_code } = data.data;
          currentAuthCode = auth_code;

          // Generate QR code using external API
          const qrContainer = document.getElementById('qr-code-display');
          qrContainer.innerHTML = '';

          // Create QR code using QR Server API
          const qrImg = document.createElement('img');
          qrImg.src = `https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=${encodeURIComponent(qr_url)}`;
          qrImg.style.width = '200px';
          qrImg.style.height = '200px';
          qrContainer.appendChild(qrImg);

          // Show QR code container
          document.getElementById('qr-code-container').style.display = 'block';
          document.getElementById('show-qr-btn').textContent = 'ğŸ”„ åˆ·æ–°äºŒç»´ç ';

          // Start polling for login status
          startLoginPolling();

          showNotification('è¯·ä½¿ç”¨ Bilibili APP æ‰«ç ç™»å½•', 'success');
        } catch (error) {
          console.error('Failed to get QR code:', error);
          showNotification('è·å–äºŒç»´ç å¤±è´¥: ' + error.message, 'error');
        }
      }

      function startLoginPolling() {
        // Clear existing interval
        if (loginPollInterval) {
          clearInterval(loginPollInterval);
        }

        // Poll every 2 seconds
        loginPollInterval = setInterval(async () => {
          if (!currentAuthCode) return;

          try {
            const response = await fetch('/api/setup/poll-login', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ auth_code: currentAuthCode })
            });
            const data = await response.json();

            if (data.success && data.data) {
              const { status, message } = data.data;
              document.getElementById('qr-status').textContent = message;

              if (status === 'success') {
                clearInterval(loginPollInterval);
                loginPollInterval = null;
                showNotification('ç™»å½•æˆåŠŸï¼', 'success');
                document.getElementById('qr-code-container').style.display = 'none';
                await checkLoginStatus();
              } else if (status === 'expired') {
                clearInterval(loginPollInterval);
                loginPollInterval = null;
                showNotification('äºŒç»´ç å·²è¿‡æœŸï¼Œè¯·é‡æ–°è·å–', 'error');
                document.getElementById('qr-status').textContent = 'äºŒç»´ç å·²è¿‡æœŸ';
                document.getElementById('qr-status').style.color = '#ef4444';
              }
            }
          } catch (error) {
            console.error('Poll login failed:', error);
          }
        }, 2000);
      }

      async function triggerBiliLogin() {
        showNotification('æ­£åœ¨å¯åŠ¨ç™»å½•æµç¨‹ï¼Œè¯·åœ¨ç»ˆç«¯æŸ¥çœ‹äºŒç»´ç ...', 'success');

        try {
          const response = await fetch('/api/setup/login', {
            method: 'POST'
          });
          const data = await response.json();

          if (data.success) {
            showNotification('ç™»å½•æˆåŠŸï¼', 'success');
            await checkLoginStatus();
          } else {
            showNotification(data.message || 'ç™»å½•å¤±è´¥', 'error');
          }
        } catch (error) {
          console.error('Login failed:', error);
          showNotification('ç™»å½•å¤±è´¥: ' + error.message, 'error');
        }
      }

      async function saveSetupConfig() {
        // Validate required fields
        const room = document.getElementById('setup-room').value;
        if (!room || room <= 0) {
          showNotification('è¯·è¾“å…¥æœ‰æ•ˆçš„ç›´æ’­é—´å·', 'error');
          goToStep(2);
          return;
        }

        // Collect all configuration
        const config = {
          room: parseInt(room),
          interval: parseInt(document.getElementById('setup-interval').value) || 60,
          auto_cover: document.getElementById('setup-auto-cover').checked,
          enable_danmaku_command: document.getElementById('setup-danmaku-command').checked,
          anti_collision: document.getElementById('setup-anti-collision').checked,
          proxy: document.getElementById('setup-proxy').value || null,

          // YouTube
          youtube_channel_name: document.getElementById('setup-yt-name').value || null,
          youtube_channel_id: document.getElementById('setup-yt-id').value || null,
          youtube_area_v2: parseInt(document.getElementById('setup-yt-area').value) || null,
          youtube_quality: document.getElementById('setup-yt-quality').value || null,

          // Twitch
          twitch_channel_name: document.getElementById('setup-tw-name').value || null,
          twitch_channel_id: document.getElementById('setup-tw-id').value || null,
          twitch_area_v2: parseInt(document.getElementById('setup-tw-area').value) || null,
          twitch_oauth_token: document.getElementById('setup-tw-oauth').value || null,
          twitch_proxy_region: document.getElementById('setup-tw-region').value || null,
          twitch_quality: document.getElementById('setup-tw-quality').value || null,

          // Advanced
          holodex_api_key: document.getElementById('setup-holodex').value || null,
          riot_api_key: document.getElementById('setup-riot').value || null,
          enable_lol_monitor: document.getElementById('setup-lol-monitor').checked
        };

        try {
          const response = await fetch('/api/setup/save-config', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(config)
          });

          const data = await response.json();

          if (data.success) {
            showNotification('é…ç½®ä¿å­˜æˆåŠŸï¼æ­£åœ¨åŠ è½½æ§åˆ¶é¢æ¿...', 'success');
            setTimeout(() => {
              location.reload();
            }, 1500);
          } else {
            showNotification(data.message || 'ä¿å­˜é…ç½®å¤±è´¥', 'error');
          }
        } catch (error) {
          console.error('Failed to save config:', error);
          showNotification('ä¿å­˜é…ç½®å¤±è´¥: ' + error.message, 'error');
        }
      }

      // Setup check functions
      async function checkSetupStatus() {
        try {
          const response = await fetch('/api/setup-status');
          const data = await response.json();

          if (data.needs_setup) {
            // Show setup page
            document.getElementById('setup-page').classList.add('active');
            document.getElementById('main-page').classList.add('hidden');

            // Load areas for dropdowns
            await loadAreasForSetup();

            // Check login status
            await checkLoginStatus();
          } else {
            // Show main page
            document.getElementById('setup-page').classList.remove('active');
            document.getElementById('main-page').classList.remove('hidden');
          }

          return data.needs_setup;
        } catch (error) {
          console.error('Failed to check setup status:', error);
          // On error, show main page
          document.getElementById('setup-page').classList.remove('active');
          document.getElementById('main-page').classList.remove('hidden');
          return false;
        }
      }

      async function loadAreasForSetup() {
        try {
          const response = await fetch('/api/areas');
          const areasData = await response.json();

          let areasList = [];
          if (Array.isArray(areasData)) {
            areasList = areasData;
          } else if (areasData && areasData.areas) {
            areasList = areasData.areas;
          }

          if (areasList.length > 0) {
            const ytAreaSelect = document.getElementById('setup-yt-area');
            const twAreaSelect = document.getElementById('setup-tw-area');

            // Sort areas: å…¶ä»–å•æœº (235) first, then others
            const sortedAreas = [...areasList].sort((a, b) => {
              if (a.id === 235) return -1;
              if (b.id === 235) return 1;
              return 0;
            });

            [ytAreaSelect, twAreaSelect].forEach(select => {
              select.innerHTML = '';
              sortedAreas.forEach(area => {
                const option = document.createElement('option');
                option.value = area.id;
                option.textContent = `${area.name} (${area.id})`;
                if (area.id === 235) option.selected = true;
                select.appendChild(option);
              });
            });
          }
        } catch (error) {
          console.error('Failed to load areas:', error);
        }
      }

      async function checkSetupAndRefresh() {
        const needsSetup = await checkSetupStatus();
        if (!needsSetup) {
          showNotification('è®¾ç½®å®Œæˆï¼æ­£åœ¨åŠ è½½æ§åˆ¶é¢æ¿...', 'success');
          setTimeout(() => {
            location.reload();
          }, 1000);
        } else {
          showNotification('è¯·å…ˆå®Œæˆè®¾ç½®æ­¥éª¤', 'error');
        }
      }

      // Check for updates function
      let CURRENT_VERSION = null; // Will be fetched from API
      const GITHUB_REPO = 'Detteee/bilistream';
      let latestUpdateInfo = null;

      // Fetch current version from API
      async function loadVersion() {
        try {
          const response = await fetch('/api/version');
          const data = await response.json();
          if (data.success && data.data) {
            CURRENT_VERSION = data.data.version;
            document.getElementById('version-display').textContent = `Bilistream v${CURRENT_VERSION}`;
          }
        } catch (error) {
          console.error('Failed to load version:', error);
          document.getElementById('version-display').textContent = 'Bilistream';
        }
      }

      async function checkForUpdates() {
        try {
          showNotification('æ­£åœ¨æ£€æŸ¥æ›´æ–°...', 'success');

          // Use backend API to check for updates
          const response = await fetch('/api/update/check');

          if (!response.ok) {
            throw new Error('æ— æ³•è·å–ç‰ˆæœ¬ä¿¡æ¯');
          }

          const data = await response.json();

          if (!data.success) {
            throw new Error(data.message || 'æ£€æŸ¥æ›´æ–°å¤±è´¥');
          }

          const updateInfo = data.data;
          latestUpdateInfo = updateInfo;

          console.log('Update info:', updateInfo);

          // Compare versions
          if (updateInfo.has_update) {
            // New version available
            const updateNotification = document.getElementById('update-notification');
            const updateMessage = document.getElementById('update-message');
            const updateLink = document.getElementById('update-link');
            const autoUpdateBtn = document.getElementById('auto-update-btn');

            let message = `æœ€æ–°ç‰ˆæœ¬ v${updateInfo.latest_version} å·²å‘å¸ƒï¼å½“å‰ç‰ˆæœ¬ï¼šv${updateInfo.current_version}`;
            if (updateInfo.asset_name) {
              const sizeMB = (updateInfo.asset_size / 1024 / 1024).toFixed(1);
              message += `\næ–‡ä»¶: ${updateInfo.asset_name} (${sizeMB} MB)`;
            }
            updateMessage.textContent = message;
            updateMessage.style.whiteSpace = 'pre-line';

            // Set manual download link
            if (updateInfo.download_url) {
              updateLink.href = updateInfo.download_url;
              autoUpdateBtn.style.display = 'block';
            } else {
              // No direct download available, hide auto-update button
              autoUpdateBtn.style.display = 'none';
              updateLink.href = `https://github.com/${GITHUB_REPO}/releases/latest`;
            }

            updateNotification.style.display = 'block';

            showNotification(`å‘ç°æ–°ç‰ˆæœ¬ v${updateInfo.latest_version}ï¼`, 'success');
          } else {
            showNotification('å·²æ˜¯æœ€æ–°ç‰ˆæœ¬ï¼', 'success');
            // Hide update notification if it was shown before
            document.getElementById('update-notification').style.display = 'none';
          }
        } catch (error) {
          console.error('Failed to check for updates:', error);
          showNotification('æ£€æŸ¥æ›´æ–°å¤±è´¥: ' + error.message, 'error');
        }
      }

      async function autoInstallUpdate() {
        if (!latestUpdateInfo || !latestUpdateInfo.download_url) {
          showNotification('æ— æ³•è·å–ä¸‹è½½åœ°å€', 'error');
          return;
        }

        try {
          const autoUpdateBtn = document.getElementById('auto-update-btn');
          const updateProgress = document.getElementById('update-progress');

          autoUpdateBtn.disabled = true;
          autoUpdateBtn.textContent = 'â³ ä¸‹è½½ä¸­...';
          updateProgress.style.display = 'block';
          updateProgress.textContent = 'æ­£åœ¨ä¸‹è½½æ›´æ–°ï¼Œè¯·ç¨å€™...';

          showNotification('å¼€å§‹ä¸‹è½½æ›´æ–°...', 'success');

          const response = await fetch('/api/update/download', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ download_url: latestUpdateInfo.download_url })
          });

          const data = await response.json();

          if (data.success) {
            updateProgress.textContent = 'âœ… æ›´æ–°ä¸‹è½½å®Œæˆï¼ç¨‹åºå°†è‡ªåŠ¨é‡å¯...';
            showNotification('æ›´æ–°å®‰è£…ä¸­ï¼Œç¨‹åºå³å°†é‡å¯...', 'success');

            // Wait a bit then reload the page (program will restart)
            setTimeout(() => {
              location.reload();
            }, 5000);
          } else {
            throw new Error(data.message || 'ä¸‹è½½å¤±è´¥');
          }
        } catch (error) {
          console.error('Failed to download update:', error);
          showNotification('è‡ªåŠ¨æ›´æ–°å¤±è´¥: ' + error.message, 'error');

          const autoUpdateBtn = document.getElementById('auto-update-btn');
          const updateProgress = document.getElementById('update-progress');
          autoUpdateBtn.disabled = false;
          autoUpdateBtn.textContent = 'ğŸš€ è‡ªåŠ¨æ›´æ–°';
          updateProgress.textContent = 'âŒ æ›´æ–°å¤±è´¥ï¼Œè¯·å°è¯•æ‰‹åŠ¨ä¸‹è½½';
        }
      }

      function compareVersions(v1, v2) {
        const parts1 = v1.split('.').map(Number);
        const parts2 = v2.split('.').map(Number);

        for (let i = 0; i < Math.max(parts1.length, parts2.length); i++) {
          const part1 = parts1[i] || 0;
          const part2 = parts2[i] || 0;

          if (part1 > part2) return 1;
          if (part1 < part2) return -1;
        }

        return 0;
      }

      // Auto-check for updates on page load (only on main page)
      function autoCheckUpdates() {
        const mainPage = document.getElementById('main-page');
        if (mainPage && !mainPage.classList.contains('hidden')) {
          // Check for updates silently (without notification)
          fetch('/api/update/check')
            .then(response => response.json())
            .then(data => {
              if (data.success && data.data && data.data.has_update) {
                const updateInfo = data.data;
                latestUpdateInfo = updateInfo;

                const updateNotification = document.getElementById('update-notification');
                const updateMessage = document.getElementById('update-message');
                const updateLink = document.getElementById('update-link');
                const autoUpdateBtn = document.getElementById('auto-update-btn');

                let message = `æœ€æ–°ç‰ˆæœ¬ v${updateInfo.latest_version} å·²å‘å¸ƒï¼å½“å‰ç‰ˆæœ¬ï¼šv${updateInfo.current_version}`;
                if (updateInfo.asset_name) {
                  const sizeMB = (updateInfo.asset_size / 1024 / 1024).toFixed(1);
                  message += `\næ–‡ä»¶: ${updateInfo.asset_name} (${sizeMB} MB)`;
                }
                updateMessage.textContent = message;
                updateMessage.style.whiteSpace = 'pre-line';

                if (updateInfo.download_url) {
                  updateLink.href = updateInfo.download_url;
                  autoUpdateBtn.style.display = 'block';
                } else {
                  autoUpdateBtn.style.display = 'none';
                  updateLink.href = `https://github.com/${GITHUB_REPO}/releases/latest`;
                }

                updateNotification.style.display = 'block';
              }
            })
            .catch(error => {
              console.log('Auto-update check failed (silent):', error);
            });
        }
      }

      // Theme toggle function
      function toggleTheme() {
        const body = document.body;
        const themeToggle = document.getElementById('theme-toggle');

        if (body.classList.contains('light-theme')) {
          // Switch to dark theme (Dracula)
          body.classList.remove('light-theme');
          themeToggle.textContent = 'ğŸŒ™ æš—è‰²';
          localStorage.setItem('theme', 'dark');
        } else {
          // Switch to light theme
          body.classList.add('light-theme');
          themeToggle.textContent = 'â˜€ï¸ äº®è‰²';
          localStorage.setItem('theme', 'light');
        }
      }

      // Load saved theme preference
      function loadTheme() {
        const savedTheme = localStorage.getItem('theme');
        const themeToggle = document.getElementById('theme-toggle');

        if (savedTheme === 'light') {
          document.body.classList.add('light-theme');
          if (themeToggle) themeToggle.textContent = 'â˜€ï¸ äº®è‰²';
        } else {
          // Default to dark theme (Dracula)
          document.body.classList.remove('light-theme');
          if (themeToggle) themeToggle.textContent = 'ğŸŒ™ æš—è‰²';
        }
      }

      // Load theme on page load
      loadTheme();

      // Check setup status on page load
      checkSetupStatus().then(needsSetup => {
        if (!needsSetup) {
          // Load version first
          loadVersion();

          // Only load data if setup is complete
          initStatusRefresh(); // This will load config and start auto-refresh
          loadChannelData();

          // Auto-check for updates after 2 seconds
          setTimeout(autoCheckUpdates, 2000);
        }
      });
    </script>
  </div> <!-- Close main-page -->
</body>

</html>