<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bilistream</title>
  <link rel="icon"
    href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'><g><path d='M0 2A2 2 0 0 1 3 .3l15.5 9.3a2 2 0 0 1 0 3.5L3.1 22.4A2 2 0 0 1 0 20.7V2Z' fill='url(%23b)'/><path d='M4.57 2a2 2 0 0 1 3-1.7L23 9.6a2 2 0 0 1 0 3.5L7.6 22.4a2 2 0 0 1-3-1.7V2Z' fill='url(%23a)'/></g><defs><linearGradient id='a' x1='.2' y1='2.8' x2='19.3' y2='18.5' gradientUnits='userSpaceOnUse'><stop stop-color='%23FD0031'/><stop offset='1' stop-color='%23FC4085'/></linearGradient><linearGradient id='b' x1='-4.4' y1='2.8' x2='19.5' y2='11.3' gradientUnits='userSpaceOnUse'><stop stop-color='%2355ACEE'/><stop offset='0.6' stop-color='%238264E5' stop-opacity='.3'/></linearGradient></defs></svg>">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      /* Catppuccin Mocha Dark Theme */
      --bg-gradient-start: #1e1e2e;
      --bg-gradient-mid: #181825;
      --bg-gradient-end: #11111b;
      --card-bg: #1e1e2e;
      --card-border: #313244;
      --text-primary: #cdd6f4;
      --text-secondary: #bac2de;
      --text-muted: #6c7086;
      --header-text: #cdd6f4;
      --input-bg: #313244;
      --input-border: #45475a;
      --input-focus: #89b4fa;
      --shadow: rgba(0, 0, 0, 0.4);
      --shadow-hover: rgba(0, 0, 0, 0.6);
      --info-border: #313244;
      --heading-color: #89b4fa;
      --button-hover-bg: #45475a;
      --accent-pink: #f5c2e7;
      --accent-mauve: #cba6f7;
      --accent-red: #f38ba8;
      --accent-green: #a6e3a1;
      --accent-yellow: #f9e2af;
      --accent-teal: #94e2d5;
    }

    body.light-theme {
      /* Light Theme */
      --bg-gradient-start: #667eea;
      --bg-gradient-mid: #764ba2;
      --bg-gradient-end: #8e54e9;
      --card-bg: #ffffff;
      --card-border: #e5e7eb;
      --text-primary: #333333;
      --text-secondary: #666666;
      --text-muted: #999999;
      --header-text: #ffffff;
      --input-bg: #ffffff;
      --input-border: #e5e7eb;
      --input-focus: #667eea;
      --shadow: rgba(0, 0, 0, 0.2);
      --shadow-hover: rgba(0, 0, 0, 0.3);
      --info-border: #f0f0f0;
      --heading-color: #667eea;
      --button-hover-bg: #e5e7eb;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-mid) 50%, var(--bg-gradient-end) 100%);
      min-height: 100vh;
      padding: 20px;
      transition: background 0.3s ease;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    .header {
      text-align: center;
      color: white;
      margin-bottom: 30px;
    }

    .header h1 {
      font-size: 2.5em;
      margin-bottom: 10px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
    }

    .header p {
      font-size: 1.1em;
      opacity: 0.9;
    }

    .dashboard {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(270px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }

    .card {
      background: var(--card-bg);
      border-radius: 12px;
      padding: 25px;
      box-shadow: 0 10px 30px var(--shadow);
      transition: transform 0.3s ease, box-shadow 0.3s ease, background 0.3s ease;
      border: 1px solid var(--card-border);
    }

    .card:hover {
      transform: translateY(-5px);
      box-shadow: 0 15px 40px var(--shadow-hover);
    }

    .card h2 {
      color: var(--heading-color);
      margin-bottom: 15px;
      font-size: 1.5em;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .status-indicator {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      display: inline-block;
    }

    .status-live {
      background: #a6e3a1;
      box-shadow: 0 0 10px #a6e3a1;
    }

    .status-offline {
      background: #f38ba8;
    }

    .info-row {
      display: flex;
      justify-content: space-between;
      padding: 10px 0;
      border-bottom: 1px solid var(--info-border);
    }

    .info-row:last-child {
      border-bottom: none;
    }

    .info-label {
      color: var(--text-secondary);
      font-weight: 500;
    }

    .info-value {
      color: var(--text-primary);
      font-weight: 600;
    }

    .controls {
      background: var(--card-bg);
      border-radius: 12px;
      padding: 25px;
      box-shadow: 0 10px 30px var(--shadow);
      border: 1px solid var(--card-border);
      transition: background 0.3s ease;
    }

    .controls h2 {
      color: var(--heading-color);
      margin-bottom: 20px;
      font-size: 1.5em;
    }

    .control-group {
      margin-bottom: 20px;
    }

    .control-group label {
      display: block;
      margin-bottom: 8px;
      color: var(--text-secondary);
      font-weight: 500;
    }

    .control-group input,
    .control-group select,
    .control-group textarea {
      width: 100%;
      padding: 12px;
      border: 2px solid var(--input-border);
      border-radius: 8px;
      font-size: 14px;
      transition: border-color 0.3s ease, background 0.3s ease;
      background: var(--input-bg);
      color: var(--text-primary);
    }

    .control-group input:focus,
    .control-group select:focus,
    .control-group textarea:focus {
      outline: none;
      border-color: var(--input-focus);
    }

    .button-group {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 10px;
      margin-top: 20px;
    }

    button {
      padding: 12px 24px;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    button:hover:not(:disabled) {
      filter: brightness(1.1);
    }

    .btn-primary {
      background: linear-gradient(135deg, #89b4fa 0%, #cba6f7 100%);
      color: #1e1e2e;
    }

    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(137, 180, 250, 0.4);
    }

    .btn-success {
      background: #a6e3a1;
      color: #1e1e2e;
    }

    .btn-success:hover {
      background: #94d89e;
      transform: translateY(-2px);
    }

    .btn-danger {
      background: #f38ba8;
      color: #1e1e2e;
    }

    .btn-danger:hover {
      background: #f17a9a;
      transform: translateY(-2px);
    }

    .btn-secondary {
      background: linear-gradient(135deg, #89b4fa 0%, #74c7ec 100%);
      color: #1e1e2e;
    }

    .btn-secondary:hover {
      background: linear-gradient(135deg, #74c7ec 0%, #89b4fa 100%);
      transform: translateY(-2px);
    }

    .notification {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 15px 20px;
      border-radius: 8px;
      color: white;
      font-weight: 500;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      animation: slideIn 0.3s ease;
      z-index: 1000;
    }

    .notification.success {
      background: #a6e3a1;
      color: #1e1e2e;
    }

    .notification.error {
      background: #f38ba8;
      color: #1e1e2e;
    }

    @keyframes slideIn {
      from {
        transform: translateX(400px);
        opacity: 0;
      }

      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    .loading {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(255, 255, 255, .3);
      border-radius: 50%;
      border-top-color: white;
      animation: spin 1s ease-in-out infinite;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    small {
      color: var(--text-muted);
    }

    a {
      color: var(--heading-color);
      transition: opacity 0.3s ease;
    }

    a:hover {
      opacity: 0.8;
    }

    @media (max-width: 768px) {
      .header h1 {
        font-size: 2em;
      }

      .dashboard {
        grid-template-columns: 1fr;
      }
    }

    /* Setup page styles */
    .setup-page {
      display: none;
    }

    .setup-page.active {
      display: block;
    }

    .main-page {
      display: block;
    }

    .main-page.hidden {
      display: none;
    }

    .setup-card {
      background: var(--card-bg);
      border-radius: 16px;
      padding: 40px;
      box-shadow: 0 20px 60px var(--shadow);
      max-width: 700px;
      margin: 50px auto;
      border: 1px solid var(--card-border);
      transition: background 0.3s ease;
    }

    .setup-icon {
      font-size: 64px;
      text-align: center;
      margin-bottom: 20px;
    }

    .setup-title {
      font-size: 2em;
      color: var(--heading-color);
      text-align: center;
      margin-bottom: 20px;
    }

    .setup-description {
      color: var(--text-secondary);
      line-height: 1.8;
      margin-bottom: 30px;
      text-align: center;
    }

    .missing-files {
      background: #fff3cd;
      border: 2px solid #ffc107;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 30px;
    }

    .missing-files h3 {
      color: #856404;
      margin-bottom: 10px;
    }

    .missing-files ul {
      list-style: none;
      padding: 0;
    }

    .missing-files li {
      color: #856404;
      padding: 5px 0;
      padding-left: 25px;
      position: relative;
    }

    .missing-files li:before {
      content: "âš ï¸";
      position: absolute;
      left: 0;
    }

    .setup-steps {
      background: var(--input-bg);
      border-radius: 8px;
      padding: 25px;
      margin-bottom: 30px;
      border: 1px solid var(--card-border);
    }

    .setup-steps h3 {
      color: var(--text-primary);
      margin-bottom: 15px;
    }

    .setup-steps ol {
      padding-left: 20px;
      color: var(--text-secondary);
      line-height: 2;
    }

    .setup-steps code {
      background: var(--card-border);
      padding: 2px 8px;
      border-radius: 4px;
      font-family: 'Courier New', monospace;
      color: #f5c2e7;
    }

    .command-box {
      background: #181825;
      color: #a6e3a1;
      padding: 20px;
      border-radius: 8px;
      font-family: 'Courier New', monospace;
      font-size: 16px;
      margin-bottom: 20px;
      position: relative;
      border: 1px solid #313244;
    }

    .command-box:before {
      content: "$";
      color: #89b4fa;
      margin-right: 10px;
    }

    .refresh-button {
      width: 100%;
      padding: 15px;
      background: linear-gradient(135deg, #89b4fa 0%, #cba6f7 100%);
      color: #1e1e2e;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s;
    }

    .refresh-button:hover {
      transform: translateY(-2px);
      filter: brightness(1.1);
    }

    /* Setup wizard styles */
    .step-dot {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: #313244;
      color: #6c7086;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      transition: all 0.3s ease;
      border: 2px solid #45475a;
    }

    .step-dot.active {
      background: linear-gradient(135deg, #89b4fa 0%, #cba6f7 100%);
      color: #1e1e2e;
      box-shadow: 0 4px 12px rgba(137, 180, 250, 0.4);
      border-color: transparent;
    }

    .setup-step {
      animation: fadeIn 0.3s ease;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Toggle Switch Styles */
    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 50px;
      height: 24px;
      margin-right: 10px;
    }

    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: var(--input-border);
      transition: 0.3s;
      border-radius: 24px;
    }

    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 18px;
      width: 18px;
      left: 3px;
      top: 3px;
      background-color: white;
      transition: 0.3s;
      border-radius: 50%;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .toggle-switch input:checked+.toggle-slider {
      background: linear-gradient(135deg, #89b4fa 0%, #cba6f7 100%);
    }

    .toggle-switch input:checked+.toggle-slider:before {
      transform: translateX(26px);
    }

    .toggle-switch input:focus+.toggle-slider {
      box-shadow: 0 0 0 2px rgba(137, 180, 250, 0.3);
    }

    .toggle-label {
      display: flex;
      align-items: center;
      cursor: pointer;
      user-select: none;
    }
  </style>
</head>

<body>
  <!-- Setup Page -->
  <div class="setup-page" id="setup-page">
    <div class="container">
      <div class="setup-card">
        <div class="setup-icon">ğŸš€</div>
        <h1 class="setup-title">æ¬¢è¿ä½¿ç”¨ Bilistream</h1>
        <p class="setup-description">
          é€šè¿‡ Web ç•Œé¢å®Œæˆåˆå§‹é…ç½®ï¼Œæ— éœ€ä½¿ç”¨å‘½ä»¤è¡Œ
        </p>

        <!-- Step Indicator -->
        <div style="display: flex; justify-content: center; gap: 10px; margin-bottom: 30px;">
          <div class="step-dot active" id="step-dot-1">1</div>
          <div class="step-dot" id="step-dot-2">2</div>
          <div class="step-dot" id="step-dot-3">3</div>
        </div>

        <!-- Step 1: Login -->
        <div class="setup-step" id="setup-step-1">
          <h3 style="color: #667eea; margin-bottom: 20px;">æ­¥éª¤ 1: ç™»å½• Bilibili</h3>
          <p style="color: #666; margin-bottom: 20px;">
            ä½¿ç”¨ Bilibili APP æ‰«æä¸‹æ–¹äºŒç»´ç ç™»å½•
          </p>
          <div id="login-status" style="padding: 15px; background: #f0f0f0; border-radius: 8px; margin-bottom: 20px;">
            <span id="login-status-text">æ£€æŸ¥ç™»å½•çŠ¶æ€...</span>
          </div>

          <!-- QR Code Display -->
          <div id="qr-code-container" style="display: none; text-align: center; margin-bottom: 20px;">
            <div
              style="background: white; padding: 20px; border-radius: 8px; display: inline-block; box-shadow: 0 4px 12px rgba(0,0,0,0.1);">
              <div id="qr-code-display"></div>
              <p style="color: #666; margin-top: 15px; font-size: 14px;">è¯·ä½¿ç”¨ Bilibili APP æ‰«ç ç™»å½•</p>
              <p id="qr-status" style="color: #667eea; margin-top: 10px; font-weight: 600;">ç­‰å¾…æ‰«ç ...</p>
            </div>
          </div>

          <div style="display: flex; gap: 10px;">
            <button class="btn-primary" onclick="showQrCode()" id="show-qr-btn" style="flex: 1;">
              ğŸ” æ˜¾ç¤ºç™»å½•äºŒç»´ç 
            </button>
            <button class="btn-secondary" onclick="checkLoginStatus()"
              style="flex: 1; display: flex; align-items: center; justify-content: center; gap: 6px;">
              <svg fill="currentColor" width="14" height="14" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path
                  d="M19.146 4.854l-1.489 1.489A8 8 0 1 0 12 20a8.094 8.094 0 0 0 7.371-4.886 1 1 0 1 0-1.842-.779A6.071 6.071 0 0 1 12 18a6 6 0 1 1 4.243-10.243l-1.39 1.39a.5.5 0 0 0 .354.854H19.5A.5.5 0 0 0 20 9.5V5.207a.5.5 0 0 0-.854-.353z" />
              </svg>
              <span>åˆ·æ–°çŠ¶æ€</span>
            </button>
          </div>
          <button class="btn-success" onclick="goToStep(2)" style="width: 100%; margin-top: 15px;">
            ä¸‹ä¸€æ­¥ â†’
          </button>
        </div>

        <!-- Step 2: Basic Config -->
        <div class="setup-step" id="setup-step-2" style="display: none;">
          <h3 style="color: #667eea; margin-bottom: 20px;">æ­¥éª¤ 2: åŸºç¡€é…ç½®</h3>

          <div class="control-group">
            <label>Bç«™ç›´æ’­é—´å· *</label>
            <input type="number" id="setup-room" placeholder="è¾“å…¥ä½ çš„ç›´æ’­é—´å·" required>
          </div>

          <div class="control-group">
            <label>æ£€æµ‹é—´éš” (ç§’)</label>
            <input type="number" id="setup-interval" value="60" min="10">
          </div>

          <div class="control-group">
            <label style="display: flex; align-items: center; gap: 10px;">
              <input type="checkbox" id="setup-auto-cover" checked>
              <span>è‡ªåŠ¨æ›´æ¢å°é¢</span>
            </label>
          </div>

          <div class="control-group">
            <label style="display: flex; align-items: center; gap: 10px;">
              <input type="checkbox" id="setup-danmaku-command" checked>
              <span>å¯ç”¨å¼¹å¹•æŒ‡ä»¤</span>
            </label>
          </div>

          <div class="control-group">
            <label style="display: flex; align-items: center; gap: 10px;">
              <input type="checkbox" id="setup-anti-collision">
              <span>å¯ç”¨æ’è½¦ç›‘æ§</span>
            </label>
          </div>

          <div class="control-group">
            <label>ä»£ç†åœ°å€ (å¯é€‰)</label>
            <input type="text" id="setup-proxy" placeholder="http://127.0.0.1:7890">
            <small style="color: var(--text-muted); display: block; margin-top: 5px;">
              å¦‚éœ€è®¿é—® YouTube/Twitch éœ€è¦ä»£ç†ï¼Œè¯·å¡«å†™<br>
              å¸¸ç”¨é»˜è®¤ç«¯å£: Clash (7890) | V2Ray (2080)<br>
              ç¤ºä¾‹: <code
                style="background: var(--card-border); padding: 2px 6px; border-radius: 3px; color: var(--accent-pink);">http://127.0.0.1:7890</code>
            </small>
          </div>

          <div style="display: flex; gap: 10px; margin-top: 20px;">
            <button class="btn-secondary" onclick="goToStep(1)" style="flex: 1;">
              â† ä¸Šä¸€æ­¥
            </button>
            <button class="btn-success" onclick="goToStep(3)" style="flex: 1;">
              ä¸‹ä¸€æ­¥ â†’
            </button>
          </div>
        </div>

        <!-- Step 3: Platform Config -->
        <div class="setup-step" id="setup-step-3" style="display: none;">
          <h3 style="color: #667eea; margin-bottom: 20px;">æ­¥éª¤ 3: å¹³å°é…ç½® (å¯é€‰)</h3>

          <!-- YouTube Config -->
          <div style="border: 2px solid #e5e7eb; border-radius: 8px; padding: 20px; margin-bottom: 20px;">
            <h4 style="color: #667eea; margin-bottom: 15px;">ğŸ“º YouTube</h4>

            <div class="control-group">
              <label>é€‰æ‹©é¢„è®¾é¢‘é“ (å¯é€‰)</label>
              <select id="setup-yt-channel-select" onchange="updateSetupYouTubeChannel()">
                <option value="">é€‰æ‹©é¢„è®¾é¢‘é“æˆ–æ‰‹åŠ¨è¾“å…¥...</option>
              </select>
            </div>

            <div class="control-group">
              <label>é¢‘é“åç§°</label>
              <input type="text" id="setup-yt-name" placeholder="ç•™ç©ºè¡¨ç¤ºä¸é…ç½®">
            </div>

            <div class="control-group">
              <label>é¢‘é“ ID</label>
              <input type="text" id="setup-yt-id" placeholder="YouTube Channel ID">
            </div>

            <div class="control-group">
              <label>Bç«™åˆ†åŒº</label>
              <select id="setup-yt-area">
                <option value="235">å…¶ä»–å•æœº (235)</option>
              </select>
            </div>

            <div class="control-group">
              <label>ç”»è´¨</label>
              <select id="setup-yt-quality">
                <option value="best">æœ€ä½³è´¨é‡ (æ¨è)</option>
                <option value="best[height<=1080]">è¶…æ¸… (1080o)</option>
                <option value="best[height<=720]">é«˜æ¸… (720p)</option>
                <option value="best[height<=480]">æ ‡æ¸… (480p)</option>
                <option value="best[height<=360]">æµç•… (360p)</option>
                <option value="worst">æœ€ä½è´¨é‡</option>
              </select>
            </div>
          </div>

          <!-- Twitch Config -->
          <div style="border: 2px solid #e5e7eb; border-radius: 8px; padding: 20px; margin-bottom: 20px;">
            <h4 style="color: #9146ff; margin-bottom: 15px;">ğŸ® Twitch</h4>

            <div class="control-group">
              <label>é€‰æ‹©é¢„è®¾é¢‘é“ (å¯é€‰)</label>
              <select id="setup-tw-channel-select" onchange="updateSetupTwitchChannel()">
                <option value="">é€‰æ‹©é¢„è®¾é¢‘é“æˆ–æ‰‹åŠ¨è¾“å…¥...</option>
              </select>
            </div>

            <div class="control-group">
              <label>é¢‘é“åç§°</label>
              <input type="text" id="setup-tw-name" placeholder="ç•™ç©ºè¡¨ç¤ºä¸é…ç½®">
            </div>

            <div class="control-group">
              <label>é¢‘é“ ID (ç”¨æˆ·å)</label>
              <input type="text" id="setup-tw-id" placeholder="Twitch ç”¨æˆ·å">
            </div>

            <div class="control-group">
              <label>Bç«™åˆ†åŒº</label>
              <select id="setup-tw-area">
                <option value="235">å…¶ä»–å•æœº (235)</option>
              </select>
            </div>

            <div class="control-group">
              <label>OAuth Token (å¯é€‰)</label>
              <input type="text" id="setup-tw-oauth" placeholder="ç”¨äº streamlink è®¤è¯">
              <small style="color: var(--text-muted); display: block; margin-top: 5px;">
                è·å–æ–¹æ³•: <a href="https://streamlink.github.io/cli/plugins/twitch.html#authentication" target="_blank"
                  rel="noopener noreferrer" style="color: var(--accent-pink);">Streamlink Twitch è®¤è¯æ–‡æ¡£</a>
              </small>
            </div>

            <div class="control-group">
              <label>ä»£ç†åŒºåŸŸ</label>
              <select id="setup-tw-region">
                <option value="asl">asl - äºšæ´² (luminous, æ¨è)</option>
                <option value="eul">eul - æ¬§æ´² (luminous, æ¨è)</option>
                <option value="eu2l">eu2l - æ¬§æ´² 2 (luminous)</option>
                <option value="as">as - äºšæ´² (TTV-LOL-PRO)</option>
                <option value="eu">eu - æ¬§æ´² (TTV-LOL-PRO)</option>
                <option value="eu2">eu2 - æ¬§æ´² 2 (TTV-LOL-PRO)</option>
                <option value="eu3">eu3 - æ¬§æ´² 3 (TTV-LOL-PRO)</option>
                <option value="eu4">eu4 - æ¬§æ´² 4 (TTV-LOL-PRO)</option>
                <option value="eu5">eu5 - æ¬§æ´² 5 (TTV-LOL-PRO)</option>
                <option value="na">na - åŒ—ç¾ (TTV-LOL-PRO)</option>
                <option value="sa">sa - å—ç¾ (TTV-LOL-PRO)</option>
                <option value="all">all - å…¨éƒ¨ä»£ç†</option>
                <option value="perf">perf - TTV-LOL-PRO å…¨éƒ¨</option>
              </select>
            </div>

            <div class="control-group">
              <label>ç”»è´¨</label>
              <select id="setup-tw-quality">
                <option value="best">best - åŸç”»è´¨é‡ (æ¨è)</option>
                <option value="high">high - é«˜è´¨é‡ (â‰¤720p30)</option>
                <option value="medium">medium - ä¸­ç­‰è´¨é‡ (â‰¤540p30)</option>
                <option value="low">low - ä½è´¨é‡ (â‰¤360p30)</option>
                <option value="audio_only">audio_only - ä»…éŸ³é¢‘</option>
                <option value="worst">worst - æœ€ä½è´¨é‡</option>
              </select>
            </div>
          </div>

          <!-- Advanced Options -->
          <div style="border: 2px solid #e5e7eb; border-radius: 8px; padding: 20px; margin-bottom: 20px;">
            <h4 style="color: #667eea; margin-bottom: 15px;">âš™ï¸ é«˜çº§é€‰é¡¹</h4>

            <div class="control-group">
              <label>Holodex API Key (å¯é€‰)</label>
              <input type="text" id="setup-holodex" placeholder="ç”¨äº YouTube ç›´æ’­çŠ¶æ€æ£€æµ‹">
              <small style="color: #888;">è·å–: <a href="https://holodex.net/login"
                  target="_blank">holodex.net</a></small>
            </div>

            <div class="control-group">
              <label class="toggle-label">
                <div class="toggle-switch">
                  <input type="checkbox" id="setup-lol-monitor" onchange="toggleRiotApiKey()">
                  <span class="toggle-slider"></span>
                </div>
                <span>å¯ç”¨è‹±é›„è”ç›Ÿç©å®¶IDç›‘æ§</span>
              </label>
            </div>

            <div class="control-group" id="riot-api-group" style="display: none;">
              <label>Riot API Key</label>
              <input type="text" id="setup-riot" placeholder="ç”¨äºç›‘æ§æ¸¸æˆå†…è¿ç¦è¯æ±‡">
              <small style="color: #888;">è·å–: <a href="https://developer.riotgames.com/"
                  target="_blank">developer.riotgames.com</a></small>
            </div>
          </div>

          <div style="display: flex; gap: 10px; margin-top: 20px;">
            <button class="btn-secondary" onclick="goToStep(2)" style="flex: 1;">
              â† ä¸Šä¸€æ­¥
            </button>
            <button class="btn-success" onclick="saveSetupConfig()" style="flex: 1;">
              âœ… å®Œæˆè®¾ç½®
            </button>
          </div>
        </div>

        <p style="text-align: center; color: #999; margin-top: 20px; font-size: 14px;">
          éœ€è¦å¸®åŠ©ï¼ŸæŸ¥çœ‹ <a href="https://github.com/Detteee/bilistream" target="_blank" style="color: #667eea;">æ–‡æ¡£</a>
        </p>
      </div>
    </div>
  </div>

  <!-- Main Page -->
  <div class="main-page" id="main-page">
    <div class="container">
      <div class="header">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
          <h1 style="margin: 0;">
            <svg width="48" height="48" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"
              style="vertical-align: middle; margin-right: 10px;">
              <g>
                <path d="M0 2A2 2 0 0 1 3 .3l15.5 9.3a2 2 0 0 1 0 3.5L3.1 22.4A2 2 0 0 1 0 20.7V2Z" fill="url(#b)" />
                <path d="M4.57 2a2 2 0 0 1 3-1.7L23 9.6a2 2 0 0 1 0 3.5L7.6 22.4a2 2 0 0 1-3-1.7V2Z" fill="url(#a)" />
              </g>
              <defs>
                <linearGradient id="a" x1=".2" y1="2.8" x2="19.3" y2="18.5" gradientUnits="userSpaceOnUse">
                  <stop stop-color="#FD0031" />
                  <stop offset="1" stop-color="#FC4085" />
                </linearGradient>
                <linearGradient id="b" x1="-4.4" y1="2.8" x2="19.5" y2="11.3" gradientUnits="userSpaceOnUse">
                  <stop stop-color="#55ACEE" />
                  <stop offset="0.6" stop-color="#8264E5" stop-opacity=".3" />
                </linearGradient>
              </defs>
            </svg>
            Bilistream
          </h1>
          <button onclick="toggleTheme()" id="theme-toggle"
            style="padding: 10px 20px; background: rgba(255,255,255,0.2); color: white; border: 1px solid rgba(255,255,255,0.3); border-radius: 8px; cursor: pointer; font-size: 14px; font-weight: 600; transition: all 0.3s ease; backdrop-filter: blur(10px);">
            ğŸŒ™ æš—è‰²
          </button>
        </div>
        <p style="color: var(--header-text);">å®æ—¶ç›‘æ§å’Œæ§åˆ¶ä½ çš„è½¬æ’­</p>
      </div>

      <div class="dashboard">
        <div class="card">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
            <h2 style="margin: 0;">
              <span class="status-indicator" id="bili-status"></span>
              Bilibili
            </h2>
            <div style="display: flex; gap: 8px; align-items: center;">
              <button id="startLiveBtn" onclick="startStream()" title="å¼€å§‹ç›´æ’­"
                style="padding: 8px; background: var(--accent-green); color: #1e1e2e; border: none; border-radius: 6px; cursor: pointer; transition: all 0.3s ease; display: flex; align-items: center; justify-content: center;">
                <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px"
                  y="0px" viewBox="0 0 330 330" style="enable-background:new 0 0 330 330;" xml:space="preserve"
                  width="14" height="14" fill="currentColor">
                  <path
                    d="M37.728,328.12c2.266,1.256,4.77,1.88,7.272,1.88c2.763,0,5.522-0.763,7.95-2.28l240-149.999c4.386-2.741,7.05-7.548,7.05-12.72c0-5.172-2.664-9.979-7.05-12.72L52.95,2.28c-4.625-2.891-10.453-3.043-15.222-0.4C32.959,4.524,30,9.547,30,15v300C30,320.453,32.959,325.476,37.728,328.12z" />
                </svg>
              </button>
              <button id="stopLiveBtn" onclick="stopStream()" title="åœæ­¢ç›´æ’­"
                style="padding: 8px; background: var(--accent-red); color: #1e1e2e; border: none; border-radius: 6px; cursor: pointer; transition: all 0.3s ease; display: flex; align-items: center; justify-content: center;">
                <svg width="14" height="14" viewBox="0 0 52 52" xmlns="http://www.w3.org/2000/svg" fill="currentColor">
                  <path d="M30,43c0,1,0.9,2,2,2h4c1.1,0,2-1.1,2-2V9c0-1-0.9-2-2-2h-4c-1.1,0-2,1.1-2,2V43z" />
                  <path d="M14,43c0,1,0.9,2,2,2h4c1.1,0,2-1.1,2-2V9c0-1-0.9-2-2-2h-4c-1.1,0-2,1.1-2,2V43z" />
                </svg>
              </button>
              <button id="restartStreamBtn" onclick="restartStream()" title="é‡å¯æµ"
                style="padding: 8px; background: var(--accent-yellow); color: #1e1e2e; border: none; border-radius: 6px; cursor: pointer; transition: all 0.3s ease; display: flex; align-items: center; justify-content: center;">
                <svg id="restartStreamIcon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="14"
                  height="14" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                  stroke-linejoin="round" style="transition: transform 0.6s ease;">
                  <path
                    d="M22 12c0 6-4.39 10-9.806 10C7.792 22 4.24 19.665 3 16m-1-4C2 6 6.39 2 11.807 2C16.208 2 19.758 4.335 21 8" />
                  <path d="m7 17l-4-1l-1 4M17 7l4 1l1-4" />
                </svg>
              </button>
              <button id="refreshBilibiliBtn" onclick="refreshBilibiliStatus()" title="åˆ·æ–°çŠ¶æ€"
                style="padding: 8px; background: linear-gradient(135deg, #89b4fa 0%, #cba6f7 100%); color: #1e1e2e; border: none; border-radius: 6px; cursor: pointer; transition: all 0.3s ease; display: flex; align-items: center; justify-content: center;">
                <svg id="refreshBilibiliIcon" fill="currentColor" width="16" height="16" viewBox="0 0 24 24"
                  xmlns="http://www.w3.org/2000/svg" style="transition: transform 0.6s ease;">
                  <path
                    d="M19.146 4.854l-1.489 1.489A8 8 0 1 0 12 20a8.094 8.094 0 0 0 7.371-4.886 1 1 0 1 0-1.842-.779A6.071 6.071 0 0 1 12 18a6 6 0 1 1 4.243-10.243l-1.39 1.39a.5.5 0 0 0 .354.854H19.5A.5.5 0 0 0 20 9.5V5.207a.5.5 0 0 0-.854-.353z" />
                </svg>
              </button>
            </div>
          </div>

          <div class="info-row">
            <span class="info-label">æ ‡é¢˜</span>
            <div style="display: flex; align-items: center; gap: 8px; flex: 1;">
              <span class="info-value" id="bili-title" style="flex: 1; text-align: right;">-</span>
              <button onclick="toggleTitleEdit()"
                style="background: none; border: none; color: var(--heading-color); cursor: pointer; padding: 4px; border-radius: 4px; display: flex; align-items: center; transition: background 0.2s;"
                onmouseover="this.style.background='var(--button-hover-bg)'" onmouseout="this.style.background='none'"
                title="ç¼–è¾‘æ ‡é¢˜">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                  stroke-linecap="round" stroke-linejoin="round">
                  <path
                    d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z" />
                </svg>
              </button>
            </div>
            <!-- Hidden edit input -->
            <div id="title-edit-container" style="display: none; flex: 1;">
              <div style="display: flex; gap: 8px; align-items: center;">
                <input type="text" id="title-edit-input"
                  style="flex: 1; max-width: 150px; padding: 4px 8px; border: 1px solid var(--input-border); border-radius: 4px; background: var(--input-bg); color: var(--text-primary); font-size: 13px;">
                <button onclick="saveTitleEdit()"
                  style="background: var(--accent-green); color: #1e1e2e; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px;">
                  âœ“
                </button>
                <button onclick="cancelTitleEdit()"
                  style="background: var(--accent-red); color: #1e1e2e; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px;">
                  âœ•
                </button>
              </div>
            </div>
          </div>
          <div class="info-row">
            <span class="info-label">åˆ†åŒº</span>
            <div style="display: flex; align-items: center; gap: 8px; flex: 1;">
              <span class="info-value" id="bili-area" style="flex: 1; text-align: right;">-</span>
              <button onclick="toggleAreaEdit()"
                style="background: none; border: none; color: var(--heading-color); cursor: pointer; padding: 4px; border-radius: 4px; display: flex; align-items: center; transition: background 0.2s;"
                onmouseover="this.style.background='var(--button-hover-bg)'" onmouseout="this.style.background='none'"
                title="æ›´æ”¹åˆ†åŒº">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                  stroke-linecap="round" stroke-linejoin="round">
                  <path
                    d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z" />
                </svg>
              </button>
            </div>
            <!-- Hidden edit dropdown -->
            <div id="area-edit-container" style="display: none; flex: 1;">
              <div style="display: flex; gap: 8px; align-items: center;">
                <select id="area-edit-select"
                  style="flex: 1; padding: 4px 8px; border: 1px solid var(--input-border); border-radius: 4px; background: var(--input-bg); color: var(--text-primary); font-size: 13px;">
                  <option value="">é€‰æ‹©åˆ†åŒº...</option>
                </select>
                <button onclick="saveAreaEdit()"
                  style="background: var(--accent-green); color: #1e1e2e; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px;">
                  âœ“
                </button>
                <button onclick="cancelAreaEdit()"
                  style="background: var(--accent-red); color: #1e1e2e; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px;">
                  âœ•
                </button>
              </div>
            </div>
          </div>
          <div class="info-row">
            <span class="info-label">å¼¹å¹•æŒ‡ä»¤</span>
            <div style="display: flex; align-items: center; gap: 8px; flex: 1; justify-content: flex-end;">
              <label class="toggle-label" style="margin: 0;">
                <div class="toggle-switch">
                  <input type="checkbox" id="bili-danmaku-command-toggle" onchange="toggleDanmakuCommand()">
                  <span class="toggle-slider"></span>
                </div>
              </label>
            </div>
          </div>
          <div class="info-row" id="bili-stream-quality-row" style="display: none;">
            <span class="info-label">æµè´¨é‡</span>
            <span class="info-value" id="bili-stream-quality">-</span>
          </div>
        </div>

        <div class="card">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
            <h2 style="margin: 0;">
              <span class="status-indicator" id="yt-status"></span>
              YouTube
            </h2>
            <div style="display: flex; gap: 8px; align-items: center;">
              <!-- Toggle Switch -->
              <label class="toggle-label">
                <div class="toggle-switch">
                  <input type="checkbox" id="youtube-monitor-toggle" onchange="toggleYouTubeMonitor()">
                  <span class="toggle-slider"></span>
                </div>
              </label>
              <button id="refreshYouTubeBtn" onclick="refreshYouTubeStatus()" title="åˆ·æ–°çŠ¶æ€"
                style="padding: 8px; background: linear-gradient(135deg, #89b4fa 0%, #cba6f7 100%); color: #1e1e2e; border: none; border-radius: 6px; cursor: pointer; transition: all 0.3s ease; display: flex; align-items: center; justify-content: center;">
                <svg id="refreshYouTubeIcon" fill="currentColor" width="16" height="16" viewBox="0 0 24 24"
                  xmlns="http://www.w3.org/2000/svg" style="transition: transform 0.6s ease;">
                  <path
                    d="M19.146 4.854l-1.489 1.489A8 8 0 1 0 12 20a8.094 8.094 0 0 0 7.371-4.886 1 1 0 1 0-1.842-.779A6.071 6.071 0 0 1 12 18a6 6 0 1 1 4.243-10.243l-1.39 1.39a.5.5 0 0 0 .354.854H19.5A.5.5 0 0 0 20 9.5V5.207a.5.5 0 0 0-.854-.353z" />
                </svg>
              </button>
            </div>
          </div>
          <div class="info-row">
            <span class="info-label">é¢‘é“</span>
            <div style="display: flex; align-items: center; gap: 8px; flex: 1;">
              <span class="info-value" id="yt-channel-name" style="flex: 1; text-align: right;">-</span>
              <button onclick="toggleYtChannelEdit()"
                style="background: none; border: none; color: var(--heading-color); cursor: pointer; padding: 4px; border-radius: 4px; display: flex; align-items: center; transition: background 0.2s;"
                onmouseover="this.style.background='var(--button-hover-bg)'" onmouseout="this.style.background='none'"
                title="æ›´æ”¹é¢‘é“">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                  stroke-linecap="round" stroke-linejoin="round">
                  <path
                    d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z" />
                </svg>
              </button>
            </div>
            <!-- Hidden edit dropdown -->
            <div id="yt-channel-edit-container" style="display: none; flex: 1;">
              <div style="display: flex; gap: 8px; align-items: center;">
                <select id="yt-channel-edit-select"
                  style="flex: 1; padding: 4px 8px; border: 1px solid var(--input-border); border-radius: 4px; background: var(--input-bg); color: var(--text-primary); font-size: 13px;">
                  <option value="">é€‰æ‹©é¢‘é“...</option>
                </select>
                <button onclick="saveYtChannelEdit()"
                  style="background: var(--accent-green); color: #1e1e2e; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px;">
                  âœ“
                </button>
                <button onclick="cancelYtChannelEdit()"
                  style="background: var(--accent-red); color: #1e1e2e; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px;">
                  âœ•
                </button>
              </div>
            </div>
          </div>
          <div class="info-row">
            <span class="info-label">æ ‡é¢˜</span>
            <span class="info-value" id="yt-title" style="text-align: right;">-</span>
          </div>
          <div class="info-row">
            <span class="info-label">åˆ†åŒº</span>
            <span class="info-value" id="yt-topic" style="text-align: right;">-</span>
          </div>
          <div class="info-row">
            <span class="info-label">é…ç½®åˆ†åŒº</span>
            <div style="display: flex; align-items: center; gap: 8px; flex: 1;">
              <span class="info-value" id="yt-area" style="flex: 1; text-align: right;">-</span>
              <button onclick="toggleYtAreaEdit()"
                style="background: none; border: none; color: var(--heading-color); cursor: pointer; padding: 4px; border-radius: 4px; display: flex; align-items: center; transition: background 0.2s;"
                onmouseover="this.style.background='var(--button-hover-bg)'" onmouseout="this.style.background='none'"
                title="æ›´æ”¹é…ç½®åˆ†åŒº">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                  stroke-linecap="round" stroke-linejoin="round">
                  <path
                    d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z" />
                </svg>
              </button>
            </div>
            <!-- Hidden edit dropdown -->
            <div id="yt-area-edit-container" style="display: none; flex: 1;">
              <div style="display: flex; gap: 8px; align-items: center;">
                <select id="yt-area-edit-select"
                  style="flex: 1; padding: 4px 8px; border: 1px solid var(--input-border); border-radius: 4px; background: var(--input-bg); color: var(--text-primary); font-size: 13px;">
                  <option value="">é€‰æ‹©åˆ†åŒº...</option>
                </select>
                <button onclick="saveYtAreaEdit()"
                  style="background: var(--accent-green); color: #1e1e2e; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px;">
                  âœ“
                </button>
                <button onclick="cancelYtAreaEdit()"
                  style="background: var(--accent-red); color: #1e1e2e; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px;">
                  âœ•
                </button>
              </div>
            </div>
          </div>
          <div class="info-row">
            <span class="info-label">ç”»è´¨</span>
            <div style="display: flex; align-items: center; gap: 8px; flex: 1;">
              <span class="info-value" id="yt-quality" style="flex: 1; text-align: right;">-</span>
              <button onclick="toggleYtQualityEdit()"
                style="background: none; border: none; color: var(--heading-color); cursor: pointer; padding: 4px; border-radius: 4px; display: flex; align-items: center; transition: background 0.2s;"
                onmouseover="this.style.background='var(--button-hover-bg)'" onmouseout="this.style.background='none'"
                title="æ›´æ”¹ç”»è´¨">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                  stroke-linecap="round" stroke-linejoin="round">
                  <path
                    d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z" />
                </svg>
              </button>
            </div>
            <!-- Hidden edit dropdown -->
            <div id="yt-quality-edit-container" style="display: none; flex: 1;">
              <div style="display: flex; gap: 8px; align-items: center;">
                <select id="yt-quality-edit-select"
                  style="flex: 1; min-width: 0; padding: 4px 8px; border: 1px solid var(--input-border); border-radius: 4px; background: var(--input-bg); color: var(--text-primary); font-size: 13px;">
                </select>
                <button onclick="saveYtQualityEdit()"
                  style="background: var(--accent-green); color: #1e1e2e; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px;">
                  âœ“
                </button>
                <button onclick="cancelYtQualityEdit()"
                  style="background: var(--accent-red); color: #1e1e2e; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px;">
                  âœ•
                </button>
              </div>
            </div>
          </div>
        </div>

        <div class="card">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
            <h2 style="margin: 0;">
              <span class="status-indicator" id="tw-status"></span>
              Twitch
            </h2>
            <div style="display: flex; gap: 8px; align-items: center;">
              <!-- Toggle Switch -->
              <label class="toggle-label">
                <div class="toggle-switch">
                  <input type="checkbox" id="twitch-monitor-toggle" onchange="toggleTwitchMonitor()">
                  <span class="toggle-slider"></span>
                </div>
              </label>
              <button id="refreshTwitchBtn" onclick="refreshTwitchStatus()" title="åˆ·æ–°çŠ¶æ€"
                style="padding: 8px; background: linear-gradient(135deg, #89b4fa 0%, #cba6f7 100%); color: #1e1e2e; border: none; border-radius: 6px; cursor: pointer; transition: all 0.3s ease; display: flex; align-items: center; justify-content: center;">
                <svg id="refreshTwitchIcon" fill="currentColor" width="16" height="16" viewBox="0 0 24 24"
                  xmlns="http://www.w3.org/2000/svg" style="transition: transform 0.6s ease;">
                  <path
                    d="M19.146 4.854l-1.489 1.489A8 8 0 1 0 12 20a8.094 8.094 0 0 0 7.371-4.886 1 1 0 1 0-1.842-.779A6.071 6.071 0 0 1 12 18a6 6 0 1 1 4.243-10.243l-1.39 1.39a.5.5 0 0 0 .354.854H19.5A.5.5 0 0 0 20 9.5V5.207a.5.5 0 0 0-.854-.353z" />
                </svg>
              </button>
            </div>
          </div>
          <div class="info-row">
            <span class="info-label">é¢‘é“</span>
            <div style="display: flex; align-items: center; gap: 8px; flex: 1;">
              <span class="info-value" id="tw-channel-name" style="flex: 1; text-align: right;">-</span>
              <button onclick="toggleTwChannelEdit()"
                style="background: none; border: none; color: var(--heading-color); cursor: pointer; padding: 4px; border-radius: 4px; display: flex; align-items: center; transition: background 0.2s;"
                onmouseover="this.style.background='var(--button-hover-bg)'" onmouseout="this.style.background='none'"
                title="æ›´æ”¹é¢‘é“">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                  stroke-linecap="round" stroke-linejoin="round">
                  <path
                    d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z" />
                </svg>
              </button>
            </div>
            <!-- Hidden edit dropdown -->
            <div id="tw-channel-edit-container" style="display: none; flex: 1;">
              <div style="display: flex; gap: 8px; align-items: center;">
                <select id="tw-channel-edit-select"
                  style="flex: 1; padding: 4px 8px; border: 1px solid var(--input-border); border-radius: 4px; background: var(--input-bg); color: var(--text-primary); font-size: 13px;">
                  <option value="">é€‰æ‹©é¢‘é“...</option>
                </select>
                <button onclick="saveTwChannelEdit()"
                  style="background: var(--accent-green); color: #1e1e2e; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px;">
                  âœ“
                </button>
                <button onclick="cancelTwChannelEdit()"
                  style="background: var(--accent-red); color: #1e1e2e; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px;">
                  âœ•
                </button>
              </div>
            </div>
          </div>
          <div class="info-row">
            <span class="info-label">æ ‡é¢˜</span>
            <span class="info-value" id="tw-title" style="text-align: right;">-</span>
          </div>
          <div class="info-row">
            <span class="info-label">æ¸¸æˆ</span>
            <span class="info-value" id="tw-game" style="text-align: right;">-</span>
          </div>
          <div class="info-row">
            <span class="info-label">é…ç½®åˆ†åŒº</span>
            <div style="display: flex; align-items: center; gap: 8px; flex: 1;">
              <span class="info-value" id="tw-area" style="flex: 1; text-align: right;">-</span>
              <button onclick="toggleTwAreaEdit()"
                style="background: none; border: none; color: var(--heading-color); cursor: pointer; padding: 4px; border-radius: 4px; display: flex; align-items: center; transition: background 0.2s;"
                onmouseover="this.style.background='var(--button-hover-bg)'" onmouseout="this.style.background='none'"
                title="æ›´æ”¹é…ç½®åˆ†åŒº">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                  stroke-linecap="round" stroke-linejoin="round">
                  <path
                    d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z" />
                </svg>
              </button>
            </div>
            <!-- Hidden edit dropdown -->
            <div id="tw-area-edit-container" style="display: none; flex: 1;">
              <div style="display: flex; gap: 8px; align-items: center;">
                <select id="tw-area-edit-select"
                  style="flex: 1; padding: 4px 8px; border: 1px solid var(--input-border); border-radius: 4px; background: var(--input-bg); color: var(--text-primary); font-size: 13px;">
                  <option value="">é€‰æ‹©åˆ†åŒº...</option>
                </select>
                <button onclick="saveTwAreaEdit()"
                  style="background: var(--accent-green); color: #1e1e2e; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px;">
                  âœ“
                </button>
                <button onclick="cancelTwAreaEdit()"
                  style="background: var(--accent-red); color: #1e1e2e; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px;">
                  âœ•
                </button>
              </div>
            </div>
          </div>
          <div class="info-row">
            <span class="info-label">ç”»è´¨</span>
            <div style="display: flex; align-items: center; gap: 8px; flex: 1;">
              <span class="info-value" id="tw-quality" style="flex: 1; text-align: right;">-</span>
              <button onclick="toggleTwQualityEdit()"
                style="background: none; border: none; color: var(--heading-color); cursor: pointer; padding: 4px; border-radius: 4px; display: flex; align-items: center; transition: background 0.2s;"
                onmouseover="this.style.background='var(--button-hover-bg)'" onmouseout="this.style.background='none'"
                title="æ›´æ”¹ç”»è´¨">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                  stroke-linecap="round" stroke-linejoin="round">
                  <path
                    d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z" />
                </svg>
              </button>
            </div>
            <!-- Hidden edit dropdown -->
            <div id="tw-quality-edit-container" style="display: none; flex: 1;">
              <div style="display: flex; gap: 8px; align-items: center;">
                <select id="tw-quality-edit-select"
                  style="flex: 1; min-width: 0; padding: 4px 8px; border: 1px solid var(--input-border); border-radius: 4px; background: var(--input-bg); color: var(--text-primary); font-size: 13px;">
                </select>
                <button onclick="saveTwQualityEdit()"
                  style="background: var(--accent-green); color: #1e1e2e; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px;">
                  âœ“
                </button>
                <button onclick="cancelTwQualityEdit()"
                  style="background: var(--accent-red); color: #1e1e2e; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px;">
                  âœ•
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="controls" id="holodex-section" style="margin-top: 20px;">
        <h2 style="cursor: pointer; user-select: none; display: flex; align-items: center; gap: 8px;"
          onclick="toggleHolodex()">
          <svg viewBox="0 0 24 24" focusable="false" style="width: 24px; height: 24px;">
            <g>
              <path d="M4.5 2a2 2 0 0 1 3-1.7L23 9.6a2 2 0 0 1 0 3.5L7.6 22.4a2 2 0 0 1-3-1.7V2Z"
                fill="url(#holodex-a)">
              </path>
              <path d="M0 2A2 2 0 0 1 3 .3l15.5 9.3a2 2 0 0 1 0 3.5L3.1 22.4A2 2 0 0 1 0 20.7V2Z"
                fill="url(#holodex-b)">
              </path>
            </g>
            <defs>
              <linearGradient id="holodex-a" x1=".2" y1="2.8" x2="19.3" y2="18.5" gradientUnits="userSpaceOnUse">
                <stop stop-color="#F06292"></stop>
                <stop offset="1" stop-color="#FF3A81"></stop>
              </linearGradient>
              <linearGradient id="holodex-b" x1="-4.4" y1="2.8" x2="19.5" y2="11.3" gradientUnits="userSpaceOnUse">
                <stop stop-color="#5DA2F2"></stop>
                <stop offset="1" stop-color="#715BF7" stop-opacity=".8"></stop>
              </linearGradient>
            </defs>
          </svg>
          <span>Holodex ç›´æ’­ç›‘æ§</span>
          <span id="holodex-toggle">â–¼</span>
        </h2>
        <div id="holodex-container" style="display: none;">
          <!-- API Key Configuration Section -->
          <div id="holodex-api-config"
            style="display: none; padding: 20px; background: var(--input-bg); border-radius: 8px; margin-bottom: 15px; border: 1px solid var(--card-border);">
            <h3 style="color: var(--heading-color); margin-bottom: 15px; display: flex; align-items: center; gap: 8px;">
              ğŸ”‘ é…ç½® Holodex API Key
            </h3>
            <p style="color: var(--text-secondary); margin-bottom: 15px; line-height: 1.6;">
              Holodex API ç”¨äºè·å– YouTube ç›´æ’­çŠ¶æ€
            </p>
            <div class="control-group" style="margin-bottom: 15px;">
              <label style="color: var(--text-secondary); font-weight: 500;">API Key</label>
              <input type="text" id="holodex-api-input" placeholder="è¾“å…¥ä½ çš„ Holodex API Key"
                style="width: 100%; padding: 12px; border: 2px solid var(--input-border); border-radius: 8px; font-size: 14px; background: var(--input-bg); color: var(--text-primary);">
            </div>
            <div
              style="background: var(--card-bg); padding: 15px; border-radius: 6px; margin-bottom: 15px; border: 1px solid var(--info-border);">
              <h4 style="color: var(--text-primary); margin-bottom: 10px; font-size: 14px;">ğŸ“‹ å¦‚ä½•è·å– API Key:</h4>
              <ol style="color: var(--text-secondary); font-size: 13px; line-height: 1.5; padding-left: 20px;">
                <li>è®¿é—® <a href="https://holodex.net/login" target="_blank" rel="noopener noreferrer"
                    style="color: var(--heading-color);">holodex.net/login</a></li>
                <li>ç™»å½•, å¤åˆ¶ API Key è‡³ä¸Šæ–¹è¾“å…¥æ¡†</li>
              </ol>
            </div>
            <div style="display: flex; gap: 10px;">
              <button class="btn-success" onclick="saveHolodexApiKey()" style="flex: 1;">
                ğŸ’¾ ä¿å­˜é…ç½®
              </button>
              <button class="btn-secondary" onclick="testHolodexApiKey()" style="flex: 1;">
                ğŸ§ª æµ‹è¯•è¿æ¥
              </button>
            </div>
          </div>

          <!-- Streams Display Section -->
          <div id="holodex-streams-section">
            <div id="holodex-status"
              style="padding: 15px; background: #f0f0f0; border-radius: 8px; margin-bottom: 15px; text-align: center;">
              åŠ è½½ä¸­...
            </div>
            <div id="holodex-streams"
              style="display: grid; grid-template-columns: repeat(auto-fill, minmax(min(100%, 320px), 1fr)); gap: 15px; margin-bottom: 15px;">
              <!-- Streams will be populated here -->
            </div>
            <button class="btn-primary" onclick="refreshHolodexStreams()"
              style="width: 100%; display: flex; align-items: center; justify-content: center; gap: 8px;">
              <svg id="refreshHolodexIcon" fill="currentColor" width="16" height="16" viewBox="0 0 24 24"
                xmlns="http://www.w3.org/2000/svg" style="transition: transform 0.6s ease;">
                <path
                  d="M19.146 4.854l-1.489 1.489A8 8 0 1 0 12 20a8.094 8.094 0 0 0 7.371-4.886 1 1 0 1 0-1.842-.779A6.071 6.071 0 0 1 12 18a6 6 0 1 1 4.243-10.243l-1.39 1.39a.5.5 0 0 0 .354.854H19.5A.5.5 0 0 0 20 9.5V5.207a.5.5 0 0 0-.854-.353z" />
              </svg>
              <span>åˆ·æ–°ç›´æ’­åˆ—è¡¨</span>
            </button>
          </div>
        </div>
      </div>

      <div class="controls" style="margin-top: 20px;">
        <h2 style="cursor: pointer; user-select: none;" onclick="toggleChannelManagement()">
          ğŸ“º é¢‘é“ç®¡ç† <span id="channel-toggle">â–¼</span>
        </h2>

        <div id="channel-management-container" style="display: none;">
          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px;">
            <div class="control-group">
              <label>å¹³å°</label>
              <select id="platform-select" onchange="updateChannelList()">
                <option value="youtube">YouTube</option>
                <option value="twitch">Twitch</option>
              </select>
            </div>

            <div class="control-group">
              <label>é€‰æ‹©é¢‘é“ (å¯é€‰)</label>
              <select id="channel-select" onchange="updateChannelInfo()">
                <option value="">é€‰æ‹©é¢„è®¾é¢‘é“æˆ–æ‰‹åŠ¨è¾“å…¥...</option>
              </select>
            </div>

            <div class="control-group">
              <label>é¢‘é“ID (å¿…å¡«)</label>
              <input type="text" id="channel-id-input" placeholder="è¾“å…¥é¢‘é“IDæˆ–ä»ä¸Šæ–¹é€‰æ‹©">
            </div>

            <div class="control-group">
              <label>é¢‘é“åç§° (å¿…å¡«)</label>
              <input type="text" id="channel-name-input" placeholder="è¾“å…¥é¢‘é“åç§°æˆ–ä»ä¸Šæ–¹é€‰æ‹©">
            </div>

            <div class="control-group">
              <label>åˆ†åŒº (å¯é€‰)</label>
              <select id="area-select" onchange="toggleLolMonitorInputs()">
                <option value="">ä¸ä¿®æ”¹åˆ†åŒº</option>
              </select>
            </div>

            <div class="control-group">
              <label>ç”»è´¨ (å¯é€‰)</label>
              <select id="quality-select" onchange="updateQualityOptions()">
                <option value="">ä¸ä¿®æ”¹ç”»è´¨</option>
              </select>
            </div>
          </div>

          <!-- Full-width sections that should span both columns -->
          <div class="control-group" id="lol-monitor-group" style="display: none;">
            <label style="display: flex; align-items: center; gap: 10px;">
              <input type="checkbox" id="enable-lol-monitor-inline" onchange="toggleRiotApiKeyInputInline()">
              <span>å¯ç”¨è‹±é›„è”ç›Ÿç©å®¶IDç›‘æ§</span>
            </label>
            <small style="color: #888; display: block; margin-top: 5px;">
              ç›‘æ§æ¸¸æˆå†…ç©å®¶IDæ˜¯å¦åŒ…å«è¿ç¦è¯æ±‡
            </small>
          </div>

          <div class="control-group" id="riot-api-key-group" style="display: none;">
            <label>Riot API Key</label>
            <input type="text" id="riot-api-key-input" placeholder="ç•™ç©ºè¡¨ç¤ºä¸ä¿®æ”¹">
            <small style="color: #888; display: block; margin-top: 5px;">
              è·å–: <a href="https://developer.riotgames.com/" target="_blank">developer.riotgames.com</a>
            </small>
          </div>

          <div class="button-group">
            <button class="btn-primary" onclick="applyChannelChange()">åº”ç”¨æ›´æ”¹</button>
          </div>
        </div>
      </div>

      <!-- Area and Channel Management Section -->
      <div class="controls" style="margin-top: 20px;">
        <h2 style="cursor: pointer; user-select: none; display: flex; align-items: center; gap: 8px;"
          onclick="toggleManagement()">
          ğŸ—ƒï¸ é…ç½®ç®¡ç† <span id="management-toggle">â–¼</span>
        </h2>
        <div id="management-container" style="display: none;">

          <!-- Area Management -->
          <div style="margin-bottom: 30px;">
            <h3
              style="cursor: pointer; user-select: none; display: flex; align-items: center; gap: 8px; color: var(--text-primary); margin-bottom: 15px; font-size: 1.2em; font-weight: 600; padding: 12px 0; border-bottom: 1px solid var(--card-border);"
              onclick="toggleAreaManagement()">
              <svg viewBox="0 0 24 24" focusable="false" style="width: 20px; height: 20px;">
                <path d="M3 13h8V3H3v10zm0 8h8v-6H3v6zm10 0h8V11h-8v10zm0-18v6h8V3h-8z" fill="url(#area-gradient)" />
                <defs>
                  <linearGradient id="area-gradient" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" style="stop-color:#f38ba8;stop-opacity:1" />
                    <stop offset="100%" style="stop-color:#fab387;stop-opacity:1" />
                  </linearGradient>
                </defs>
              </svg>
              åˆ†åŒºç®¡ç† <span id="area-management-toggle">â–¼</span>
            </h3>
            <div id="area-management-content" style="display: none;">

              <!-- Add Area Form -->
              <div
                style="background: var(--input-bg); padding: 20px; border-radius: 8px; margin-bottom: 15px; border: 1px solid var(--card-border);">
                <h4 id="area-form-title" style="margin-bottom: 15px; color: var(--text-primary);">æ·»åŠ æ–°åˆ†åŒº</h4>

                <!-- Bilibili API Hint -->
                <div
                  style="background: var(--input-bg); padding: 12px; border-radius: 6px; margin-bottom: 15px; border-left: 3px solid var(--heading-color);">
                  <small style="color: var(--text-secondary);">
                    ğŸ’¡ Bç«™åˆ†åŒºIDå¯ä»
                    <a href="https://api.live.bilibili.com/room/v1/Area/getList" target="_blank"
                      style="color: var(--heading-color); text-decoration: none; font-weight: 500;">
                      Bç«™ç›´æ’­åˆ†åŒºAPI
                    </a>
                    è·å–ï¼Œè¾“å…¥å¯¹åº”çš„åˆ†åŒºIDå’Œåç§°
                  </small>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 2fr; gap: 15px; margin-bottom: 15px;">
                  <div>
                    <label
                      style="color: var(--text-primary); font-weight: 500; margin-bottom: 5px; display: block;">åˆ†åŒºID</label>
                    <input type="number" id="area-id" placeholder=""
                      style="width: 100%; padding: 8px 12px; border: 1px solid var(--input-border); border-radius: 6px; background: var(--card-bg); color: var(--text-primary); font-size: 14px;">
                  </div>
                  <div>
                    <label
                      style="color: var(--text-primary); font-weight: 500; margin-bottom: 5px; display: block;">åˆ†åŒºåç§°</label>
                    <input type="text" id="area-name" placeholder=""
                      style="width: 100%; padding: 8px 12px; border: 1px solid var(--input-border); border-radius: 6px; background: var(--card-bg); color: var(--text-primary); font-size: 14px;">
                  </div>
                </div>
                <div style="margin-bottom: 15px;">
                  <label style="color: var(--text-primary); font-weight: 500; margin-bottom: 5px; display: block;">
                    æ ‡é¢˜å…³é”®è¯ (ç”¨", "åˆ†éš”)
                    <small
                      style="color: #888; font-weight: normal; display: block; margin-top: 2px;">ç”¨äºè‡ªåŠ¨æ£€æµ‹ç›´æ’­åˆ†åŒºï¼ŒåŒ¹é…YouTubeåˆ†åŒº/Twitchæ¸¸æˆæˆ–ç›´æ’­æ ‡é¢˜ä¸­çš„å…³é”®è¯</small>
                  </label>
                  <input type="text" id="area-keywords" placeholder="ä¾‹: league of legends, lol, ã‚ã‚‹"
                    style="width: 100%; padding: 8px 12px; border: 1px solid var(--input-border); border-radius: 6px; background: var(--card-bg); color: var(--text-primary); font-size: 14px;">
                </div>
                <div style="margin-bottom: 15px;">
                  <label style="color: var(--text-primary); font-weight: 500; margin-bottom: 5px; display: block;">
                    åˆ«å (ç”¨", "åˆ†éš”)
                    <small
                      style="color: #888; font-weight: normal; display: block; margin-top: 2px;">ç”¨äºå¼¹å¹•æŒ‡ä»¤è¯†åˆ«ï¼Œè§‚ä¼—å¯ä»¥é€šè¿‡è¿™äº›åˆ«ååˆ‡æ¢åˆ°æ­¤åˆ†åŒº</small>
                  </label>
                  <input type="text" id="area-aliases" placeholder="ä¾‹: lol, ç“¦"
                    style="width: 100%; padding: 8px 12px; border: 1px solid var(--input-border); border-radius: 6px; background: var(--card-bg); color: var(--text-primary); font-size: 14px;">
                </div>
                <div style="display: flex; gap: 10px;">
                  <button id="area-submit-btn" class="btn-primary" onclick="addArea()">æ·»åŠ åˆ†åŒº</button>
                  <button class="btn-secondary" onclick="clearAreaForm()">æ¸…ç©ºè¡¨å•</button>
                </div>
              </div>

              <!-- Areas List -->
              <div id="areas-list"
                style="background: var(--input-bg); padding: 15px; border-radius: 8px; border: 1px solid var(--card-border);">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                  <h4
                    style="cursor: pointer; user-select: none; display: flex; align-items: center; gap: 8px; color: var(--text-primary);"
                    onclick="toggleAreasList()">
                    ç°æœ‰åˆ†åŒº <span id="areas-list-toggle">â–¼</span>
                  </h4>
                  <button id="refreshAreasBtn" onclick="refreshAreas()" title="åˆ·æ–°åˆ†åŒºåˆ—è¡¨"
                    style="display: none; padding: 8px; background: linear-gradient(135deg, #89b4fa 0%, #cba6f7 100%); color: #1e1e2e; border: none; border-radius: 6px; cursor: pointer; transition: all 0.3s ease; align-items: center; justify-content: center;">
                    <svg id="refreshAreasIcon" fill="currentColor" width="16" height="16" viewBox="0 0 24 24"
                      xmlns="http://www.w3.org/2000/svg" style="transition: transform 0.6s ease;">
                      <path
                        d="M19.146 4.854l-1.489 1.489A8 8 0 1 0 12 20a8.094 8.094 0 0 0 7.371-4.886 1 1 0 1 0-1.842-.779A6.071 6.071 0 0 1 12 18a6 6 0 1 1 4.243-10.243l-1.39 1.39a.5.5 0 0 0 .354.854H19.5A.5.5 0 0 0 20 9.5V5.207a.5.5 0 0 0-.854-.353z" />
                    </svg>
                  </button>
                </div>
                <div id="areas-content" style="display: none;">åŠ è½½ä¸­...</div>
              </div>
            </div>
          </div>

          <!-- Channel Management -->
          <div>
            <h3
              style="cursor: pointer; user-select: none; display: flex; align-items: center; gap: 8px; color: var(--text-primary); margin-bottom: 15px; font-size: 1.2em; font-weight: 600; padding: 12px 0; border-bottom: 1px solid var(--card-border);"
              onclick="toggleChannelConfig()">
              <svg viewBox="0 0 24 24" focusable="false" style="width: 20px; height: 20px;">
                <path
                  d="M21 6h-2v9H6v2c0 .55.45 1 1 1h11l4 4V7c0-.55-.45-1-1-1zm-4 6V3c0-.55-.45-1-1-1H3c-.55 0-1 .45-1 1v14l4-4h11c.55 0 1-.45 1-1z"
                  fill="url(#channel-gradient)" />
                <defs>
                  <linearGradient id="channel-gradient" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" style="stop-color:#a6e3a1;stop-opacity:1" />
                    <stop offset="100%" style="stop-color:#94e2d5;stop-opacity:1" />
                  </linearGradient>
                </defs>
              </svg>
              é¢‘é“é…ç½®ç®¡ç† <span id="channel-management-toggle">â–¼</span>
            </h3>
            <div id="channel-management-content" style="display: none;">

              <!-- Add Channel Form -->
              <div
                style="background: var(--input-bg); padding: 20px; border-radius: 8px; margin-bottom: 15px; border: 1px solid var(--card-border);">
                <h4 id="channel-form-title" style="margin-bottom: 15px; color: var(--text-primary);">æ·»åŠ é¢‘é“</h4>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                  <div>
                    <label style="color: var(--text-primary); font-weight: 500; margin-bottom: 5px; display: block;">
                      é¢‘é“åç§°
                      <small style="color: #888; font-weight: normal; display: block; margin-top: 2px;">å°†å‡ºç°äºè½¬æ’­æ ‡é¢˜</small>
                    </label>

                    <input type="text" id="channel-name" placeholder=""
                      style="width: 100%; padding: 8px 12px; border: 1px solid var(--input-border); border-radius: 6px; background: var(--card-bg); color: var(--text-primary); font-size: 14px;">
                  </div>
                  <div>
                    <label style="color: var(--text-primary); font-weight: 500; margin-bottom: 5px; display: block;">
                      åˆ«å (ç”¨", "åˆ†éš”)
                      <small style="color: #888; font-weight: normal; display: block; margin-top: 2px;">ç”¨äºå¼¹å¹•æŒ‡ä»¤è¯†åˆ«</small>
                    </label>
                    <input type="text" id="channel-aliases" placeholder="ä¾‹: æ˜µç§°1, æ˜µç§°2"
                      style="width: 100%; padding: 8px 12px; border: 1px solid var(--input-border); border-radius: 6px; background: var(--card-bg); color: var(--text-primary); font-size: 14px;">
                  </div>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                  <div>
                    <label style="color: var(--text-primary); font-weight: 500; margin-bottom: 5px; display: block;">
                      YouTube é¢‘é“ID (å¯é€‰)
                    </label>
                    <input type="text" id="channel-youtube" placeholder="UCå¼€å¤´çš„é¢‘é“ID"
                      style="width: 100%; padding: 8px 12px; border: 1px solid var(--input-border); border-radius: 6px; background: var(--card-bg); color: var(--text-primary); font-size: 14px;">
                  </div>
                  <div>
                    <label style="color: var(--text-primary); font-weight: 500; margin-bottom: 5px; display: block;">
                      Twitch é¢‘é“ID (å¯é€‰)
                    </label>
                    <input type="text" id="channel-twitch" placeholder="ID in Twitch url"
                      style="width: 100%; padding: 8px 12px; border: 1px solid var(--input-border); border-radius: 6px; background: var(--card-bg); color: var(--text-primary); font-size: 14px;">
                  </div>
                </div>
                <div style="margin-bottom: 15px;">
                  <div
                    style="background: var(--input-bg); padding: 10px; border-radius: 6px; margin-bottom: 10px; border-left: 3px solid var(--heading-color);">
                    <small style="color: var(--text-secondary);">ğŸ’¡ è‡³å°‘å¡«å†™ä¸€ä¸ªå¹³å°çš„é¢‘é“ID</small>
                  </div>
                  <label style="color: var(--text-primary); font-weight: 500; margin-bottom: 5px; display: block;">Riot
                    PUUID (å¯é€‰)</label>
                  <input type="text" id="channel-riot" placeholder="è‹±é›„è”ç›ŸPUUID"
                    style="width: 100%; padding: 8px 12px; border: 1px solid var(--input-border); border-radius: 6px; background: var(--card-bg); color: var(--text-primary); font-size: 14px;">
                </div>
                <div style="display: flex; gap: 10px;">
                  <button id="channel-submit-btn" class="btn-primary" onclick="addChannel()">æ·»åŠ é¢‘é“</button>
                  <button class="btn-secondary" onclick="clearChannelForm()">æ¸…ç©ºè¡¨å•</button>
                </div>
              </div>

              <!-- Channels List -->
              <div id="channels-list"
                style="background: var(--input-bg); padding: 15px; border-radius: 8px; border: 1px solid var(--card-border);">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                  <h4
                    style="cursor: pointer; user-select: none; display: flex; align-items: center; gap: 8px; color: var(--text-primary);"
                    onclick="toggleChannelsList()">
                    ç°æœ‰é¢‘é“ <span id="channels-list-toggle">â–¼</span>
                  </h4>
                  <button id="refreshChannelsBtn" onclick="refreshChannels()" title="åˆ·æ–°é¢‘é“åˆ—è¡¨"
                    style="display: none; padding: 8px; background: linear-gradient(135deg, #89b4fa 0%, #cba6f7 100%); color: #1e1e2e; border: none; border-radius: 6px; cursor: pointer; transition: all 0.3s ease; align-items: center; justify-content: center;">
                    <svg id="refreshChannelsIcon" fill="currentColor" width="16" height="16" viewBox="0 0 24 24"
                      xmlns="http://www.w3.org/2000/svg" style="transition: transform 0.6s ease;">
                      <path
                        d="M19.146 4.854l-1.489 1.489A8 8 0 1 0 12 20a8.094 8.094 0 0 0 7.371-4.886 1 1 0 1 0-1.842-.779A6.071 6.071 0 0 1 12 18a6 6 0 1 1 4.243-10.243l-1.39 1.39a.5.5 0 0 0 .354.854H19.5A.5.5 0 0 0 20 9.5V5.207a.5.5 0 0 0-.854-.353z" />
                    </svg>
                  </button>
                </div>
                <div id="channels-content" style="display: none;">åŠ è½½ä¸­...</div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- System Configuration Section -->
      <div class="controls" style="margin-top: 20px;">
        <h2 style="cursor: pointer; user-select: none;" onclick="toggleSystemConfig()">
          âš™ï¸ ç³»ç»Ÿè®¾ç½® <span id="system-config-toggle">â–¼</span>
        </h2>
        <div id="system-config-container" style="display: none;">

          <!-- Basic Settings Section -->
          <div style="margin-bottom: 30px;">
            <h3
              style="color: var(--text-primary); margin-bottom: 20px; font-size: 1.1em; font-weight: 600; padding-bottom: 8px; border-bottom: 1px solid var(--card-border);">
              åŸºç¡€è®¾ç½®
            </h3>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(270px, 1fr)); gap: 25px;">
              <div class="control-group">
                <label>æ£€æµ‹é—´éš” (ç§’)</label>
                <input type="number" id="config-interval" min="10" max="300" placeholder="30">
              </div>
              <div class="control-group">
                <label class="toggle-label">
                  <div class="toggle-switch">
                    <input type="checkbox" id="config-auto-cover-checkbox">
                    <span class="toggle-slider"></span>
                  </div>
                  <span>è‡ªåŠ¨æ›´æ¢å°é¢</span>
                </label>
              </div>
              <div class="control-group">
                <label class="toggle-label">
                  <div class="toggle-switch">
                    <input type="checkbox" id="config-danmaku-command-checkbox">
                    <span class="toggle-slider"></span>
                  </div>
                  <span>å¯ç”¨å¼¹å¹•æŒ‡ä»¤</span>
                </label>
              </div>
              <div class="control-group">
                <label>HTTP ä»£ç†è®¾ç½® (å¯é€‰)</label>
                <input type="text" id="config-proxy" placeholder="http://proxy:port">
              </div>
            </div>
          </div>

          <!-- API Keys Section -->
          <div style="margin-bottom: 30px;">
            <h3
              style="color: var(--text-primary); margin-bottom: 20px; font-size: 1.1em; font-weight: 600; padding-bottom: 8px; border-bottom: 1px solid var(--card-border);">
              API å¯†é’¥
            </h3>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(270px, 1fr)); gap: 25px;">
              <div class="control-group">
                <label>Holodex API Key (å¯é€‰)</label>
                <input type="text" id="config-holodex-key" placeholder="ç”¨äº YouTube ç›´æ’­çŠ¶æ€æ£€æµ‹">
                <small style="color: var(--text-secondary); display: block; margin-top: 8px;">
                  è·å–: <a href="https://holodex.net/login" target="_blank" rel="noopener noreferrer"
                    style="color: var(--accent-pink);">holodex.net</a>
                </small>
              </div>
              <div class="control-group">
                <label class="toggle-label" style="margin-bottom: 15px;">
                  <div class="toggle-switch">
                    <input type="checkbox" id="config-lol-monitor-checkbox" onchange="toggleConfigRiotApiKey()">
                    <span class="toggle-slider"></span>
                  </div>
                  <span>å¯ç”¨è‹±é›„è”ç›Ÿç©å®¶IDç›‘æ§</span>
                </label>
                <div id="config-riot-api-group" style="display: none;">
                  <label>Riot API Key</label>
                  <input type="text" id="config-riot-key" placeholder="ç”¨äºç›‘æ§æ¸¸æˆå†…è¿ç¦è¯æ±‡">
                  <small style="color: var(--text-secondary); display: block; margin-top: 8px;">
                    è·å–: <a href="https://developer.riotgames.com/" target="_blank" rel="noopener noreferrer"
                      style="color: var(--accent-pink);">developer.riotgames.com</a>
                  </small>
                </div>
                <div id="config-lol-interval-group" style="display: none; margin-top: 15px;">
                  <label>LoL ç›‘æ§é—´éš” (åˆ†é’Ÿ)</label>
                  <input type="number" id="config-lol-interval" min="1" max="60" placeholder="1">
                </div>
              </div>
            </div>
          </div>

          <!-- Platform Settings Section -->
          <div style="margin-bottom: 30px;">
            <h3
              style="color: var(--text-primary); margin-bottom: 20px; font-size: 1.1em; font-weight: 600; padding-bottom: 8px; border-bottom: 1px solid var(--card-border);">
              å¹³å°è®¾ç½®
            </h3>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(270px, 1fr)); gap: 25px;">
              <div class="control-group">
                <label>Twitch OAuth Token (å¯é€‰)</label>
                <input type="text" id="config-tw-oauth" placeholder="ç”¨äº streamlink è®¤è¯">
                <small style="color: var(--text-secondary); display: block; margin-top: 8px;">
                  è·å–æ–¹æ³•: <a href="https://streamlink.github.io/cli/plugins/twitch.html#authentication" target="_blank"
                    rel="noopener noreferrer" style="color: var(--accent-pink);">Streamlink Twitch è®¤è¯æ–‡æ¡£</a>
                </small>
              </div>
              <div class="control-group">
                <label>Twitch ä»£ç†åŒºåŸŸ</label>
                <select id="config-tw-region">
                  <option value="asl">asl - äºšæ´² (luminous, æ¨è)</option>
                  <option value="eul">eul - æ¬§æ´² (luminous, æ¨è)</option>
                  <option value="eu2l">eu2l - æ¬§æ´² 2 (luminous)</option>
                  <option value="as">as - äºšæ´² (TTV-LOL-PRO)</option>
                  <option value="eu">eu - æ¬§æ´² (TTV-LOL-PRO)</option>
                  <option value="eu2">eu2 - æ¬§æ´² 2 (TTV-LOL-PRO)</option>
                  <option value="eu3">eu3 - æ¬§æ´² 3 (TTV-LOL-PRO)</option>
                  <option value="eu4">eu4 - æ¬§æ´² 4 (TTV-LOL-PRO)</option>
                  <option value="eu5">eu5 - æ¬§æ´² 5 (TTV-LOL-PRO)</option>
                  <option value="na">na - åŒ—ç¾ (TTV-LOL-PRO)</option>
                  <option value="sa">sa - å—ç¾ (TTV-LOL-PRO)</option>
                  <option value="all">all - å…¨éƒ¨ä»£ç†</option>
                  <option value="perf">perf - TTV-LOL-PRO å…¨éƒ¨</option>
                </select>
              </div>
            </div>
          </div>

          <!-- Anti-Collision Settings Section -->
          <div style="margin-bottom: 30px;">
            <h3
              style="color: var(--text-primary); margin-bottom: 20px; font-size: 1.1em; font-weight: 600; padding-bottom: 8px; border-bottom: 1px solid var(--card-border);">
              é˜²æ’è½¦è®¾ç½®
            </h3>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(270px, 1fr)); gap: 25px;">
              <div class="control-group">
                <label class="toggle-label">
                  <div class="toggle-switch">
                    <input type="checkbox" id="config-anti-collision-checkbox" onchange="toggleAntiCollisionList()">
                    <span class="toggle-slider"></span>
                  </div>
                  <span>å¯ç”¨é˜²æ’è½¦</span>
                </label>
              </div>
            </div>
          </div>

          <!-- Anti-Collision List -->
          <div id="anti-collision-section" style="margin-top: 0px; display: none;">
            <h3 style="color: var(--text-primary); margin-bottom: 15px; font-size: 1.1em; font-weight: 600;">
              é˜²æ’è½¦åå•
            </h3>
            <div
              style="display: grid; grid-template-columns: repeat(auto-fit, minmax(270px, 1fr)); gap: 15px; margin-bottom: 20px;">
              <div class="control-group">
                <label>ç”¨æˆ·å</label>
                <input type="text" id="anti-collision-username" placeholder="è¾“å…¥ç”¨æˆ·å">
              </div>
              <div class="control-group">
                <label>æˆ¿é—´å·</label>
                <input type="number" id="anti-collision-roomid" placeholder="è¾“å…¥æˆ¿é—´å·">
              </div>
              <div class="control-group" style="display: flex; align-items: end;">
                <button class="btn-secondary" onclick="addAntiCollisionEntry()" style="width: 100%;">
                  æ·»åŠ åˆ°åå•
                </button>
              </div>
            </div>

            <div id="anti-collision-list"
              style="background: var(--card-bg); border: 1px solid var(--card-border); border-radius: 8px; padding: 15px; max-height: 300px; overflow-y: auto;">
              <div style="color: var(--text-secondary); text-align: center; padding: 20px;">
                åŠ è½½ä¸­...
              </div>
            </div>
          </div>

          <!-- Banned Keywords Settings Section -->
          <div style="margin-bottom: 30px;">
            <h3
              style="color: var(--text-primary); margin-bottom: 20px; font-size: 1.1em; font-weight: 600; padding-bottom: 8px; border-bottom: 1px solid var(--card-border);">
              ç¦ç”¨å…³é”®è¯è®¾ç½®
            </h3>

            <!-- Streaming Banned Keywords -->
            <div class="control-group" style="margin-bottom: 25px;">
              <label style="font-weight: 600; color: var(--text-primary); margin-bottom: 10px; display: block;">
                è½¬æ’­ç¦ç”¨å…³é”®è¯
                <small style="color: var(--text-secondary); font-weight: normal; display: block; margin-top: 5px;">
                  åŒ…å«è¿™äº›å…³é”®è¯çš„ç›´æ’­å°†ä¸ä¼šè¢«è½¬æ’­ï¼ˆæ¯è¡Œä¸€ä¸ªå…³é”®è¯ï¼‰
                </small>
              </label>
              <textarea id="streaming-banned-keywords" rows="6"
                style="width: 100%; padding: 12px; border: 2px solid var(--input-border); border-radius: 8px; font-size: 14px; background: var(--input-bg); color: var(--text-primary); font-family: monospace; resize: vertical;"
                placeholder="watchalong&#10;watchparty&#10;asmr"></textarea>
            </div>

            <!-- Danmaku Banned Keywords -->
            <div class="control-group">
              <label style="font-weight: 600; color: var(--text-primary); margin-bottom: 10px; display: block;">
                å¼¹å¹•å‘½ä»¤ç¦ç”¨å…³é”®è¯
                <small style="color: var(--text-secondary); font-weight: normal; display: block; margin-top: 5px;">
                  åŒ…å«è¿™äº›å…³é”®è¯çš„ç›´æ’­å°†ç¦ç”¨å¼¹å¹•å‘½ä»¤ï¼ˆæ¯è¡Œä¸€ä¸ªå…³é”®è¯ï¼‰
                </small>
              </label>
              <textarea id="danmaku-banned-keywords" rows="8"
                style="width: 100%; padding: 12px; border: 2px solid var(--input-border); border-radius: 8px; font-size: 14px; background: var(--input-bg); color: var(--text-primary); font-family: monospace; resize: vertical;"
                placeholder="watchalong&#10;talk&#10;freechat"></textarea>
            </div>
          </div>

          <div class="button-group" style="margin-top: 20px;">
            <button class="btn-primary" onclick="saveSystemConfig()">ä¿å­˜é…ç½®</button>
            <button class="btn-secondary" onclick="loadSystemConfig()">é‡æ–°åŠ è½½</button>
          </div>
        </div>
      </div>

      <div class="controls" style="margin-top: 20px;">
        <h2 style="cursor: pointer; user-select: none;" onclick="toggleLogs()">
          ğŸ“‹ ç³»ç»Ÿæ—¥å¿— <span id="log-toggle">â–¼</span>
        </h2>
        <div id="log-container" style="display: none;">
          <div
            style="background: #1e1e1e; color: #d4d4d4; padding: 15px; border-radius: 8px; font-family: 'SF Mono', 'Consolas', 'Liberation Mono', 'Menlo', 'Courier New', monospace; font-size: 14px; max-height: 400px; overflow-y: auto; line-height: 1.4; white-space: pre; overflow-x: auto;">
            <div id="log-output">ç­‰å¾…æ—¥å¿—...</div>
          </div>
          <div style="margin-top: 10px; display: flex; gap: 10px;">
            <button class="btn-secondary" onclick="clearLogs()">æ¸…ç©ºæ—¥å¿—</button>
            <button class="btn-primary" onclick="refreshLogs()" style="display: flex; align-items: center; gap: 6px;">
              <svg fill="currentColor" width="14" height="14" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path
                  d="M19.146 4.854l-1.489 1.489A8 8 0 1 0 12 20a8.094 8.094 0 0 0 7.371-4.886 1 1 0 1 0-1.842-.779A6.071 6.071 0 0 1 12 18a6 6 0 1 1 4.243-10.243l-1.39 1.39a.5.5 0 0 0 .354.854H19.5A.5.5 0 0 0 20 9.5V5.207a.5.5 0 0 0-.854-.353z" />
              </svg>
              <span>åˆ·æ–°æ—¥å¿—</span>
            </button>
            <label style="display: flex; align-items: center; gap: 5px; color: #666;">
              <input type="checkbox" id="auto-scroll-checkbox" checked> è‡ªåŠ¨æ»šåŠ¨
            </label>
          </div>
        </div>
      </div>

      <div style="text-align: center; color: white; margin-top: 40px; padding: 20px; opacity: 0.8;">
        <p style="margin-bottom: 10px;">
          <span id="version-display">Bilistream</span>
          <button onclick="checkForUpdates()"
            style="margin-left: 10px; padding: 5px 15px; background: rgba(255,255,255,0.2); color: white; border: 1px solid rgba(255,255,255,0.5); border-radius: 5px; cursor: pointer; font-size: 12px; display: inline-flex; align-items: center; gap: 6px;">
            <svg fill="currentColor" width="14" height="14" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
              <path
                d="M19.146 4.854l-1.489 1.489A8 8 0 1 0 12 20a8.094 8.094 0 0 0 7.371-4.886 1 1 0 1 0-1.842-.779A6.071 6.071 0 0 1 12 18a6 6 0 1 1 4.243-10.243l-1.39 1.39a.5.5 0 0 0 .354.854H19.5A.5.5 0 0 0 20 9.5V5.207a.5.5 0 0 0-.854-.353z" />
            </svg>
            <span>æ£€æŸ¥æ›´æ–°</span>
          </button>
        </p>
        <div id="update-notification"
          style="display: none; margin: 15px auto; padding: 15px; max-width: 600px; background: rgba(16, 185, 129, 0.9); border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.3);">
          <p style="margin: 0 0 10px 0; font-weight: 600; font-size: 16px;">ğŸ‰ å‘ç°æ–°ç‰ˆæœ¬ï¼</p>
          <p id="update-message" style="margin: 0 0 10px 0; font-size: 14px;"></p>
          <div style="display: flex; gap: 10px; margin-top: 10px;">
            <button id="auto-update-btn" onclick="autoInstallUpdate()"
              style="flex: 1; padding: 8px 20px; background: white; color: #667eea; border: none; border-radius: 5px; font-weight: 600; cursor: pointer;">
              ğŸš€ è‡ªåŠ¨æ›´æ–°
            </button>
            <a id="update-link" href="#" target="_blank"
              style="flex: 1; padding: 8px 20px; background: rgba(255,255,255,0.3); color: white; text-decoration: none; border-radius: 5px; font-weight: 600; text-align: center;">
              ğŸ“¥ æ‰‹åŠ¨ä¸‹è½½
            </a>
          </div>
          <p id="update-progress"
            style="margin: 10px 0 0 0; font-size: 12px; color: rgba(255,255,255,0.9); display: none;"></p>
        </div>
        <p>
          <a href="https://github.com/Detteee/bilistream" target="_blank"
            style="color: white; text-decoration: none; border-bottom: 1px solid rgba(255,255,255,0.5); padding-bottom: 2px;">
            â­ GitHub
          </a>
          <span style="margin: 0 10px;">|</span>
          <a href="https://github.com/Detteee/bilistream/issues" target="_blank"
            style="color: white; text-decoration: none; border-bottom: 1px solid rgba(255,255,255,0.5); padding-bottom: 2px;">
            ğŸ› æŠ¥å‘Šé—®é¢˜
          </a>
        </p>
      </div>
    </div>

    <!-- Area Selection Modal -->
    <div id="area-modal"
      style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; align-items: center; justify-content: center;">
      <div
        style="background: white; border-radius: 12px; padding: 30px; max-width: 500px; width: 90%; box-shadow: 0 20px 60px rgba(0,0,0,0.3);">
        <h3 style="color: #667eea; margin-bottom: 20px;">é€‰æ‹©åˆ†åŒº</h3>
        <p style="color: #666; margin-bottom: 20px;">æœªèƒ½è‡ªåŠ¨æ£€æµ‹åˆ†åŒºï¼Œè¯·æ‰‹åŠ¨é€‰æ‹©ï¼š</p>
        <select id="modal-area-select"
          style="width: 100%; padding: 12px; border: 2px solid #e5e7eb; border-radius: 8px; font-size: 14px; margin-bottom: 20px;">
          <option value="">åŠ è½½ä¸­...</option>
        </select>
        <div style="display: flex; gap: 10px;">
          <button onclick="confirmAreaSelection()"
            style="flex: 1; padding: 12px; background: #667eea; color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer;">
            ç¡®è®¤
          </button>
          <button onclick="closeAreaModal()"
            style="flex: 1; padding: 12px; background: #6b7280; color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer;">
            å–æ¶ˆ
          </button>
        </div>
      </div>
    </div>

    <script>
      // Global data
      let channelsData = null;
      let areasData = null;
      let logLines = [];
      let maxLogLines = 500;
      let statusRefreshInterval = 60000; // Default 60 seconds
      let statusIntervalId = null;

      // Global config data for access across functions
      window.configData = {
        enable_lol_monitor: false,
        riot_api_key: ''
      };

      // Auto refresh logs every 2 seconds
      setInterval(refreshLogs, 2000);

      // Load config and set up status refresh interval
      async function initStatusRefresh() {
        try {
          const response = await fetch('/api/config');
          if (response.ok) {
            const config = await response.json();

            // Store config globally
            window.configData = {
              enable_lol_monitor: config.enable_lol_monitor || false,
              riot_api_key: config.riot_api_key || '',
              holodex_api_key: config.holodex_api_key || ''
            };

            // Show/hide Holodex sections based on API key configuration
            const holodexSection = document.getElementById('holodex-section');
            const holodexApiConfig = document.getElementById('holodex-api-config');
            const holodexStreamsSection = document.getElementById('holodex-streams-section');

            // Always show the Holodex section
            holodexSection.style.display = 'block';

            if (config.holodex_api_key && config.holodex_api_key.trim() !== '') {
              // API key is configured - show streams section, hide config
              holodexApiConfig.style.display = 'none';
              holodexStreamsSection.style.display = 'block';
            } else {
              // No API key - show config section, hide streams
              holodexApiConfig.style.display = 'block';
              holodexStreamsSection.style.display = 'none';
            }

            if (config.interval) {
              statusRefreshInterval = config.interval * 1000; // Convert to milliseconds
              console.log('Status refresh interval set to', config.interval, 'seconds');
            }

            console.log('LOL Monitor enabled:', window.configData.enable_lol_monitor);
            console.log('Holodex API configured:', !!config.holodex_api_key);
          }
        } catch (error) {
          console.log('Failed to load config, using default interval:', error);
        }

        // Start status refresh with configured interval
        if (statusIntervalId) {
          clearInterval(statusIntervalId);
        }
        statusIntervalId = setInterval(refreshStatus, statusRefreshInterval);

        // Initial refresh
        refreshStatus();

        // Load monitor toggle states
        loadMonitorToggleStates();
      }

      function toggleChannelManagement() {
        const container = document.getElementById('channel-management-container');
        const toggle = document.getElementById('channel-toggle');
        if (container.style.display === 'none') {
          container.style.display = 'block';
          toggle.textContent = 'â–²';
        } else {
          container.style.display = 'none';
          toggle.textContent = 'â–¼';
        }
      }

      function toggleHolodex() {
        const container = document.getElementById('holodex-container');
        const toggle = document.getElementById('holodex-toggle');
        if (container.style.display === 'none') {
          container.style.display = 'block';
          toggle.textContent = 'â–²';
          refreshHolodexStreams();
        } else {
          container.style.display = 'none';
          toggle.textContent = 'â–¼';
        }
      }

      async function refreshHolodexStreams() {
        // Start continuous spinning animation
        const icon = document.getElementById('refreshHolodexIcon');
        if (icon) {
          icon.style.animation = 'spin 1s linear infinite';
        }

        const statusDiv = document.getElementById('holodex-status');
        const streamsDiv = document.getElementById('holodex-streams');

        statusDiv.innerHTML = 'â³ åŠ è½½ä¸­...';
        statusDiv.style.background = '#89b4fa';
        statusDiv.style.color = '#1e1e2e';
        streamsDiv.innerHTML = '';

        try {
          const response = await fetch('/api/holodex/streams');
          const data = await response.json();

          if (!data.success) {
            statusDiv.innerHTML = `âš ï¸ ${data.message}`;
            statusDiv.style.background = '#f9e2af';
            statusDiv.style.color = '#1e1e2e';
            return;
          }

          const streams = data.data || [];

          if (streams.length === 0) {
            statusDiv.innerHTML = 'âœ… å·²è¿æ¥ Holodex API - å½“å‰æ— ç›´æ’­æˆ–é¢„å‘Š';
            statusDiv.style.background = '#a6e3a1';
            statusDiv.style.color = '#1e1e2e';
            return;
          }

          // Separate live and scheduled streams
          const liveStreams = streams.filter(s => s.status === 'live');
          const scheduledStreams = streams.filter(s => s.status !== 'live');

          // Sort scheduled streams by time - nearest first
          scheduledStreams.sort((a, b) => {
            const timeA = a.start_scheduled ? new Date(a.start_scheduled).getTime() : Infinity;
            const timeB = b.start_scheduled ? new Date(b.start_scheduled).getTime() : Infinity;
            return timeA - timeB;
          });

          statusDiv.innerHTML = `âœ… æ‰¾åˆ° ${liveStreams.length} ä¸ªç›´æ’­, ${scheduledStreams.length} ä¸ªé¢„å‘Š`;
          statusDiv.style.background = '#a6e3a1';
          statusDiv.style.color = '#1e1e2e';

          // Render live streams first
          liveStreams.forEach(stream => {
            streamsDiv.appendChild(createStreamCard(stream, true));
          });

          // Add divider if both live and scheduled exist
          if (liveStreams.length > 0 && scheduledStreams.length > 0) {
            const divider = document.createElement('div');
            divider.style.cssText = 'grid-column: 1 / -1; height: 2px; background: linear-gradient(to right, transparent, var(--heading-color), transparent); margin: 10px 0; position: relative;';
            divider.innerHTML = '<span style="position: absolute; top: -10px; left: 50%; transform: translateX(-50%); background: var(--card-bg); padding: 0 15px; color: var(--heading-color); font-size: 12px; font-weight: 600;">é¢„å‘Š</span>';
            streamsDiv.appendChild(divider);
          }

          // Render scheduled streams (now sorted by time)
          scheduledStreams.forEach(stream => {
            streamsDiv.appendChild(createStreamCard(stream, false));
          });

        } catch (error) {
          statusDiv.innerHTML = `âŒ è¯·æ±‚å¤±è´¥: ${error.message}`;
          statusDiv.style.background = '#f38ba8';
          statusDiv.style.color = '#1e1e2e';
        } finally {
          // Stop spinning animation when complete
          if (icon) {
            icon.style.animation = '';
          }
        }
      }

      function createStreamCard(stream, isLive) {
        const streamCard = document.createElement('div');
        streamCard.style.cssText = 'background: var(--card-bg); border: 2px solid var(--card-border); border-radius: 8px; padding: 15px; transition: all 0.2s; min-width: 0; overflow: hidden;';
        streamCard.onmouseenter = () => {
          streamCard.style.transform = 'translateY(-2px)';
          streamCard.style.boxShadow = '0 4px 12px var(--shadow-hover)';
        };
        streamCard.onmouseleave = () => {
          streamCard.style.transform = 'translateY(0)';
          streamCard.style.boxShadow = 'none';
        };

        const statusBadge = isLive
          ? '<span style="background: #f38ba8; color: #1e1e2e; padding: 3px 8px; border-radius: 4px; font-size: 12px; font-weight: 600;">ğŸ”´ ç›´æ’­ä¸­</span>'
          : '<span style="background: #89b4fa; color: #1e1e2e; padding: 3px 8px; border-radius: 4px; font-size: 12px; font-weight: 600;">ğŸ“… é¢„å‘Š</span>';

        const viewers = stream.live_viewers ? `${stream.live_viewers.toLocaleString()} è§‚çœ‹` : '';
        const scheduledTime = stream.start_scheduled ? new Date(stream.start_scheduled).toLocaleString('zh-CN') : '';
        const actualTime = stream.start_actual ? new Date(stream.start_actual).toLocaleString('zh-CN') : '';

        let areaInfo = '';
        if (stream.suggested_area_id && stream.suggested_area_name) {
          areaInfo = `<p style="color: #a6e3a1; font-size: 12px; margin: 5px 0;">ğŸ¯ å»ºè®®åˆ†åŒº: ${stream.suggested_area_name}</p>`;
        }

        streamCard.innerHTML = `
          <div style="margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center;">
            <div>
              ${statusBadge}
              ${viewers ? `<span style="margin-left: 10px; color: var(--text-secondary); font-size: 14px;">${viewers}</span>` : ''}
            </div>
          </div>
          ${stream.channel_name ? `<p style="color: var(--text-muted); font-size: 12px; margin: 5px 0; font-weight: 500; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">ğŸ‘¤ ${stream.channel_name}</p>` : ''}
          <h4 style="margin: 10px 0; color: var(--text-primary); font-size: 14px; line-height: 1.4; font-weight: 600; word-wrap: break-word; overflow-wrap: break-word;">${stream.title}</h4>
          ${stream.topic_id ? `<p style="color: var(--heading-color); font-size: 12px; margin: 5px 0;">ğŸ® ${stream.topic_id}</p>` : ''}
          ${areaInfo}
          ${isLive && actualTime ? `<p style="color: var(--text-secondary); font-size: 12px; margin: 5px 0;">â° å¼€å§‹: ${actualTime}</p>` : ''}
          ${!isLive && scheduledTime ? `<p style="color: var(--text-secondary); font-size: 12px; margin: 5px 0;">â° é¢„å®š: ${scheduledTime}</p>` : ''}
          <div style="margin-top: 12px; display: flex; gap: 8px;">
            <a href="https://www.youtube.com/watch?v=${stream.id}" target="_blank" 
               style="flex: 1; padding: 6px 12px; background: linear-gradient(135deg, #89b4fa 0%, #cba6f7 100%); color: #1e1e2e; text-decoration: none; border-radius: 4px; font-size: 12px; text-align: center; font-weight: 600;">
              ğŸ“º è§‚çœ‹
            </a>
            <button class="switch-button" 
               data-channel-id="${stream.channel_id}" 
               data-suggested-area-id="${stream.suggested_area_id || ''}" 
               data-title="${stream.title}" 
               data-topic-id="${stream.topic_id || ''}" 
               data-status="${stream.status || ''}"
               style="flex: 1; padding: 6px 12px; background: #a6e3a1; color: #1e1e2e; border: none; border-radius: 4px; font-size: 12px; cursor: pointer; font-weight: 600; display: flex; align-items: center; justify-content: center; gap: 4px;">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 12c0 6-4.39 10-9.806 10C7.792 22 4.24 19.665 3 16m-1-4C2 6 6.39 2 11.807 2C16.208 2 19.758 4.335 21 8"/><path d="m7 17l-4-1l-1 4M17 7l4 1l1-4"/></svg>
              <span>åˆ‡æ¢</span>
            </button>
          </div>
        `;

        return streamCard;
      }

      // Store pending switch data
      let pendingSwitchData = null;

      async function switchToHolodexStream(channelId, suggestedAreaId, title, topicId, status) {
        if (!suggestedAreaId) {
          // Show modal for area selection
          pendingSwitchData = { channelId, areaId: null, title, topicId, status };
          await showAreaModal();
        } else {
          // Direct switch with suggested area
          await performSwitch(channelId, suggestedAreaId, title, topicId, status);
        }
      }

      async function showAreaModal() {
        const modal = document.getElementById('area-modal');
        const select = document.getElementById('modal-area-select');

        // Load areas if not already loaded
        if (!areasData) {
          try {
            const response = await fetch('/api/areas');
            const data = await response.json();
            areasData = data;
          } catch (error) {
            showNotification('åŠ è½½åˆ†åŒºåˆ—è¡¨å¤±è´¥', 'error');
            return;
          }
        }

        // Populate select
        select.innerHTML = '<option value="">é€‰æ‹©åˆ†åŒº...</option>';
        if (areasData && areasData.areas) {
          areasData.areas.forEach(area => {
            const option = document.createElement('option');
            option.value = area.id;
            option.textContent = `${area.name} (${area.id})`;
            select.appendChild(option);
          });
        }

        modal.style.display = 'flex';
      }

      function closeAreaModal() {
        document.getElementById('area-modal').style.display = 'none';
        pendingSwitchData = null;
      }

      async function confirmAreaSelection() {
        const select = document.getElementById('modal-area-select');
        const areaId = parseInt(select.value);

        if (!areaId) {
          showNotification('è¯·é€‰æ‹©åˆ†åŒº', 'error');
          return;
        }

        if (!pendingSwitchData) {
          console.error('No pending switch data');
          closeAreaModal();
          return;
        }

        const channelId = pendingSwitchData.channelId;
        const { title, topicId, status } = pendingSwitchData;
        closeAreaModal();
        await performSwitch(channelId, areaId, title, topicId, status);
      }

      async function performSwitch(channelId, areaId, title, topicId, status) {
        try {
          console.log('Switching to channel:', channelId, 'area:', areaId, 'status:', status);
          const response = await fetch('/api/holodex/switch', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              channel_id: channelId,
              area_id: areaId,
              title: title || null,
              topic_id: topicId || null,
              status: status || null
            })
          });

          console.log('Response status:', response.status);
          const data = await response.json();
          console.log('Response data:', data);

          if (data.success) {
            showNotification(data.message || 'é¢‘é“åˆ‡æ¢æˆåŠŸï¼', 'success');
            // Refresh status immediately to show updated info
            refreshStatus();
          } else {
            showNotification(data.message || 'åˆ‡æ¢å¤±è´¥', 'error');
            console.error('Switch failed:', data.message);
          }
        } catch (error) {
          showNotification('åˆ‡æ¢å¤±è´¥: ' + error.message, 'error');
          console.error('Switch error:', error);
        }
      }

      // Holodex API Key Management Functions
      async function saveHolodexApiKey() {
        const apiKeyInput = document.getElementById('holodex-api-input');
        const apiKey = apiKeyInput.value.trim();

        if (!apiKey) {
          showNotification('è¯·è¾“å…¥ API Key', 'error');
          return;
        }

        try {
          // Save the API key to config
          const response = await fetch('/api/config', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              holodex_api_key: apiKey
            })
          });

          const data = await response.json();
          if (data.success) {
            showNotification('Holodex API Key ä¿å­˜æˆåŠŸï¼', 'success');
            // Refresh the page to update the UI
            setTimeout(() => window.location.reload(), 1500);
          } else {
            showNotification('ä¿å­˜å¤±è´¥: ' + (data.message || 'æœªçŸ¥é”™è¯¯'), 'error');
          }
        } catch (error) {
          showNotification('ä¿å­˜å¤±è´¥: ' + error.message, 'error');
          console.error('Save API key error:', error);
        }
      }

      function toggleLogs() {
        const container = document.getElementById('log-container');
        const toggle = document.getElementById('log-toggle');
        if (container.style.display === 'none') {
          container.style.display = 'block';
          toggle.textContent = 'â–²';
          refreshLogs();
        } else {
          container.style.display = 'none';
          toggle.textContent = 'â–¼';
        }
      }

      function toggleSystemConfig() {
        const container = document.getElementById('system-config-container');
        const toggle = document.getElementById('system-config-toggle');
        if (container.style.display === 'none') {
          container.style.display = 'block';
          toggle.textContent = 'â–²';
          loadSystemConfig();
        } else {
          container.style.display = 'none';
          toggle.textContent = 'â–¼';
        }
      }

      function toggleConfigRiotApiKey() {
        const checkbox = document.getElementById('config-lol-monitor-checkbox');
        const riotGroup = document.getElementById('config-riot-api-group');
        const intervalGroup = document.getElementById('config-lol-interval-group');

        if (checkbox.checked) {
          riotGroup.style.display = 'block';
          intervalGroup.style.display = 'block';
        } else {
          riotGroup.style.display = 'none';
          intervalGroup.style.display = 'none';
        }
      }

      function toggleAntiCollisionList() {
        const checkbox = document.getElementById('config-anti-collision-checkbox');
        const section = document.getElementById('anti-collision-section');

        if (checkbox.checked) {
          section.style.display = 'block';
        } else {
          section.style.display = 'none';
        }
      }

      async function loadSystemConfig() {
        try {
          const response = await fetch('/api/config');
          const config = await response.json();

          // Load basic settings
          document.getElementById('config-interval').value = config.interval || 30;
          document.getElementById('config-auto-cover-checkbox').checked = config.auto_cover || false;
          document.getElementById('config-danmaku-command-checkbox').checked = config.bilibili?.enable_danmaku_command !== false;
          document.getElementById('config-anti-collision-checkbox').checked = config.enable_anti_collision || false;
          toggleAntiCollisionList(); // Show/hide anti-collision section based on checkbox

          // Load API keys
          document.getElementById('config-holodex-key').value = config.holodex_api_key || '';
          document.getElementById('config-riot-key').value = config.riot_api_key || '';

          // Load LoL monitor settings
          const lolMonitorEnabled = config.enable_lol_monitor || false;
          document.getElementById('config-lol-monitor-checkbox').checked = lolMonitorEnabled;
          document.getElementById('config-lol-interval').value = config.lol_monitor_interval || 1;
          toggleConfigRiotApiKey(); // Show/hide riot API fields based on checkbox

          // Load Twitch settings
          document.getElementById('config-tw-oauth').value = (config.twitch && config.twitch.oauth_token) || '';
          document.getElementById('config-tw-region').value = (config.twitch && config.twitch.proxy_region) || 'asl';

          // Load proxy
          document.getElementById('config-proxy').value = config.proxy || '';

          // Load anti-collision list
          window.currentAntiCollisionList = config.anti_collision_list || {};
          loadAntiCollisionList(window.currentAntiCollisionList);

          // Load banned keywords
          await loadBannedKeywords();

          // Load monitor toggle states
          await loadMonitorToggleStates();

        } catch (error) {
          console.error('Failed to load system config:', error);
          showNotification('åŠ è½½é…ç½®å¤±è´¥', 'error');
        }
      }

      async function loadMonitorToggleStates() {
        try {
          const response = await fetch('/api/config');
          const config = await response.json();

          // Set toggle states
          document.getElementById('youtube-monitor-toggle').checked = config.youtube?.enable_monitor !== false;
          document.getElementById('twitch-monitor-toggle').checked = config.twitch?.enable_monitor !== false;
        } catch (error) {
          console.error('Failed to load monitor toggle states:', error);
        }
      }

      async function loadBannedKeywords() {
        try {
          const response = await fetch('/api/banned-keywords');
          const data = await response.json();

          document.getElementById('streaming-banned-keywords').value =
            (data.streaming_banned_keywords || []).join('\n');
          document.getElementById('danmaku-banned-keywords').value =
            (data.danmaku_banned_keywords || []).join('\n');
        } catch (error) {
          console.error('Failed to load banned keywords:', error);
        }
      }

      // Danmaku Command Toggle Functions
      async function loadDanmakuCommandState() {
        try {
          const response = await fetch('/api/config');
          const config = await response.json();

          const toggle = document.getElementById('bili-danmaku-command-toggle');
          if (toggle) {
            toggle.checked = config.bilibili?.enable_danmaku_command !== false;
          }
        } catch (error) {
          console.error('Failed to load danmaku command state:', error);
        }
      }

      async function toggleDanmakuCommand() {
        const toggle = document.getElementById('bili-danmaku-command-toggle');
        const enabled = toggle.checked;

        try {
          const response = await fetch('/api/config', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              enable_danmaku_command: enabled
            })
          });

          const result = await response.json();
          if (result.success) {
            showNotification(enabled ? 'å¼¹å¹•æŒ‡ä»¤å·²å¯ç”¨' : 'å¼¹å¹•æŒ‡ä»¤å·²ç¦ç”¨', 'success');
          } else {
            // Revert toggle if save failed
            toggle.checked = !enabled;
            showNotification(result.message || 'ä¿å­˜å¤±è´¥', 'error');
          }
        } catch (error) {
          console.error('Failed to toggle danmaku command:', error);
          // Revert toggle if save failed
          toggle.checked = !enabled;
          showNotification('ä¿å­˜å¤±è´¥: ' + error.message, 'error');
        }
      }

      function loadAntiCollisionList(list) {
        const container = document.getElementById('anti-collision-list');
        if (Object.keys(list).length === 0) {
          container.innerHTML = '<div style="color: var(--text-secondary); text-align: center; padding: 20px;">æš‚æ— é˜²æ’è½¦åå•</div>';
          return;
        }

        const html = `
          <table style="width: 100%; border-collapse: collapse;">
            <thead>
              <tr style="border-bottom: 2px solid var(--card-border);">
                <th style="text-align: left; padding: 12px 8px; color: var(--text-primary); font-weight: 600;">ç”¨æˆ·å</th>
                <th style="text-align: left; padding: 12px 8px; color: var(--text-primary); font-weight: 600;">æˆ¿é—´å·</th>
                <th style="text-align: center; padding: 12px 8px; color: var(--text-primary); font-weight: 600; width: 60px;">æ“ä½œ</th>
              </tr>
            </thead>
            <tbody>
              ${Object.entries(list).map(([username, roomId]) => `
                <tr style="border-bottom: 1px solid var(--card-border);">
                  <td style="padding: 12px 8px; color: var(--text-primary); font-weight: 500;">${username}</td>
                  <td style="padding: 12px 8px; color: var(--text-secondary);">${roomId}</td>
                  <td style="padding: 12px 8px; text-align: center;">
                    <button onclick="removeAntiCollisionEntry('${username}')" title="åˆ é™¤"
                      style="background: none; border: none; color: #F38BA8; cursor: pointer; padding: 4px; border-radius: 4px; display: flex; align-items: center; transition: background 0.2s; margin: 0 auto;"
                      onmouseover="this.style.background='var(--button-hover-bg)'" onmouseout="this.style.background='none'">
                      <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="3,6 5,6 21,6"></polyline>
                        <path d="m19,6v14a2,2 0 0,1 -2,2H7a2,2 0 0,1 -2,-2V6m3,0V4a2,2 0 0,1 2,-2h4a2,2 0 0,1 2,2v2"></path>
                        <line x1="10" y1="11" x2="10" y2="17"></line>
                        <line x1="14" y1="11" x2="14" y2="17"></line>
                      </svg>
                    </button>
                  </td>
                </tr>
              `).join('')}
            </tbody>
          </table>
        `;

        container.innerHTML = html;
      }

      function addAntiCollisionEntry() {
        const username = document.getElementById('anti-collision-username').value.trim();
        const roomId = parseInt(document.getElementById('anti-collision-roomid').value);

        if (!username || !roomId || isNaN(roomId)) {
          showNotification('è¯·å¡«å†™ç”¨æˆ·åå’Œæœ‰æ•ˆçš„æˆ¿é—´å·', 'error');
          return;
        }

        // Add to global anti-collision list
        if (!window.currentAntiCollisionList) {
          window.currentAntiCollisionList = {};
        }
        window.currentAntiCollisionList[username] = roomId;

        loadAntiCollisionList(window.currentAntiCollisionList);

        // Clear inputs
        document.getElementById('anti-collision-username').value = '';
        document.getElementById('anti-collision-roomid').value = '';

        showNotification('å·²æ·»åŠ åˆ°é˜²æ’è½¦åå•', 'success');
      }

      function removeAntiCollisionEntry(username) {
        if (window.currentAntiCollisionList && window.currentAntiCollisionList[username]) {
          delete window.currentAntiCollisionList[username];
          loadAntiCollisionList(window.currentAntiCollisionList);
          showNotification('å·²ä»é˜²æ’è½¦åå•ç§»é™¤', 'success');
        }
      }

      function getCurrentConfig() {
        return {
          interval: parseInt(document.getElementById('config-interval').value) || 30,
          auto_cover: document.getElementById('config-auto-cover-checkbox').checked,
          enable_danmaku_command: document.getElementById('config-danmaku-command-checkbox').checked,
          enable_anti_collision: document.getElementById('config-anti-collision-checkbox').checked,
          holodex_api_key: document.getElementById('config-holodex-key').value.trim(),
          riot_api_key: document.getElementById('config-riot-key').value.trim(),
          enable_lol_monitor: document.getElementById('config-lol-monitor-checkbox').checked,
          lol_monitor_interval: parseInt(document.getElementById('config-lol-interval').value) || 1,
          proxy: document.getElementById('config-proxy').value.trim() || null,
          twitch_oauth_token: document.getElementById('config-tw-oauth').value.trim(),
          twitch_proxy_region: document.getElementById('config-tw-region').value,
          anti_collision_list: window.currentAntiCollisionList || {}
        };
      }

      async function saveSystemConfig() {
        try {
          const config = getCurrentConfig();

          const response = await fetch('/api/config', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(config)
          });

          const result = await response.json();

          if (result.success) {
            // Save banned keywords separately
            await saveBannedKeywords();
            showNotification('é…ç½®ä¿å­˜æˆåŠŸ', 'success');
          } else {
            showNotification('é…ç½®ä¿å­˜å¤±è´¥: ' + (result.error || 'æœªçŸ¥é”™è¯¯'), 'error');
          }
        } catch (error) {
          console.error('Failed to save system config:', error);
          showNotification('é…ç½®ä¿å­˜å¤±è´¥', 'error');
        }
      }

      async function saveBannedKeywords() {
        try {
          const streamingKeywords = document.getElementById('streaming-banned-keywords').value
            .split('\n')
            .map(k => k.trim())
            .filter(k => k.length > 0);

          const danmakuKeywords = document.getElementById('danmaku-banned-keywords').value
            .split('\n')
            .map(k => k.trim())
            .filter(k => k.length > 0);

          const response = await fetch('/api/banned-keywords', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              streaming_banned_keywords: streamingKeywords,
              danmaku_banned_keywords: danmakuKeywords
            })
          });

          const result = await response.json();
          if (!result.success) {
            console.error('Failed to save banned keywords:', result.message);
          }
        } catch (error) {
          console.error('Failed to save banned keywords:', error);
        }
      }

      function toggleManagement() {
        const container = document.getElementById('management-container');
        const toggle = document.getElementById('management-toggle');
        if (container.style.display === 'none') {
          container.style.display = 'block';
          toggle.textContent = 'â–²';
          // Don't auto-load since subsections are collapsed by default
        } else {
          container.style.display = 'none';
          toggle.textContent = 'â–¼';
        }
      }

      function toggleAreaManagement() {
        const container = document.getElementById('area-management-content');
        const toggle = document.getElementById('area-management-toggle');
        if (container.style.display === 'none') {
          container.style.display = 'block';
          toggle.textContent = 'â–²';
        } else {
          container.style.display = 'none';
          toggle.textContent = 'â–¼';
        }
      }

      function toggleChannelConfig() {
        const container = document.getElementById('channel-management-content');
        const toggle = document.getElementById('channel-management-toggle');
        if (container.style.display === 'none') {
          container.style.display = 'block';
          toggle.textContent = 'â–²';
        } else {
          container.style.display = 'none';
          toggle.textContent = 'â–¼';
        }
      }

      function toggleAreasList() {
        const container = document.getElementById('areas-content');
        const toggle = document.getElementById('areas-list-toggle');
        const refreshBtn = document.getElementById('refreshAreasBtn');
        if (container.style.display === 'none') {
          container.style.display = 'block';
          toggle.textContent = 'â–²';
          refreshBtn.style.display = 'flex';
          if (container.innerHTML === 'åŠ è½½ä¸­...') {
            loadAreas();
          }
        } else {
          container.style.display = 'none';
          toggle.textContent = 'â–¼';
          refreshBtn.style.display = 'none';
        }
      }

      function toggleChannelsList() {
        const container = document.getElementById('channels-content');
        const toggle = document.getElementById('channels-list-toggle');
        const refreshBtn = document.getElementById('refreshChannelsBtn');
        if (container.style.display === 'none') {
          container.style.display = 'block';
          toggle.textContent = 'â–²';
          refreshBtn.style.display = 'flex';
          if (container.innerHTML === 'åŠ è½½ä¸­...') {
            loadChannels();
          }
        } else {
          container.style.display = 'none';
          toggle.textContent = 'â–¼';
          refreshBtn.style.display = 'none';
        }
      }

      // Area management functions
      async function loadAreas() {
        try {
          const response = await fetch('/api/manage/areas');

          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }

          const contentType = response.headers.get('content-type');
          if (!contentType || !contentType.includes('application/json')) {
            const text = await response.text();
            throw new Error(`Expected JSON, got: ${contentType}. Response: ${text}`);
          }

          const result = await response.json();

          if (result.success) {
            const areasContent = document.getElementById('areas-content');
            if (result.data.areas.length === 0) {
              areasContent.innerHTML = '<p style="color: var(--text-secondary);">æš‚æ— åˆ†åŒº</p>';
            } else {
              areasContent.innerHTML = `
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(min(250px, 100%), 1fr)); gap: 12px;">
                  ${result.data.areas.map(area => `
                    <div style="padding: 10px; border: 1px solid var(--card-border); border-radius: 12px; background: var(--card-bg); color: var(--text-primary);">
                      <div style="display: flex; align-items: center; justify-content: space-between;">
                        <div><strong>ID: ${area.id}</strong> - ${area.name}</div>
                        <div style="display: flex; gap: 4px;">
                          <button onclick="editArea(${area.id})" title="ç¼–è¾‘åˆ†åŒº"
                            style="background: none; border: none; color: var(--heading-color); cursor: pointer; padding: 4px; border-radius: 4px; display: flex; align-items: center; transition: background 0.2s;"
                            onmouseover="this.style.background='var(--button-hover-bg)'" onmouseout="this.style.background='none'">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                              <path d="M12 20h9"></path>
                              <path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path>
                            </svg>
                          </button>
                          <button onclick="deleteArea(${area.id})" title="åˆ é™¤åˆ†åŒº"
                            style="background: none; border: none; color: var(--heading-color); cursor: pointer; padding: 4px; border-radius: 4px; display: flex; align-items: center; transition: background 0.2s;"
                            onmouseover="this.style.background='var(--button-hover-bg)'" onmouseout="this.style.background='none'">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                              <polyline points="3,6 5,6 21,6"></polyline>
                              <path d="m19,6v14a2,2 0 0,1 -2,2H7a2,2 0 0,1 -2,-2V6m3,0V4a2,2 0 0,1 2,-2h4a2,2 0 0,1 2,2v2"></path>
                              <line x1="10" y1="11" x2="10" y2="17"></line>
                              <line x1="14" y1="11" x2="14" y2="17"></line>
                            </svg>
                          </button>
                        </div>
                      </div>
                      <hr style="margin: 8px 0; border: none; height: 1px; background: var(--card-border);">
                      <small style="color: var(--text-secondary);">å…³é”®è¯: ${area.title_keywords.join(', ') || 'æ— '}</small>
                      <br><small style="color: var(--text-secondary);">åˆ«å: ${area.aliases.join(', ') || 'æ— '}</small>
                    </div>
                  `).join('')}
                </div>
              `;
            }
          } else {
            document.getElementById('areas-content').innerHTML = `<p style="color: red;">åŠ è½½å¤±è´¥: ${result.message}</p>`;
          }
        } catch (error) {
          console.error('Load areas error:', error);
          document.getElementById('areas-content').innerHTML = `<p style="color: red;">åŠ è½½å¤±è´¥: ${error.message}</p>`;
        }
      }

      async function addArea() {
        const id = parseInt(document.getElementById('area-id').value);
        const name = document.getElementById('area-name').value.trim();
        const keywords = document.getElementById('area-keywords').value.split(',').map(k => k.trim()).filter(k => k);
        const aliases = document.getElementById('area-aliases').value.split(',').map(a => a.trim()).filter(a => a);

        if (!id || !name) {
          alert('è¯·å¡«å†™åˆ†åŒºIDå’Œåç§°');
          return;
        }

        try {
          const response = await fetch('/api/manage/areas', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              id: id,
              name: name,
              title_keywords: keywords,
              aliases: aliases
            })
          });

          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }

          const contentType = response.headers.get('content-type');
          if (!contentType || !contentType.includes('application/json')) {
            const text = await response.text();
            throw new Error(`Expected JSON, got: ${contentType}. Response: ${text}`);
          }

          const result = await response.json();
          if (result.success) {
            alert('åˆ†åŒºæ·»åŠ æˆåŠŸ');
            // Clear form
            document.getElementById('area-id').value = '';
            document.getElementById('area-name').value = '';
            document.getElementById('area-keywords').value = '';
            document.getElementById('area-aliases').value = '';
            loadAreas();
          } else {
            alert(`æ·»åŠ å¤±è´¥: ${result.message}`);
          }
        } catch (error) {
          console.error('Add area error:', error);
          alert(`æ·»åŠ å¤±è´¥: ${error.message}`);
        }
      }

      // Channel management functions
      async function loadChannels() {
        try {
          const response = await fetch('/api/manage/channels');
          const result = await response.json();

          if (result.success) {
            const channelsContent = document.getElementById('channels-content');
            if (result.data.channels.length === 0) {
              channelsContent.innerHTML = '<p style="color: var(--text-secondary);">æš‚æ— é¢‘é“</p>';
            } else {
              channelsContent.innerHTML = `
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(min(250px, 100%), 1fr)); gap: 12px;">
                  ${result.data.channels.map(channel => `
                    <div style="padding: 10px; border: 1px solid var(--card-border); border-radius: 12px; background: var(--card-bg); color: var(--text-primary); word-wrap: break-word; overflow-wrap: break-word;">
                      <div style="display: flex; align-items: center; justify-content: space-between;">
                        <div><strong>${channel.name}</strong></div>
                        <div style="display: flex; gap: 4px;">
                          <button onclick="editChannel('${channel.name}')" title="ç¼–è¾‘é¢‘é“"
                            style="background: none; border: none; color: var(--heading-color); cursor: pointer; padding: 4px; border-radius: 4px; display: flex; align-items: center; transition: background 0.2s;"
                            onmouseover="this.style.background='var(--button-hover-bg)'" onmouseout="this.style.background='none'">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                              <path d="M12 20h9"></path>
                              <path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path>
                            </svg>
                          </button>
                          <button onclick="deleteChannel('${channel.name}')" title="åˆ é™¤é¢‘é“"
                            style="background: none; border: none; color: var(--heading-color); cursor: pointer; padding: 4px; border-radius: 4px; display: flex; align-items: center; transition: background 0.2s;"
                            onmouseover="this.style.background='var(--button-hover-bg)'" onmouseout="this.style.background='none'">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                              <polyline points="3,6 5,6 21,6"></polyline>
                              <path d="m19,6v14a2,2 0 0,1 -2,2H7a2,2 0 0,1 -2,-2V6m3,0V4a2,2 0 0,1 2,-2h4a2,2 0 0,1 2,2v2"></path>
                              <line x1="10" y1="11" x2="10" y2="17"></line>
                              <line x1="14" y1="11" x2="14" y2="17"></line>
                            </svg>
                          </button>
                        </div>
                      </div>
                      <hr style="margin: 8px 0; border: none; height: 1px; background: var(--card-border);">
                      <small style="color: var(--text-secondary);">åˆ«å: ${channel.aliases.join(', ') || 'æ— '}</small>
                      <br><small style="color: var(--text-secondary); word-break: break-all;">YouTube: ${channel.platforms.youtube || 'æ— '}</small>
                      <br><small style="color: var(--text-secondary);">Twitch: ${channel.platforms.twitch || 'æ— '}</small>
                      ${channel.riot_puuid ? `<br><small style="color: var(--text-secondary); word-break: break-all; line-height: 1.3;">Riot PUUID: ${channel.riot_puuid}</small>` : ''}
                    </div>
                  `).join('')}
                </div>
              `;
            }
          } else {
            document.getElementById('channels-content').innerHTML = `<p style="color: red;">åŠ è½½å¤±è´¥: ${result.message}</p>`;
          }
        } catch (error) {
          document.getElementById('channels-content').innerHTML = `<p style="color: red;">åŠ è½½å¤±è´¥: ${error.message}</p>`;
        }
      }

      async function addChannel() {
        const name = document.getElementById('channel-name').value.trim();
        const aliases = document.getElementById('channel-aliases').value.split(',').map(a => a.trim()).filter(a => a);
        const youtube = document.getElementById('channel-youtube').value.trim();
        const twitch = document.getElementById('channel-twitch').value.trim();
        const riot = document.getElementById('channel-riot').value.trim();

        if (!name) {
          alert('è¯·å¡«å†™é¢‘é“åç§°');
          return;
        }

        const platforms = {};
        if (youtube) platforms.youtube = youtube;
        if (twitch) platforms.twitch = twitch;

        // Validate that at least one platform is provided
        if (Object.keys(platforms).length === 0) {
          alert('è¯·è‡³å°‘å¡«å†™ä¸€ä¸ªå¹³å°çš„é¢‘é“IDï¼ˆYouTubeæˆ–Twitchï¼‰');
          return;
        }

        try {
          const response = await fetch('/api/manage/channels', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              name: name,
              aliases: aliases,
              platforms: platforms,
              riot_puuid: riot || null
            })
          });

          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }

          const contentType = response.headers.get('content-type');
          if (!contentType || !contentType.includes('application/json')) {
            const text = await response.text();
            throw new Error(`Expected JSON, got: ${contentType}. Response: ${text}`);
          }

          const result = await response.json();
          if (result.success) {
            alert('é¢‘é“æ·»åŠ æˆåŠŸ');
            clearChannelForm();
            loadChannels();
          } else {
            alert(`æ·»åŠ å¤±è´¥: ${result.message}`);
          }
        } catch (error) {
          console.error('Add channel error:', error);
          alert(`æ·»åŠ å¤±è´¥: ${error.message}`);
        }
      }

      async function updateChannel() {
        const name = document.getElementById('channel-name').value.trim();
        const aliases = document.getElementById('channel-aliases').value.split(',').map(a => a.trim()).filter(a => a);
        const youtube = document.getElementById('channel-youtube').value.trim();
        const twitch = document.getElementById('channel-twitch').value.trim();
        const riot = document.getElementById('channel-riot').value.trim();

        if (!name) {
          alert('è¯·å¡«å†™é¢‘é“åç§°');
          return;
        }

        const platforms = {};
        if (youtube) platforms.youtube = youtube;
        if (twitch) platforms.twitch = twitch;

        // Validate that at least one platform is provided
        if (Object.keys(platforms).length === 0) {
          alert('è¯·è‡³å°‘å¡«å†™ä¸€ä¸ªå¹³å°çš„é¢‘é“IDï¼ˆYouTubeæˆ–Twitchï¼‰');
          return;
        }

        try {
          const response = await fetch('/api/manage/channels', {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              name: name,
              aliases: aliases,
              platforms: platforms,
              riot_puuid: riot || null
            })
          });

          const result = await response.json();
          if (result.success) {
            alert('é¢‘é“æ›´æ–°æˆåŠŸ');
            clearChannelForm();
            loadChannels();
          } else {
            alert(`æ›´æ–°å¤±è´¥: ${result.message}`);
          }
        } catch (error) {
          alert(`æ›´æ–°å¤±è´¥: ${error.message}`);
        }
      }

      function editChannel(channelName) {
        // Load channel data into form for editing
        fetch('/api/manage/channels')
          .then(response => response.json())
          .then(result => {
            if (result.success) {
              const channel = result.data.channels.find(c => c.name === channelName);
              if (channel) {
                document.getElementById('channel-name').value = channel.name;
                document.getElementById('channel-aliases').value = channel.aliases.join(', ');
                document.getElementById('channel-youtube').value = channel.platforms.youtube || '';
                document.getElementById('channel-twitch').value = channel.platforms.twitch || '';
                document.getElementById('channel-riot').value = channel.riot_puuid || '';

                // Change form to edit mode
                document.getElementById('channel-form-title').textContent = 'ç¼–è¾‘é¢‘é“';
                document.getElementById('channel-submit-btn').textContent = 'æ›´æ–°é¢‘é“';
                document.getElementById('channel-submit-btn').onclick = () => updateChannel();

                // Scroll to form
                document.getElementById('channel-name').scrollIntoView({ behavior: 'smooth' });
              }
            }
          });
      }

      function clearChannelForm() {
        document.getElementById('channel-name').value = '';
        document.getElementById('channel-aliases').value = '';
        document.getElementById('channel-youtube').value = '';
        document.getElementById('channel-twitch').value = '';
        document.getElementById('channel-riot').value = '';

        // Reset form to add mode
        document.getElementById('channel-form-title').textContent = 'æ·»åŠ é¢‘é“';
        document.getElementById('channel-submit-btn').textContent = 'æ·»åŠ é¢‘é“';
        document.getElementById('channel-submit-btn').onclick = addChannel;
      }

      function editArea(areaId) {
        // Load area data into form for editing
        fetch('/api/manage/areas')
          .then(response => response.json())
          .then(result => {
            if (result.success) {
              const area = result.data.areas.find(a => a.id === areaId);
              if (area) {
                document.getElementById('area-id').value = area.id;
                document.getElementById('area-name').value = area.name;
                document.getElementById('area-keywords').value = area.title_keywords.join(', ');
                document.getElementById('area-aliases').value = area.aliases.join(', ');

                // Change form to edit mode
                document.getElementById('area-form-title').textContent = 'ç¼–è¾‘åˆ†åŒº';
                document.getElementById('area-submit-btn').textContent = 'æ›´æ–°åˆ†åŒº';
                document.getElementById('area-submit-btn').onclick = () => updateArea(areaId);

                // Scroll to form
                document.getElementById('area-id').scrollIntoView({ behavior: 'smooth' });
              }
            }
          });
      }

      function clearAreaForm() {
        document.getElementById('area-id').value = '';
        document.getElementById('area-name').value = '';
        document.getElementById('area-keywords').value = '';
        document.getElementById('area-aliases').value = '';

        // Reset form to add mode
        document.getElementById('area-form-title').textContent = 'æ·»åŠ æ–°åˆ†åŒº';
        document.getElementById('area-submit-btn').textContent = 'æ·»åŠ åˆ†åŒº';
        document.getElementById('area-submit-btn').onclick = addArea;
      }

      async function updateArea(originalId) {
        const id = parseInt(document.getElementById('area-id').value);
        const name = document.getElementById('area-name').value.trim();
        const keywords = document.getElementById('area-keywords').value.split(',').map(k => k.trim()).filter(k => k);
        const aliases = document.getElementById('area-aliases').value.split(',').map(a => a.trim()).filter(a => a);

        if (!id || !name) {
          alert('è¯·å¡«å†™åˆ†åŒºIDå’Œåç§°');
          return;
        }

        try {
          // If ID changed, we need to delete the old one and add the new one
          if (originalId !== id) {
            // Delete old area
            const deleteResponse = await fetch(`/api/manage/areas/${originalId}`, {
              method: 'DELETE'
            });

            if (!deleteResponse.ok) {
              throw new Error(`åˆ é™¤åŸåˆ†åŒºå¤±è´¥: ${deleteResponse.status}`);
            }
          }

          // Add/update area (since there's no PUT endpoint, we use POST)
          const response = await fetch('/api/manage/areas', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              id: id,
              name: name,
              title_keywords: keywords,
              aliases: aliases
            })
          });

          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }

          const contentType = response.headers.get('content-type');
          if (!contentType || !contentType.includes('application/json')) {
            const text = await response.text();
            throw new Error(`Expected JSON, got: ${contentType}. Response: ${text}`);
          }

          const result = await response.json();
          if (result.success) {
            alert('åˆ†åŒºæ›´æ–°æˆåŠŸ');
            clearAreaForm();
            loadAreas();
          } else {
            alert(`æ›´æ–°å¤±è´¥: ${result.message}`);
          }
        } catch (error) {
          console.error('Update area error:', error);
          alert(`æ›´æ–°å¤±è´¥: ${error.message}`);
        }
      }

      // Delete functions
      async function deleteArea(areaId) {
        if (!confirm(`ç¡®å®šè¦åˆ é™¤åˆ†åŒº ID ${areaId} å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚`)) {
          return;
        }

        try {
          const response = await fetch(`/api/manage/areas/${areaId}`, {
            method: 'DELETE'
          });

          const result = await response.json();
          if (result.success) {
            alert('åˆ†åŒºåˆ é™¤æˆåŠŸ');
            loadAreas();
          } else {
            alert(`åˆ é™¤å¤±è´¥: ${result.message}`);
          }
        } catch (error) {
          alert(`åˆ é™¤å¤±è´¥: ${error.message}`);
        }
      }

      async function deleteChannel(channelName) {
        if (!confirm(`ç¡®å®šè¦åˆ é™¤é¢‘é“ "${channelName}" å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚`)) {
          return;
        }

        try {
          const response = await fetch(`/api/manage/channels/${encodeURIComponent(channelName)}`, {
            method: 'DELETE'
          });

          const result = await response.json();
          if (result.success) {
            alert('é¢‘é“åˆ é™¤æˆåŠŸ');
            loadChannels();
          } else {
            alert(`åˆ é™¤å¤±è´¥: ${result.message}`);
          }
        } catch (error) {
          alert(`åˆ é™¤å¤±è´¥: ${error.message}`);
        }
      }

      // Animated refresh functions
      async function refreshAreas() {
        const btn = document.getElementById('refreshAreasBtn');
        const icon = document.getElementById('refreshAreasIcon');

        // Disable button and start spinning animation
        btn.disabled = true;
        btn.style.opacity = '0.7';
        btn.style.cursor = 'not-allowed';
        icon.style.animation = 'spin 1s linear infinite';

        try {
          await loadAreas();
          showNotification('åˆ†åŒºåˆ—è¡¨å·²åˆ·æ–°', 'success');
        } catch (error) {
          console.error('Error refreshing areas:', error);
          showNotification('åˆ·æ–°åˆ†åŒºåˆ—è¡¨å¤±è´¥', 'error');
        } finally {
          // Re-enable button and stop spinning
          btn.disabled = false;
          btn.style.opacity = '1';
          btn.style.cursor = 'pointer';
          icon.style.animation = '';
        }
      }

      async function refreshChannels() {
        const btn = document.getElementById('refreshChannelsBtn');
        const icon = document.getElementById('refreshChannelsIcon');

        // Disable button and start spinning animation
        btn.disabled = true;
        btn.style.opacity = '0.7';
        btn.style.cursor = 'not-allowed';
        icon.style.animation = 'spin 1s linear infinite';

        try {
          await loadChannels();
          showNotification('é¢‘é“åˆ—è¡¨å·²åˆ·æ–°', 'success');
        } catch (error) {
          console.error('Error refreshing channels:', error);
          showNotification('åˆ·æ–°é¢‘é“åˆ—è¡¨å¤±è´¥', 'error');
        } finally {
          // Re-enable button and stop spinning
          btn.disabled = false;
          btn.style.opacity = '1';
          btn.style.cursor = 'pointer';
          icon.style.animation = '';
        }
      }

      function clearLogs() {
        logLines = [];
        document.getElementById('log-output').innerHTML = 'æ—¥å¿—å·²æ¸…ç©º';
      }

      async function refreshLogs() {
        try {
          const response = await fetch('/api/logs');
          if (!response.ok) return;

          const data = await response.json();
          if (data.success && data.logs) {
            // Add new logs
            const newLogs = data.logs.split('\n').filter(line => line.trim());
            newLogs.forEach(line => {
              if (!logLines.includes(line)) {
                logLines.push(line);
              }
            });

            // Keep only last maxLogLines
            if (logLines.length > maxLogLines) {
              logLines = logLines.slice(-maxLogLines);
            }

            // Format and display logs
            const logOutput = document.getElementById('log-output');
            logOutput.innerHTML = logLines.map(line => {
              // Escape HTML to prevent XSS
              const escaped = line
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
              // Don't replace spaces - let white-space: pre handle it

              // Color code log levels
              let coloredLine = escaped;
              if (line.includes('ERROR') || line.includes('âŒ')) {
                coloredLine = `<span style="color: #f87171;">${escaped}</span>`;
              } else if (line.includes('WARN') || line.includes('âš ï¸')) {
                coloredLine = `<span style="color: #fbbf24;">${escaped}</span>`;
              } else if (line.includes('INFO') || line.includes('âœ…') || line.includes('ğŸš€')) {
                coloredLine = `<span style="color: #60a5fa;">${escaped}</span>`;
              } else if (line.includes('DEBUG') || line.includes('ğŸ”„')) {
                coloredLine = `<span style="color: #a78bfa;">${escaped}</span>`;
              }
              return coloredLine;
            }).join('\n');

            // Auto scroll if enabled
            if (document.getElementById('auto-scroll-checkbox').checked) {
              logOutput.parentElement.scrollTop = logOutput.parentElement.scrollHeight;
            }
          }
        } catch (error) {
          // Silently fail - logs are optional
          console.log('Failed to fetch logs:', error);
        }
      }

      function showNotification(message, type = 'success') {
        const notification = document.createElement('div');
        notification.className = `notification ${type}`;
        notification.textContent = message;
        document.body.appendChild(notification);

        setTimeout(() => {
          notification.remove();
        }, 3000);
      }

      async function refreshBilibiliStatus() {
        const btn = document.getElementById('refreshBilibiliBtn');
        const icon = document.getElementById('refreshBilibiliIcon');

        // Disable button and start spinning animation
        btn.disabled = true;
        btn.style.opacity = '0.7';
        btn.style.cursor = 'not-allowed';
        icon.style.animation = 'spin 1s linear infinite';

        try {
          // Bilibili status is always fetched fresh, just refresh the display
          await refreshStatus();
          showNotification('Bilibili status refreshed', 'success');
        } catch (error) {
          console.error('Error refreshing Bilibili status:', error);
          showNotification('Failed to refresh Bilibili status', 'error');
        } finally {
          // Re-enable button and stop spinning
          btn.disabled = false;
          btn.style.opacity = '1';
          btn.style.cursor = 'pointer';
          icon.style.animation = '';
        }
      }

      // YouTube Monitor Toggle
      async function toggleYouTubeMonitor() {
        const toggle = document.getElementById('youtube-monitor-toggle');
        const enabled = toggle.checked;

        try {
          const response = await fetch('/api/toggle-youtube-monitor', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ enabled: enabled })
          });

          const result = await response.json();
          if (result.success) {
            showNotification(result.message, 'success');
            // Refresh status to show updated state
            await refreshStatus();
          } else {
            // Revert toggle if save failed
            toggle.checked = !enabled;
            showNotification(result.message || 'ä¿å­˜å¤±è´¥', 'error');
          }
        } catch (error) {
          console.error('Failed to toggle YouTube monitor:', error);
          // Revert toggle if save failed
          toggle.checked = !enabled;
          showNotification('ä¿å­˜å¤±è´¥: ' + error.message, 'error');
        }
      }

      // Twitch Monitor Toggle
      async function toggleTwitchMonitor() {
        const toggle = document.getElementById('twitch-monitor-toggle');
        const enabled = toggle.checked;

        try {
          const response = await fetch('/api/toggle-twitch-monitor', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ enabled: enabled })
          });

          const result = await response.json();
          if (result.success) {
            showNotification(result.message, 'success');
            // Refresh status to show updated state
            await refreshStatus();
          } else {
            // Revert toggle if save failed
            toggle.checked = !enabled;
            showNotification(result.message || 'ä¿å­˜å¤±è´¥', 'error');
          }
        } catch (error) {
          console.error('Failed to toggle Twitch monitor:', error);
          // Revert toggle if save failed
          toggle.checked = !enabled;
          showNotification('ä¿å­˜å¤±è´¥: ' + error.message, 'error');
        }
      }

      async function refreshYouTubeStatus() {
        const btn = document.getElementById('refreshYouTubeBtn');
        const icon = document.getElementById('refreshYouTubeIcon');

        // Disable button and start spinning animation
        btn.disabled = true;
        btn.style.opacity = '0.7';
        btn.style.cursor = 'not-allowed';
        icon.style.animation = 'spin 1s linear infinite';

        try {
          const response = await fetch('/api/refresh/youtube');
          const data = await response.json();
          if (data.success) {
            showNotification('YouTube status refreshed', 'success');
            // Refresh the main status to show updated data
            await refreshStatus();
          } else {
            showNotification(data.message || 'Failed to refresh YouTube status', 'error');
          }
        } catch (error) {
          console.error('Error refreshing YouTube status:', error);
          showNotification('Failed to refresh YouTube status', 'error');
        } finally {
          // Re-enable button and stop spinning
          btn.disabled = false;
          btn.style.opacity = '1';
          btn.style.cursor = 'pointer';
          icon.style.animation = '';
        }
      }

      async function refreshTwitchStatus() {
        const btn = document.getElementById('refreshTwitchBtn');
        const icon = document.getElementById('refreshTwitchIcon');

        // Disable button and start spinning animation
        btn.disabled = true;
        btn.style.opacity = '0.7';
        btn.style.cursor = 'not-allowed';
        icon.style.animation = 'spin 1s linear infinite';

        try {
          const response = await fetch('/api/refresh/twitch');
          const data = await response.json();
          if (data.success) {
            showNotification('Twitch status refreshed', 'success');
            // Refresh the main status to show updated data
            await refreshStatus();
          } else {
            showNotification(data.message || 'Failed to refresh Twitch status', 'error');
          }
        } catch (error) {
          console.error('Error refreshing Twitch status:', error);
          showNotification('Failed to refresh Twitch status', 'error');
        } finally {
          // Re-enable button and stop spinning
          btn.disabled = false;
          btn.style.opacity = '1';
          btn.style.cursor = 'pointer';
          icon.style.animation = '';
        }
      }

      async function refreshStatus() {
        try {
          const response = await fetch('/api/status');

          if (!response.ok) {
            const errorText = await response.text();
            console.error('API Error:', response.status, errorText);
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }

          const text = await response.text();
          console.log('API Response Text:', text); // Debug log

          if (!text) {
            throw new Error('Empty response from server');
          }

          const data = JSON.parse(text);
          console.log('Parsed Data:', data); // Debug log

          if (!data.success) {
            // API returned an error
            throw new Error(data.message || 'æœåŠ¡å™¨è¿”å›é”™è¯¯');
          }

          if (data.success && data.data) {
            // Update Bilibili status
            const bili = data.data.bilibili;
            document.getElementById('bili-status').className =
              `status-indicator ${bili.is_live ? 'status-live' : 'status-offline'}`;
            document.getElementById('bili-title').textContent = bili.title || '-';
            document.getElementById('bili-area').textContent =
              bili.area_name ? `${bili.area_name} (${bili.area_id})` : (bili.area_id || '-');

            // Update stream quality
            const qualityRow = document.getElementById('bili-stream-quality-row');
            const qualityElement = document.getElementById('bili-stream-quality');
            if (bili.is_live && bili.stream_quality) {
              qualityRow.style.display = '';
              const speedText = bili.stream_speed ? ` (${bili.stream_speed.toFixed(2)}x)` : '';
              qualityElement.textContent = bili.stream_quality + speedText;

              // Set color based on quality
              if (bili.stream_quality === 'æµç•…') {
                qualityElement.style.color = '#10b981'; // green
              } else if (bili.stream_quality === 'æ³¢åŠ¨') {
                qualityElement.style.color = '#f59e0b'; // orange
              } else if (bili.stream_quality === 'å¡é¡¿') {
                qualityElement.style.color = '#ef4444'; // red
              }
            } else {
              qualityRow.style.display = 'none';
            }

            // Load danmaku command state
            loadDanmakuCommandState();

            // Update YouTube status
            if (data.data.youtube) {
              const yt = data.data.youtube;
              document.getElementById('yt-status').className =
                `status-indicator ${yt.is_live ? 'status-live' : 'status-offline'}`;
              document.getElementById('yt-channel-name').textContent = yt.channel_name || '-';
              document.getElementById('yt-title').textContent = yt.title || '-';
              document.getElementById('yt-topic').textContent = yt.topic || '-';
              document.getElementById('yt-area').textContent =
                yt.area_name ? `${yt.area_name} (${yt.area_id})` : (yt.area_id || '-');
              document.getElementById('yt-quality').textContent = yt.quality ? getQualityDisplayText(yt.quality, 'youtube') : '-';
            } else {
              document.getElementById('yt-status').className = 'status-indicator status-offline';
              document.getElementById('yt-channel-name').textContent = '-';
              document.getElementById('yt-title').textContent = '-';
              document.getElementById('yt-topic').textContent = '-';
              document.getElementById('yt-area').textContent = '-';
              document.getElementById('yt-quality').textContent = '-';
            }

            // Update Twitch status
            if (data.data.twitch) {
              const tw = data.data.twitch;
              document.getElementById('tw-status').className =
                `status-indicator ${tw.is_live ? 'status-live' : 'status-offline'}`;
              document.getElementById('tw-channel-name').textContent = tw.channel_name || '-';
              document.getElementById('tw-title').textContent = tw.title || '-';
              document.getElementById('tw-game').textContent = tw.game || '-';
              document.getElementById('tw-area').textContent =
                tw.area_name ? `${tw.area_name} (${tw.area_id})` : (tw.area_id || '-');
              document.getElementById('tw-quality').textContent = tw.quality ? getQualityDisplayText(tw.quality, 'twitch') : '-';
            } else {
              document.getElementById('tw-status').className = 'status-indicator status-offline';
              document.getElementById('tw-channel-name').textContent = '-';
              document.getElementById('tw-title').textContent = '-';
              document.getElementById('tw-game').textContent = '-';
              document.getElementById('tw-area').textContent = '-';
              document.getElementById('tw-quality').textContent = '-';
            }
          } else {
            console.error('Invalid API response:', data);
            showNotification('è·å–çŠ¶æ€å¤±è´¥ï¼šå“åº”æ ¼å¼é”™è¯¯', 'error');
            // Show error state
            document.getElementById('bili-title').textContent = 'æ•°æ®é”™è¯¯';
            document.getElementById('yt-channel-name').textContent = 'æ•°æ®é”™è¯¯';
            document.getElementById('tw-channel-name').textContent = 'æ•°æ®é”™è¯¯';
          }
        } catch (error) {
          console.error('Failed to refresh status:', error);

          // Suppress network errors (when server is down)
          if (error.message && error.message.includes('NetworkError')) {
            console.log('Server appears to be down, suppressing error notification');
            return;
          }

          // Show more helpful error messages for other errors
          let errorMsg = error.message;
          if (errorMsg.includes('æƒé™é”™è¯¯') || errorMsg.includes('Permission denied')) {
            errorMsg = 'é…ç½®æ–‡ä»¶æƒé™é”™è¯¯ï¼è¯·åœ¨å¯æ‰§è¡Œæ–‡ä»¶æ‰€åœ¨ç›®å½•è¿è¡Œç¨‹åºã€‚';
          } else if (errorMsg.includes('ä¸å­˜åœ¨') || errorMsg.includes('No such file')) {
            errorMsg = 'é…ç½®æ–‡ä»¶ä¸å­˜åœ¨ï¼è¯·å…ˆè¿è¡Œ "bilistream setup" åˆ›å»ºé…ç½®ã€‚';
          } else if (errorMsg.includes('Failed to fetch')) {
            // Also suppress generic fetch failures
            console.log('Connection failed, suppressing error notification');
            return;
          }

          showNotification(errorMsg, 'error');

          // Show connection error state
          document.getElementById('bili-title').textContent = 'é…ç½®é”™è¯¯';
          document.getElementById('yt-channel-name').textContent = 'é…ç½®é”™è¯¯';
          document.getElementById('tw-channel-name').textContent = 'é…ç½®é”™è¯¯';
        }
      }

      async function startStream() {
        try {
          const response = await fetch('/api/start', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({})
          });
          const data = await response.json();
          showNotification(data.message || 'ç›´æ’­å·²å¼€å§‹', 'success');
          setTimeout(refreshStatus, 2000);
        } catch (error) {
          showNotification('æ“ä½œå¤±è´¥: ' + error.message, 'error');
        }
      }

      async function stopStream() {
        try {
          const response = await fetch('/api/stop', {
            method: 'POST'
          });
          const data = await response.json();
          showNotification(data.message || 'ç›´æ’­å·²åœæ­¢', 'success');
          setTimeout(refreshStatus, 2000);
        } catch (error) {
          showNotification('æ“ä½œå¤±è´¥: ' + error.message, 'error');
        }
      }

      async function restartStream() {
        if (!confirm('ç¡®å®šè¦åœæ­¢å½“å‰æµå¹¶é‡æ–°åŠ è½½é…ç½®å—ï¼Ÿ')) {
          return;
        }

        const btn = document.getElementById('restartStreamBtn');
        const icon = document.getElementById('restartStreamIcon');

        // Disable button and start spinning animation
        btn.disabled = true;
        btn.style.opacity = '0.7';
        btn.style.cursor = 'not-allowed';
        icon.style.animation = 'spin 1s linear infinite';

        try {
          const response = await fetch('/api/restart', {
            method: 'POST'
          });
          const data = await response.json();
          showNotification(data.message || 'å·²é‡å¯æµ', 'success');
          setTimeout(refreshStatus, 2000);
        } catch (error) {
          showNotification('æ“ä½œå¤±è´¥: ' + error.message, 'error');
        } finally {
          // Re-enable button and stop spinning after a delay
          setTimeout(() => {
            btn.disabled = false;
            btn.style.opacity = '1';
            btn.style.cursor = 'pointer';
            icon.style.animation = '';
          }, 2000);
        }
      }

      async function changeTitle() {
        const title = document.getElementById('title-input').value.trim();
        if (!title) {
          showNotification('è¯·è¾“å…¥ç›´æ’­æ ‡é¢˜', 'error');
          return;
        }

        try {
          const response = await fetch('/api/title', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ title: title })
          });
          const data = await response.json();
          if (data.success) {
            showNotification(data.message || 'ç›´æ’­æ ‡é¢˜å·²æ›´æ–°', 'success');
            document.getElementById('title-input').value = '';
            setTimeout(refreshStatus, 2000);
          } else {
            showNotification(data.message || 'æ›´æ–°å¤±è´¥', 'error');
          }
        } catch (error) {
          showNotification('æ›´æ–°å¤±è´¥: ' + error.message, 'error');
        }
      }

      // Inline title editing functions
      function toggleTitleEdit() {
        const titleSpan = document.getElementById('bili-title');
        const editContainer = document.getElementById('title-edit-container');
        const editInput = document.getElementById('title-edit-input');
        const editButton = titleSpan.parentElement.querySelector('button');

        // Show edit input and hide title span and edit button
        titleSpan.style.display = 'none';
        editButton.style.display = 'none';
        editContainer.style.display = 'flex';

        // Set current title as input value
        editInput.value = titleSpan.textContent === '-' ? '' : titleSpan.textContent;
        editInput.focus();
        editInput.select();

        // Add keyboard event listener
        editInput.onkeydown = function (event) {
          if (event.key === 'Enter') {
            saveTitleEdit();
          } else if (event.key === 'Escape') {
            cancelTitleEdit();
          }
        };
      }

      function cancelTitleEdit() {
        const titleSpan = document.getElementById('bili-title');
        const editContainer = document.getElementById('title-edit-container');
        const editButton = titleSpan.parentElement.querySelector('button');

        // Hide edit input and show title span and edit button
        editContainer.style.display = 'none';
        titleSpan.style.display = 'block';
        editButton.style.display = 'flex';
      }

      // YouTube channel editing functions
      function toggleYtChannelEdit() {
        const channelSpan = document.getElementById('yt-channel-name');
        const editContainer = document.getElementById('yt-channel-edit-container');
        const editSelect = document.getElementById('yt-channel-edit-select');
        const editButton = channelSpan.parentElement.querySelector('button');

        // Show edit dropdown and hide channel span and edit button
        channelSpan.style.display = 'none';
        editButton.style.display = 'none';
        editContainer.style.display = 'flex';

        // Load channels if not already loaded
        if (!channelsData) {
          loadChannelData().then(() => {
            populateYtChannelEditSelect();
          });
        } else {
          populateYtChannelEditSelect();
        }

        editSelect.focus();
      }

      function populateYtChannelEditSelect() {
        const editSelect = document.getElementById('yt-channel-edit-select');
        editSelect.innerHTML = '<option value="">é€‰æ‹©é¢‘é“...</option>';

        if (channelsData && channelsData.channels) {
          channelsData.channels.forEach(channel => {
            if (channel.platforms && channel.platforms.youtube) {
              const option = document.createElement('option');
              option.value = JSON.stringify({
                id: channel.platforms.youtube,
                name: channel.name
              });
              option.textContent = channel.name;
              editSelect.appendChild(option);
            }
          });
        }
      }

      function cancelYtChannelEdit() {
        const channelSpan = document.getElementById('yt-channel-name');
        const editContainer = document.getElementById('yt-channel-edit-container');
        const editButton = channelSpan.parentElement.querySelector('button');

        // Hide edit dropdown and show channel span and edit button
        editContainer.style.display = 'none';
        channelSpan.style.display = 'block';
        editButton.style.display = 'flex';
      }

      async function saveYtChannelEdit() {
        const editSelect = document.getElementById('yt-channel-edit-select');
        const selectedValue = editSelect.value;

        if (!selectedValue) {
          showNotification('è¯·é€‰æ‹©é¢‘é“', 'error');
          return;
        }

        try {
          const channelInfo = JSON.parse(selectedValue);
          const response = await fetch('/api/channel', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              platform: 'youtube',
              channel_id: channelInfo.id,
              channel_name: channelInfo.name
            })
          });
          const data = await response.json();
          showNotification(data.message || 'YouTubeé¢‘é“å·²æ›´æ–°', 'success');
          cancelYtChannelEdit();
          // Refresh status immediately to show updated info
          refreshStatus();
        } catch (error) {
          showNotification('æ›´æ–°å¤±è´¥: ' + error.message, 'error');
        }
      }

      // YouTube area editing functions
      function toggleYtAreaEdit() {
        const areaSpan = document.getElementById('yt-area');
        const editContainer = document.getElementById('yt-area-edit-container');
        const editSelect = document.getElementById('yt-area-edit-select');
        const editButton = areaSpan.parentElement.querySelector('button');

        // Show edit dropdown and hide area span and edit button
        areaSpan.style.display = 'none';
        editButton.style.display = 'none';
        editContainer.style.display = 'flex';

        // Load areas if not already loaded
        if (!areasData) {
          loadChannelData().then(() => {
            populateYtAreaEditSelect();
          });
        } else {
          populateYtAreaEditSelect();
        }

        editSelect.focus();
      }

      function populateYtAreaEditSelect() {
        const editSelect = document.getElementById('yt-area-edit-select');
        editSelect.innerHTML = '<option value="">é€‰æ‹©åˆ†åŒº...</option>';

        if (areasData && areasData.areas) {
          // Sort areas: å…¶ä»–å•æœº (235) first, then others
          const sortedAreas = [...areasData.areas].sort((a, b) => {
            if (a.id === 235) return -1;
            if (b.id === 235) return 1;
            return 0;
          });

          sortedAreas.forEach(area => {
            const option = document.createElement('option');
            option.value = area.id;
            option.textContent = area.name; // Removed (${area.id}) for cleaner display
            editSelect.appendChild(option);
          });
        }
      }

      function cancelYtAreaEdit() {
        const areaSpan = document.getElementById('yt-area');
        const editContainer = document.getElementById('yt-area-edit-container');
        const editButton = areaSpan.parentElement.querySelector('button');

        // Hide edit dropdown and show area span and edit button
        editContainer.style.display = 'none';
        areaSpan.style.display = 'block';
        editButton.style.display = 'flex';
      }

      async function saveYtAreaEdit() {
        const editSelect = document.getElementById('yt-area-edit-select');
        const areaId = parseInt(editSelect.value);

        if (!areaId) {
          showNotification('è¯·é€‰æ‹©åˆ†åŒº', 'error');
          return;
        }

        try {
          const response = await fetch('/api/channel', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              platform: 'youtube',
              area_id: areaId
            })
          });
          const data = await response.json();
          showNotification(data.message || 'YouTubeé…ç½®åˆ†åŒºå·²æ›´æ–°', 'success');
          cancelYtAreaEdit();
          // Refresh status immediately to show updated info
          refreshStatus();
        } catch (error) {
          showNotification('æ›´æ–°å¤±è´¥: ' + error.message, 'error');
        }
      }

      // YouTube quality editing functions
      function toggleYtQualityEdit() {
        const qualitySpan = document.getElementById('yt-quality');
        const editContainer = document.getElementById('yt-quality-edit-container');
        const editSelect = document.getElementById('yt-quality-edit-select');
        const editButton = qualitySpan.parentElement.querySelector('button');

        // Show edit dropdown and hide quality span and edit button
        qualitySpan.style.display = 'none';
        editButton.style.display = 'none';
        editContainer.style.display = 'flex';

        // Populate quality options for YouTube
        populateQualityOptions(editSelect, 'youtube');

        // Set current quality as selected - convert display text back to technical value
        const currentDisplayText = qualitySpan.textContent;
        if (currentDisplayText && currentDisplayText !== '-') {
          const technicalValue = getTechnicalQualityValue(currentDisplayText, 'youtube');
          editSelect.value = technicalValue;
        }

        editSelect.focus();
      }

      function cancelYtQualityEdit() {
        const qualitySpan = document.getElementById('yt-quality');
        const editContainer = document.getElementById('yt-quality-edit-container');
        const editButton = qualitySpan.parentElement.querySelector('button');

        // Hide edit dropdown and show quality span and edit button
        editContainer.style.display = 'none';
        qualitySpan.style.display = 'block';
        editButton.style.display = 'flex';
      }

      async function saveYtQualityEdit() {
        const editSelect = document.getElementById('yt-quality-edit-select');
        const quality = editSelect.value;

        if (!quality) {
          showNotification('è¯·é€‰æ‹©ç”»è´¨', 'error');
          return;
        }

        try {
          const response = await fetch('/api/channel', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              platform: 'youtube',
              quality: quality // Send technical value to server
            })
          });
          const data = await response.json();
          showNotification(data.message || 'YouTubeç”»è´¨å·²æ›´æ–°', 'success');
          cancelYtQualityEdit();
          // Update the display immediately with display text
          document.getElementById('yt-quality').textContent = getQualityDisplayText(quality, 'youtube');
          // Refresh status to get updated info
          refreshStatus();
        } catch (error) {
          showNotification('æ›´æ–°å¤±è´¥: ' + error.message, 'error');
        }
      }

      // Twitch quality editing functions
      function toggleTwQualityEdit() {
        const qualitySpan = document.getElementById('tw-quality');
        const editContainer = document.getElementById('tw-quality-edit-container');
        const editSelect = document.getElementById('tw-quality-edit-select');
        const editButton = qualitySpan.parentElement.querySelector('button');

        // Show edit dropdown and hide quality span and edit button
        qualitySpan.style.display = 'none';
        editButton.style.display = 'none';
        editContainer.style.display = 'flex';

        // Populate quality options for Twitch
        populateQualityOptions(editSelect, 'twitch');

        // Set current quality as selected - convert display text back to technical value
        const currentDisplayText = qualitySpan.textContent;
        if (currentDisplayText && currentDisplayText !== '-') {
          const technicalValue = getTechnicalQualityValue(currentDisplayText, 'twitch');
          editSelect.value = technicalValue;
        }

        editSelect.focus();
      }

      function cancelTwQualityEdit() {
        const qualitySpan = document.getElementById('tw-quality');
        const editContainer = document.getElementById('tw-quality-edit-container');
        const editButton = qualitySpan.parentElement.querySelector('button');

        // Hide edit dropdown and show quality span and edit button
        editContainer.style.display = 'none';
        qualitySpan.style.display = 'block';
        editButton.style.display = 'flex';
      }

      async function saveTwQualityEdit() {
        const editSelect = document.getElementById('tw-quality-edit-select');
        const quality = editSelect.value;

        if (!quality) {
          showNotification('è¯·é€‰æ‹©ç”»è´¨', 'error');
          return;
        }

        try {
          const response = await fetch('/api/channel', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              platform: 'twitch',
              quality: quality // Send technical value to server
            })
          });
          const data = await response.json();
          showNotification(data.message || 'Twitchç”»è´¨å·²æ›´æ–°', 'success');
          cancelTwQualityEdit();
          // Update the display immediately with display text
          document.getElementById('tw-quality').textContent = getQualityDisplayText(quality, 'twitch');
          // Refresh status to get updated info
          refreshStatus();
        } catch (error) {
          showNotification('æ›´æ–°å¤±è´¥: ' + error.message, 'error');
        }
      }

      // Twitch channel editing functions
      function toggleTwChannelEdit() {
        const channelSpan = document.getElementById('tw-channel-name');
        const editContainer = document.getElementById('tw-channel-edit-container');
        const editSelect = document.getElementById('tw-channel-edit-select');
        const editButton = channelSpan.parentElement.querySelector('button');

        // Show edit dropdown and hide channel span and edit button
        channelSpan.style.display = 'none';
        editButton.style.display = 'none';
        editContainer.style.display = 'flex';

        // Load channels if not already loaded
        if (!channelsData) {
          loadChannelData().then(() => {
            populateTwChannelEditSelect();
          });
        } else {
          populateTwChannelEditSelect();
        }

        editSelect.focus();
      }

      function populateTwChannelEditSelect() {
        const editSelect = document.getElementById('tw-channel-edit-select');
        editSelect.innerHTML = '<option value="">é€‰æ‹©é¢‘é“...</option>';

        if (channelsData && channelsData.channels) {
          channelsData.channels.forEach(channel => {
            if (channel.platforms && channel.platforms.twitch) {
              const option = document.createElement('option');
              option.value = JSON.stringify({
                id: channel.platforms.twitch,
                name: channel.name
              });
              option.textContent = channel.name;
              editSelect.appendChild(option);
            }
          });
        }
      }

      function cancelTwChannelEdit() {
        const channelSpan = document.getElementById('tw-channel-name');
        const editContainer = document.getElementById('tw-channel-edit-container');
        const editButton = channelSpan.parentElement.querySelector('button');

        // Hide edit dropdown and show channel span and edit button
        editContainer.style.display = 'none';
        channelSpan.style.display = 'block';
        editButton.style.display = 'flex';
      }

      async function saveTwChannelEdit() {
        const editSelect = document.getElementById('tw-channel-edit-select');
        const selectedValue = editSelect.value;

        if (!selectedValue) {
          showNotification('è¯·é€‰æ‹©é¢‘é“', 'error');
          return;
        }

        try {
          const channelInfo = JSON.parse(selectedValue);
          const response = await fetch('/api/channel', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              platform: 'twitch',
              channel_id: channelInfo.id,
              channel_name: channelInfo.name
            })
          });
          const data = await response.json();
          showNotification(data.message || 'Twitché¢‘é“å·²æ›´æ–°', 'success');
          cancelTwChannelEdit();
          // Refresh status immediately to show updated info
          refreshStatus();
        } catch (error) {
          showNotification('æ›´æ–°å¤±è´¥: ' + error.message, 'error');
        }
      }

      // Twitch area editing functions
      function toggleTwAreaEdit() {
        const areaSpan = document.getElementById('tw-area');
        const editContainer = document.getElementById('tw-area-edit-container');
        const editSelect = document.getElementById('tw-area-edit-select');
        const editButton = areaSpan.parentElement.querySelector('button');

        // Show edit dropdown and hide area span and edit button
        areaSpan.style.display = 'none';
        editButton.style.display = 'none';
        editContainer.style.display = 'flex';

        // Load areas if not already loaded
        if (!areasData) {
          loadChannelData().then(() => {
            populateTwAreaEditSelect();
          });
        } else {
          populateTwAreaEditSelect();
        }

        editSelect.focus();
      }

      function populateTwAreaEditSelect() {
        const editSelect = document.getElementById('tw-area-edit-select');
        editSelect.innerHTML = '<option value="">é€‰æ‹©åˆ†åŒº...</option>';

        if (areasData && areasData.areas) {
          // Sort areas: å…¶ä»–å•æœº (235) first, then others
          const sortedAreas = [...areasData.areas].sort((a, b) => {
            if (a.id === 235) return -1;
            if (b.id === 235) return 1;
            return 0;
          });

          sortedAreas.forEach(area => {
            const option = document.createElement('option');
            option.value = area.id;
            option.textContent = area.name; // Removed (${area.id}) for cleaner display
            editSelect.appendChild(option);
          });
        }
      }

      function cancelTwAreaEdit() {
        const areaSpan = document.getElementById('tw-area');
        const editContainer = document.getElementById('tw-area-edit-container');
        const editButton = areaSpan.parentElement.querySelector('button');

        // Hide edit dropdown and show area span and edit button
        editContainer.style.display = 'none';
        areaSpan.style.display = 'block';
        editButton.style.display = 'flex';
      }

      async function saveTwAreaEdit() {
        const editSelect = document.getElementById('tw-area-edit-select');
        const areaId = parseInt(editSelect.value);

        if (!areaId) {
          showNotification('è¯·é€‰æ‹©åˆ†åŒº', 'error');
          return;
        }

        try {
          const response = await fetch('/api/channel', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              platform: 'twitch',
              area_id: areaId
            })
          });
          const data = await response.json();
          showNotification(data.message || 'Twitché…ç½®åˆ†åŒºå·²æ›´æ–°', 'success');
          cancelTwAreaEdit();
          // Refresh status immediately to show updated info
          refreshStatus();
        } catch (error) {
          showNotification('æ›´æ–°å¤±è´¥: ' + error.message, 'error');
        }
      }

      // Area editing functions
      function toggleAreaEdit() {
        const areaSpan = document.getElementById('bili-area');
        const editContainer = document.getElementById('area-edit-container');
        const editSelect = document.getElementById('area-edit-select');
        const editButton = areaSpan.parentElement.querySelector('button');

        // Show edit dropdown and hide area span and edit button
        areaSpan.style.display = 'none';
        editButton.style.display = 'none';
        editContainer.style.display = 'flex';

        // Load areas if not already loaded
        if (!areasData) {
          loadChannelData().then(() => {
            populateAreaEditSelect();
          });
        } else {
          populateAreaEditSelect();
        }

        editSelect.focus();
      }

      function populateAreaEditSelect() {
        const editSelect = document.getElementById('area-edit-select');
        editSelect.innerHTML = '<option value="">é€‰æ‹©åˆ†åŒº...</option>';

        if (areasData && areasData.areas) {
          // Sort areas: å…¶ä»–å•æœº (235) first, then others
          const sortedAreas = [...areasData.areas].sort((a, b) => {
            if (a.id === 235) return -1;
            if (b.id === 235) return 1;
            return 0;
          });

          sortedAreas.forEach(area => {
            const option = document.createElement('option');
            option.value = area.id;
            option.textContent = area.name; // Removed (${area.id}) for cleaner display
            editSelect.appendChild(option);
          });
        }
      }

      function cancelAreaEdit() {
        const areaSpan = document.getElementById('bili-area');
        const editContainer = document.getElementById('area-edit-container');
        const editButton = areaSpan.parentElement.querySelector('button');

        // Hide edit dropdown and show area span and edit button
        editContainer.style.display = 'none';
        areaSpan.style.display = 'block';
        editButton.style.display = 'flex';
      }

      async function saveAreaEdit() {
        const editSelect = document.getElementById('area-edit-select');
        const areaId = parseInt(editSelect.value);

        if (!areaId) {
          showNotification('è¯·é€‰æ‹©åˆ†åŒº', 'error');
          return;
        }

        try {
          const response = await fetch('/api/area', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ area_id: areaId })
          });
          const data = await response.json();
          showNotification(data.message || 'åˆ†åŒºå·²æ›´æ–°', 'success');
          cancelAreaEdit();
          setTimeout(refreshStatus, 2000);
        } catch (error) {
          showNotification('æ›´æ–°å¤±è´¥: ' + error.message, 'error');
        }
      }

      async function saveTitleEdit() {
        const editInput = document.getElementById('title-edit-input');
        const title = editInput.value.trim();

        if (!title) {
          showNotification('è¯·è¾“å…¥ç›´æ’­æ ‡é¢˜', 'error');
          return;
        }

        try {
          const response = await fetch('/api/title', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ title: title })
          });
          const data = await response.json();
          if (data.success) {
            showNotification(data.message || 'ç›´æ’­æ ‡é¢˜å·²æ›´æ–°', 'success');
            cancelTitleEdit();
            setTimeout(refreshStatus, 2000);
          } else {
            showNotification(data.message || 'æ›´æ–°å¤±è´¥', 'error');
          }
        } catch (error) {
          showNotification('æ›´æ–°å¤±è´¥: ' + error.message, 'error');
        }
      }

      // Channel management functions
      async function loadChannelData() {
        // Start continuous spinning animation
        const icon = document.getElementById('loadChannelIcon');
        if (icon) {
          icon.style.animation = 'spin 1s linear infinite';
        }

        try {
          // Load channels
          const channelsResponse = await fetch('/api/channels');
          channelsData = await channelsResponse.json();
          console.log('Channels loaded:', channelsData);

          // Load areas
          const areasResponse = await fetch('/api/areas');
          areasData = await areasResponse.json();
          console.log('Areas loaded:', areasData);

          // Populate area select
          const areaSelect = document.getElementById('area-select');
          areaSelect.innerHTML = '<option value="">ä¸ä¿®æ”¹åˆ†åŒº</option>';

          // Handle both array and object responses
          let areasList = [];
          if (Array.isArray(areasData)) {
            areasList = areasData;
          } else if (areasData && areasData.areas) {
            areasList = areasData.areas;
          }

          if (areasList.length > 0) {
            console.log('Populating areas, count:', areasList.length);

            // Sort areas: å…¶ä»–å•æœº (235) first, then others
            const sortedAreas = [...areasList].sort((a, b) => {
              if (a.id === 235) return -1;
              if (b.id === 235) return 1;
              return 0;
            });

            // Populate channel management area select
            sortedAreas.forEach(area => {
              const option = document.createElement('option');
              option.value = area.id;
              option.textContent = `${area.name} (${area.id})`;
              areaSelect.appendChild(option);
            });

            console.log('Successfully populated', areasList.length, 'areas');
          } else {
            console.error('No areas data found:', areasData);
            showNotification('æœªæ‰¾åˆ°åˆ†åŒºæ•°æ®', 'error');
          }

          // Update channel list
          updateChannelList();
        } catch (error) {
          console.error('Failed to load channel data:', error);
          showNotification('åŠ è½½é¢‘é“æ•°æ®å¤±è´¥: ' + error.message, 'error');
        } finally {
          // Stop spinning animation when complete
          if (icon) {
            icon.style.animation = '';
          }
        }
      }

      function updateChannelList() {
        const platform = document.getElementById('platform-select').value;
        const channelSelect = document.getElementById('channel-select');

        channelSelect.innerHTML = '<option value="">é€‰æ‹©é¢„è®¾é¢‘é“æˆ–æ‰‹åŠ¨è¾“å…¥...</option>';

        // Only populate if channels data is available
        if (channelsData && channelsData.channels) {
          channelsData.channels.forEach(channel => {
            if (channel.platforms && channel.platforms[platform]) {
              const option = document.createElement('option');
              option.value = JSON.stringify({
                id: channel.platforms[platform],
                name: channel.name
              });
              option.textContent = channel.name;
              channelSelect.appendChild(option);
            }
          });
        }

        // Don't clear inputs - allow manual entry to persist
        // Update quality options based on platform
        updateQualityOptions();
      }

      function updateQualityOptions() {
        const platform = document.getElementById('platform-select').value;
        const qualitySelect = document.getElementById('quality-select');

        // Store current value
        const currentValue = qualitySelect.value;

        // Clear all options except the first "ä¸ä¿®æ”¹ç”»è´¨" option
        const firstOption = qualitySelect.querySelector('option[value=""]');
        qualitySelect.innerHTML = '';
        if (firstOption) {
          qualitySelect.appendChild(firstOption);
        }

        // Add platform-specific quality options if platform is selected
        if (platform) {
          populateQualityOptions(qualitySelect, platform, false); // false = don't add empty option
        }

        // Try to restore previous value if it's still valid
        if (currentValue && qualitySelect.querySelector(`option[value="${currentValue}"]`)) {
          qualitySelect.value = currentValue;
        }
      }

      function updateChannelInfo() {
        const channelSelect = document.getElementById('channel-select');
        const selectedValue = channelSelect.value;

        if (!selectedValue) {
          document.getElementById('channel-id-input').value = '';
          document.getElementById('channel-name-input').value = '';
          return;
        }

        try {
          const channelInfo = JSON.parse(selectedValue);
          document.getElementById('channel-id-input').value = channelInfo.id;
          document.getElementById('channel-name-input').value = channelInfo.name;
        } catch (error) {
          console.error('Failed to parse channel info:', error);
        }
      }

      function toggleLolMonitorInputs() {
        const areaId = document.getElementById('area-select').value;
        const lolMonitorGroup = document.getElementById('lol-monitor-group');
        const riotApiKeyGroup = document.getElementById('riot-api-key-group');
        const enableCheckbox = document.getElementById('enable-lol-monitor-inline');

        // Show LOL monitor checkbox if area is 86 (è‹±é›„è”ç›Ÿ)
        if (areaId === '86') {
          lolMonitorGroup.style.display = 'block';

          // Load current enable_lol_monitor state
          if (window.configData) {
            enableCheckbox.checked = window.configData.enable_lol_monitor || false;
          }

          // Show Riot API Key input if checkbox is checked
          if (enableCheckbox.checked) {
            riotApiKeyGroup.style.display = 'block';
          } else {
            riotApiKeyGroup.style.display = 'none';
          }
        } else {
          lolMonitorGroup.style.display = 'none';
          riotApiKeyGroup.style.display = 'none';
        }
      }

      function toggleRiotApiKeyInputInline() {
        const enableCheckbox = document.getElementById('enable-lol-monitor-inline');
        const riotApiKeyGroup = document.getElementById('riot-api-key-group');

        // Show/hide Riot API Key input based on checkbox
        if (enableCheckbox.checked) {
          riotApiKeyGroup.style.display = 'block';
        } else {
          riotApiKeyGroup.style.display = 'none';
        }
      }

      // Quality mapping functions for display vs technical values
      function getQualityDisplayText(technicalValue, platform = 'youtube') {
        const qualityMappings = {
          youtube: {
            'best': 'æœ€ä½³è´¨é‡',
            'best[height<=1080]': 'è¶…æ¸… (1080p)',
            'best[height<=720]': 'é«˜æ¸… (720p)',
            'best[height<=480]': 'æ ‡æ¸… (480p)',
            'best[height<=360]': 'æµç•… (360p)',
            'worst': 'æœ€ä½è´¨é‡'
          },
          twitch: {
            'best': 'åŸç”»è´¨é‡',
            'high': 'é«˜è´¨é‡ (720p)',
            'medium': 'ä¸­ç­‰è´¨é‡ (540p)',
            'low': 'ä½è´¨é‡ (360p)',
            'audio_only': 'ä»…éŸ³é¢‘',
            'worst': 'æœ€ä½è´¨é‡'
          }
        };

        return qualityMappings[platform][technicalValue] || technicalValue;
      }

      function getTechnicalQualityValue(displayText, platform = 'youtube') {
        const reverseMappings = {
          youtube: {
            'æœ€ä½³è´¨é‡': 'best',
            'è¶…æ¸… (1080p)': 'best[height<=1080]',
            'é«˜æ¸… (720p)': 'best[height<=720]',
            'æ ‡æ¸… (480p)': 'best[height<=480]',
            'æµç•… (360p)': 'best[height<=360]',
            'æœ€ä½è´¨é‡': 'worst'
          },
          twitch: {
            'åŸç”»è´¨é‡': 'best',
            'é«˜è´¨é‡ (720p)': 'high',
            'ä¸­ç­‰è´¨é‡ (540p)': 'medium',
            'ä½è´¨é‡ (360p)': 'low',
            'ä»…éŸ³é¢‘': 'audio_only',
            'æœ€ä½è´¨é‡': 'worst'
          }
        };

        return reverseMappings[platform][displayText] || displayText;
      }

      // Unified function to populate quality options for any select element
      function populateQualityOptions(selectElement, platform, includeEmpty = true) {
        if (!selectElement) return;

        // Clear existing options
        selectElement.innerHTML = '';

        // Add empty option if requested
        if (includeEmpty) {
          const emptyOption = document.createElement('option');
          emptyOption.value = '';
          emptyOption.textContent = 'é€‰æ‹©ç”»è´¨...';
          selectElement.appendChild(emptyOption);
        }

        // Get quality mappings for the platform
        const qualityMappings = {
          youtube: {
            'best': 'æœ€ä½³è´¨é‡',
            'best[height<=1080]': 'è¶…æ¸… (1080p)',
            'best[height<=720]': 'é«˜æ¸… (720p)',
            'best[height<=480]': 'æ ‡æ¸… (480p)',
            'best[height<=360]': 'æµç•… (360p)',
            'worst': 'æœ€ä½è´¨é‡'
          },
          twitch: {
            'best': 'åŸç”»è´¨é‡',
            'high': 'é«˜è´¨é‡ (720p)',
            'medium': 'ä¸­ç­‰è´¨é‡ (540p)',
            'low': 'ä½è´¨é‡ (360p)',
            'audio_only': 'ä»…éŸ³é¢‘',
            'worst': 'æœ€ä½è´¨é‡'
          }
        };

        // Add options for the specified platform
        const platformQualities = qualityMappings[platform];
        if (platformQualities) {
          Object.entries(platformQualities).forEach(([value, text]) => {
            const option = document.createElement('option');
            option.value = value;
            option.textContent = text;
            selectElement.appendChild(option);
          });
        }
      }

      async function applyChannelChange() {
        const platform = document.getElementById('platform-select').value;
        const channelId = document.getElementById('channel-id-input').value.trim();
        const channelName = document.getElementById('channel-name-input').value.trim();
        const areaId = document.getElementById('area-select').value;
        const quality = document.getElementById('quality-select').value;
        const riotApiKey = document.getElementById('riot-api-key-input').value.trim();
        const enableLolMonitor = document.getElementById('enable-lol-monitor-inline').checked;

        if (!channelId || !channelName) {
          showNotification('è¯·è¾“å…¥é¢‘é“IDå’Œé¢‘é“åç§°', 'error');
          return;
        }

        try {
          // First, update channel info
          const channelPayload = {
            platform: platform,
            channel_id: channelId,
            channel_name: channelName
          };

          if (areaId) {
            channelPayload.area_id = parseInt(areaId);

            // Include Riot API Key if area is 86 and key is provided
            if (areaId === '86' && riotApiKey) {
              channelPayload.riot_api_key = riotApiKey;
            }
          }

          if (quality) {
            channelPayload.quality = quality;
          }

          const channelResponse = await fetch('/api/channel', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(channelPayload)
          });

          const channelData = await channelResponse.json();

          // If area is 86, also update enable_lol_monitor setting
          if (areaId === '86') {
            const configPayload = {
              enable_lol_monitor: enableLolMonitor
            };

            // Include Riot API Key in config update if provided
            if (riotApiKey) {
              configPayload.riot_api_key = riotApiKey;
            }

            await fetch('/api/config', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(configPayload)
            });

            // Update global config
            window.configData.enable_lol_monitor = enableLolMonitor;
          }

          showNotification(channelData.message || 'é¢‘é“å·²æ›´æ–°', 'success');

          // Clear Riot API Key input after successful update
          if (riotApiKey) {
            document.getElementById('riot-api-key-input').value = '';
          }

          setTimeout(refreshStatus, 2000);
        } catch (error) {
          showNotification('æ›´æ–°å¤±è´¥: ' + error.message, 'error');
        }
      }

      // Setup wizard functions
      let currentStep = 1;

      function goToStep(step) {
        // Hide all steps
        for (let i = 1; i <= 3; i++) {
          document.getElementById(`setup-step-${i}`).style.display = 'none';
          document.getElementById(`step-dot-${i}`).classList.remove('active');
        }

        // Show target step
        document.getElementById(`setup-step-${step}`).style.display = 'block';
        document.getElementById(`step-dot-${step}`).classList.add('active');
        currentStep = step;
      }

      function toggleRiotApiKey() {
        const checkbox = document.getElementById('setup-lol-monitor');
        const group = document.getElementById('riot-api-group');
        group.style.display = checkbox.checked ? 'block' : 'none';
      }

      async function checkLoginStatus() {
        try {
          const response = await fetch('/api/setup/login-status');
          const data = await response.json();

          const statusDiv = document.getElementById('login-status');
          const statusText = document.getElementById('login-status-text');

          if (data.logged_in) {
            statusDiv.style.background = '#d1fae5';
            statusDiv.style.color = '#065f46';
            statusText.textContent = 'âœ… å·²ç™»å½• Bilibili';
          } else {
            statusDiv.style.background = '#fee2e2';
            statusDiv.style.color = '#991b1b';
            statusText.textContent = 'âŒ æœªç™»å½•ï¼Œè¯·ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®ç™»å½•';
          }
        } catch (error) {
          console.error('Failed to check login status:', error);
          showNotification('æ£€æŸ¥ç™»å½•çŠ¶æ€å¤±è´¥', 'error');
        }
      }

      let loginPollInterval = null;
      let currentAuthCode = null;

      async function showQrCode() {
        try {
          // Get QR code from API
          const response = await fetch('/api/setup/qrcode');
          const data = await response.json();

          if (!data.success || !data.data) {
            showNotification(data.message || 'è·å–äºŒç»´ç å¤±è´¥', 'error');
            return;
          }

          const { qr_url, auth_code } = data.data;
          currentAuthCode = auth_code;

          // Generate QR code using external API
          const qrContainer = document.getElementById('qr-code-display');
          qrContainer.innerHTML = '';

          // Create QR code using QR Server API
          const qrImg = document.createElement('img');
          qrImg.src = `https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=${encodeURIComponent(qr_url)}`;
          qrImg.style.width = '200px';
          qrImg.style.height = '200px';
          qrContainer.appendChild(qrImg);

          // Show QR code container
          document.getElementById('qr-code-container').style.display = 'block';
          document.getElementById('show-qr-btn').textContent = 'ğŸ”„ åˆ·æ–°äºŒç»´ç ';

          // Start polling for login status
          startLoginPolling();

          showNotification('è¯·ä½¿ç”¨ Bilibili APP æ‰«ç ç™»å½•', 'success');
        } catch (error) {
          console.error('Failed to get QR code:', error);
          showNotification('è·å–äºŒç»´ç å¤±è´¥: ' + error.message, 'error');
        }
      }

      function startLoginPolling() {
        // Clear existing interval
        if (loginPollInterval) {
          clearInterval(loginPollInterval);
        }

        // Poll every 2 seconds
        loginPollInterval = setInterval(async () => {
          if (!currentAuthCode) return;

          try {
            const response = await fetch('/api/setup/poll-login', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ auth_code: currentAuthCode })
            });
            const data = await response.json();

            if (data.success && data.data) {
              const { status, message } = data.data;
              document.getElementById('qr-status').textContent = message;

              if (status === 'success') {
                clearInterval(loginPollInterval);
                loginPollInterval = null;
                showNotification('ç™»å½•æˆåŠŸï¼', 'success');
                document.getElementById('qr-code-container').style.display = 'none';
                await checkLoginStatus();
              } else if (status === 'expired') {
                clearInterval(loginPollInterval);
                loginPollInterval = null;
                showNotification('äºŒç»´ç å·²è¿‡æœŸï¼Œè¯·é‡æ–°è·å–', 'error');
                document.getElementById('qr-status').textContent = 'äºŒç»´ç å·²è¿‡æœŸ';
                document.getElementById('qr-status').style.color = '#ef4444';
              }
            }
          } catch (error) {
            console.error('Poll login failed:', error);
          }
        }, 2000);
      }

      async function triggerBiliLogin() {
        showNotification('æ­£åœ¨å¯åŠ¨ç™»å½•æµç¨‹ï¼Œè¯·åœ¨ç»ˆç«¯æŸ¥çœ‹äºŒç»´ç ...', 'success');

        try {
          const response = await fetch('/api/setup/login', {
            method: 'POST'
          });
          const data = await response.json();

          if (data.success) {
            showNotification('ç™»å½•æˆåŠŸï¼', 'success');
            await checkLoginStatus();
          } else {
            showNotification(data.message || 'ç™»å½•å¤±è´¥', 'error');
          }
        } catch (error) {
          console.error('Login failed:', error);
          showNotification('ç™»å½•å¤±è´¥: ' + error.message, 'error');
        }
      }

      async function saveSetupConfig() {
        // Validate required fields
        const room = document.getElementById('setup-room').value;
        if (!room || room <= 0) {
          showNotification('è¯·è¾“å…¥æœ‰æ•ˆçš„ç›´æ’­é—´å·', 'error');
          goToStep(2);
          return;
        }

        // Collect all configuration
        const config = {
          room: parseInt(room),
          interval: parseInt(document.getElementById('setup-interval').value) || 60,
          auto_cover: document.getElementById('setup-auto-cover').checked,
          enable_danmaku_command: document.getElementById('setup-danmaku-command').checked,
          anti_collision: document.getElementById('setup-anti-collision').checked,
          proxy: document.getElementById('setup-proxy').value || null,

          // YouTube
          youtube_channel_name: document.getElementById('setup-yt-name').value || null,
          youtube_channel_id: document.getElementById('setup-yt-id').value || null,
          youtube_area_v2: parseInt(document.getElementById('setup-yt-area').value) || null,
          youtube_quality: document.getElementById('setup-yt-quality').value || null,

          // Twitch
          twitch_channel_name: document.getElementById('setup-tw-name').value || null,
          twitch_channel_id: document.getElementById('setup-tw-id').value || null,
          twitch_area_v2: parseInt(document.getElementById('setup-tw-area').value) || null,
          twitch_oauth_token: document.getElementById('setup-tw-oauth').value || null,
          twitch_proxy_region: document.getElementById('setup-tw-region').value || null,
          twitch_quality: document.getElementById('setup-tw-quality').value || null,

          // Advanced
          holodex_api_key: document.getElementById('setup-holodex').value || null,
          riot_api_key: document.getElementById('setup-riot').value || null,
          enable_lol_monitor: document.getElementById('setup-lol-monitor').checked
        };

        try {
          const response = await fetch('/api/setup/save-config', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(config)
          });

          const data = await response.json();

          if (data.success) {
            showNotification('é…ç½®ä¿å­˜æˆåŠŸï¼æ­£åœ¨åŠ è½½æ§åˆ¶é¢æ¿...', 'success');
            setTimeout(() => {
              location.reload();
            }, 1500);
          } else {
            showNotification(data.message || 'ä¿å­˜é…ç½®å¤±è´¥', 'error');
          }
        } catch (error) {
          console.error('Failed to save config:', error);
          showNotification('ä¿å­˜é…ç½®å¤±è´¥: ' + error.message, 'error');
        }
      }

      // Setup check functions
      async function checkSetupStatus() {
        try {
          const response = await fetch('/api/setup-status');
          const data = await response.json();

          if (data.needs_setup) {
            // Show setup page
            document.getElementById('setup-page').classList.add('active');
            document.getElementById('main-page').classList.add('hidden');

            // Load areas for dropdowns
            await loadAreasForSetup();

            // Load channels for dropdowns
            await loadChannelsForSetup();

            // Check login status
            await checkLoginStatus();
          } else {
            // Show main page
            document.getElementById('setup-page').classList.remove('active');
            document.getElementById('main-page').classList.remove('hidden');
          }

          return data.needs_setup;
        } catch (error) {
          console.error('Failed to check setup status:', error);
          // On error, show main page
          document.getElementById('setup-page').classList.remove('active');
          document.getElementById('main-page').classList.remove('hidden');
          return false;
        }
      }

      async function loadAreasForSetup() {
        try {
          const response = await fetch('/api/areas');
          const areasData = await response.json();

          let areasList = [];
          if (Array.isArray(areasData)) {
            areasList = areasData;
          } else if (areasData && areasData.areas) {
            areasList = areasData.areas;
          }

          if (areasList.length > 0) {
            const ytAreaSelect = document.getElementById('setup-yt-area');
            const twAreaSelect = document.getElementById('setup-tw-area');

            // Sort areas: å…¶ä»–å•æœº (235) first, then others
            const sortedAreas = [...areasList].sort((a, b) => {
              if (a.id === 235) return -1;
              if (b.id === 235) return 1;
              return 0;
            });

            [ytAreaSelect, twAreaSelect].forEach(select => {
              select.innerHTML = '';
              sortedAreas.forEach(area => {
                const option = document.createElement('option');
                option.value = area.id;
                option.textContent = `${area.name} (${area.id})`;
                if (area.id === 235) option.selected = true;
                select.appendChild(option);
              });
            });
          }
        } catch (error) {
          console.error('Failed to load areas:', error);
        }
      }

      async function loadChannelsForSetup() {
        try {
          const response = await fetch('/api/channels');
          const channelsData = await response.json();

          if (channelsData && channelsData.channels) {
            const ytChannelSelect = document.getElementById('setup-yt-channel-select');
            const twChannelSelect = document.getElementById('setup-tw-channel-select');

            // Populate YouTube channels
            ytChannelSelect.innerHTML = '<option value="">é€‰æ‹©é¢„è®¾é¢‘é“æˆ–æ‰‹åŠ¨è¾“å…¥...</option>';
            channelsData.channels.forEach(channel => {
              if (channel.platforms && channel.platforms.youtube) {
                const option = document.createElement('option');
                option.value = JSON.stringify({
                  id: channel.platforms.youtube,
                  name: channel.name
                });
                option.textContent = channel.name;
                ytChannelSelect.appendChild(option);
              }
            });

            // Populate Twitch channels
            twChannelSelect.innerHTML = '<option value="">é€‰æ‹©é¢„è®¾é¢‘é“æˆ–æ‰‹åŠ¨è¾“å…¥...</option>';
            channelsData.channels.forEach(channel => {
              if (channel.platforms && channel.platforms.twitch) {
                const option = document.createElement('option');
                option.value = JSON.stringify({
                  id: channel.platforms.twitch,
                  name: channel.name
                });
                option.textContent = channel.name;
                twChannelSelect.appendChild(option);
              }
            });
          }
        } catch (error) {
          console.error('Failed to load channels:', error);
        }
      }

      function updateSetupYouTubeChannel() {
        const select = document.getElementById('setup-yt-channel-select');
        const selectedValue = select.value;

        if (!selectedValue) {
          return;
        }

        try {
          const channelInfo = JSON.parse(selectedValue);
          document.getElementById('setup-yt-id').value = channelInfo.id;
          document.getElementById('setup-yt-name').value = channelInfo.name;
        } catch (error) {
          console.error('Failed to parse channel info:', error);
        }
      }

      function updateSetupTwitchChannel() {
        const select = document.getElementById('setup-tw-channel-select');
        const selectedValue = select.value;

        if (!selectedValue) {
          return;
        }

        try {
          const channelInfo = JSON.parse(selectedValue);
          document.getElementById('setup-tw-id').value = channelInfo.id;
          document.getElementById('setup-tw-name').value = channelInfo.name;
        } catch (error) {
          console.error('Failed to parse channel info:', error);
        }
      }

      async function checkSetupAndRefresh() {
        const needsSetup = await checkSetupStatus();
        if (!needsSetup) {
          showNotification('è®¾ç½®å®Œæˆï¼æ­£åœ¨åŠ è½½æ§åˆ¶é¢æ¿...', 'success');
          setTimeout(() => {
            location.reload();
          }, 1000);
        } else {
          showNotification('è¯·å…ˆå®Œæˆè®¾ç½®æ­¥éª¤', 'error');
        }
      }

      // Check for updates function
      let CURRENT_VERSION = null; // Will be fetched from API
      const GITHUB_REPO = 'Detteee/bilistream';
      let latestUpdateInfo = null;

      // Fetch current version from API
      async function loadVersion() {
        try {
          const response = await fetch('/api/version');
          const data = await response.json();
          if (data.success && data.data) {
            CURRENT_VERSION = data.data.version;
            document.getElementById('version-display').textContent = `Bilistream v${CURRENT_VERSION}`;
          }
        } catch (error) {
          console.error('Failed to load version:', error);
          document.getElementById('version-display').textContent = 'Bilistream';
        }
      }

      async function checkForUpdates() {
        try {
          showNotification('æ­£åœ¨æ£€æŸ¥æ›´æ–°...', 'success');

          // Use backend API to check for updates
          const response = await fetch('/api/update/check');

          if (!response.ok) {
            throw new Error('æ— æ³•è·å–ç‰ˆæœ¬ä¿¡æ¯');
          }

          const data = await response.json();

          if (!data.success) {
            throw new Error(data.message || 'æ£€æŸ¥æ›´æ–°å¤±è´¥');
          }

          const updateInfo = data.data;
          latestUpdateInfo = updateInfo;

          console.log('Update info:', updateInfo);

          // Compare versions
          if (updateInfo.has_update) {
            // New version available
            const updateNotification = document.getElementById('update-notification');
            const updateMessage = document.getElementById('update-message');
            const updateLink = document.getElementById('update-link');
            const autoUpdateBtn = document.getElementById('auto-update-btn');

            let message = `æœ€æ–°ç‰ˆæœ¬ v${updateInfo.latest_version} å·²å‘å¸ƒï¼å½“å‰ç‰ˆæœ¬ï¼šv${updateInfo.current_version}`;
            if (updateInfo.asset_name) {
              const sizeMB = (updateInfo.asset_size / 1024 / 1024).toFixed(1);
              message += `\næ–‡ä»¶: ${updateInfo.asset_name} (${sizeMB} MB)`;
            }
            updateMessage.textContent = message;
            updateMessage.style.whiteSpace = 'pre-line';

            // Set manual download link
            if (updateInfo.download_url) {
              updateLink.href = updateInfo.download_url;
              autoUpdateBtn.style.display = 'block';
            } else {
              // No direct download available, hide auto-update button
              autoUpdateBtn.style.display = 'none';
              updateLink.href = `https://github.com/${GITHUB_REPO}/releases/latest`;
            }

            updateNotification.style.display = 'block';

            showNotification(`å‘ç°æ–°ç‰ˆæœ¬ v${updateInfo.latest_version}ï¼`, 'success');
          } else {
            showNotification('å·²æ˜¯æœ€æ–°ç‰ˆæœ¬ï¼', 'success');
            // Hide update notification if it was shown before
            document.getElementById('update-notification').style.display = 'none';
          }
        } catch (error) {
          console.error('Failed to check for updates:', error);
          showNotification('æ£€æŸ¥æ›´æ–°å¤±è´¥: ' + error.message, 'error');
        }
      }

      async function autoInstallUpdate() {
        if (!latestUpdateInfo || !latestUpdateInfo.download_url) {
          showNotification('æ— æ³•è·å–ä¸‹è½½åœ°å€', 'error');
          return;
        }

        try {
          const autoUpdateBtn = document.getElementById('auto-update-btn');
          const updateProgress = document.getElementById('update-progress');

          autoUpdateBtn.disabled = true;
          autoUpdateBtn.textContent = 'â³ ä¸‹è½½ä¸­...';
          updateProgress.style.display = 'block';
          updateProgress.textContent = 'æ­£åœ¨ä¸‹è½½æ›´æ–°ï¼Œè¯·ç¨å€™...';

          showNotification('å¼€å§‹ä¸‹è½½æ›´æ–°...', 'success');

          const response = await fetch('/api/update/download', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ download_url: latestUpdateInfo.download_url })
          });

          const data = await response.json();

          if (data.success) {
            updateProgress.textContent = 'âœ… æ›´æ–°ä¸‹è½½å®Œæˆï¼ç¨‹åºå°†è‡ªåŠ¨é‡å¯...';
            showNotification('æ›´æ–°å®‰è£…ä¸­ï¼Œç¨‹åºå³å°†é‡å¯...', 'success');

            // Wait a bit then reload the page (program will restart)
            setTimeout(() => {
              location.reload();
            }, 5000);
          } else {
            throw new Error(data.message || 'ä¸‹è½½å¤±è´¥');
          }
        } catch (error) {
          console.error('Failed to download update:', error);
          showNotification('è‡ªåŠ¨æ›´æ–°å¤±è´¥: ' + error.message, 'error');

          const autoUpdateBtn = document.getElementById('auto-update-btn');
          const updateProgress = document.getElementById('update-progress');
          autoUpdateBtn.disabled = false;
          autoUpdateBtn.textContent = 'ğŸš€ è‡ªåŠ¨æ›´æ–°';
          updateProgress.textContent = 'âŒ æ›´æ–°å¤±è´¥ï¼Œè¯·å°è¯•æ‰‹åŠ¨ä¸‹è½½';
        }
      }

      function compareVersions(v1, v2) {
        const parts1 = v1.split('.').map(Number);
        const parts2 = v2.split('.').map(Number);

        for (let i = 0; i < Math.max(parts1.length, parts2.length); i++) {
          const part1 = parts1[i] || 0;
          const part2 = parts2[i] || 0;

          if (part1 > part2) return 1;
          if (part1 < part2) return -1;
        }

        return 0;
      }

      // Auto-check for updates on page load (only on main page)
      function autoCheckUpdates() {
        const mainPage = document.getElementById('main-page');
        if (mainPage && !mainPage.classList.contains('hidden')) {
          // Check for updates silently (without notification)
          fetch('/api/update/check')
            .then(response => response.json())
            .then(data => {
              if (data.success && data.data && data.data.has_update) {
                const updateInfo = data.data;
                latestUpdateInfo = updateInfo;

                const updateNotification = document.getElementById('update-notification');
                const updateMessage = document.getElementById('update-message');
                const updateLink = document.getElementById('update-link');
                const autoUpdateBtn = document.getElementById('auto-update-btn');

                let message = `æœ€æ–°ç‰ˆæœ¬ v${updateInfo.latest_version} å·²å‘å¸ƒï¼å½“å‰ç‰ˆæœ¬ï¼šv${updateInfo.current_version}`;
                if (updateInfo.asset_name) {
                  const sizeMB = (updateInfo.asset_size / 1024 / 1024).toFixed(1);
                  message += `\næ–‡ä»¶: ${updateInfo.asset_name} (${sizeMB} MB)`;
                }
                updateMessage.textContent = message;
                updateMessage.style.whiteSpace = 'pre-line';

                if (updateInfo.download_url) {
                  updateLink.href = updateInfo.download_url;
                  autoUpdateBtn.style.display = 'block';
                } else {
                  autoUpdateBtn.style.display = 'none';
                  updateLink.href = `https://github.com/${GITHUB_REPO}/releases/latest`;
                }

                updateNotification.style.display = 'block';
              }
            })
            .catch(error => {
              console.log('Auto-update check failed (silent):', error);
            });
        }
      }

      // Theme toggle function
      function toggleTheme() {
        const body = document.body;
        const themeToggle = document.getElementById('theme-toggle');

        if (body.classList.contains('light-theme')) {
          // Switch to dark theme (Dracula)
          body.classList.remove('light-theme');
          themeToggle.textContent = 'ğŸŒ™ æš—è‰²';
          localStorage.setItem('theme', 'dark');
        } else {
          // Switch to light theme
          body.classList.add('light-theme');
          themeToggle.textContent = 'â˜€ï¸ äº®è‰²';
          localStorage.setItem('theme', 'light');
        }
      }

      // Load saved theme preference
      function loadTheme() {
        const savedTheme = localStorage.getItem('theme');
        const themeToggle = document.getElementById('theme-toggle');

        if (savedTheme === 'light') {
          document.body.classList.add('light-theme');
          if (themeToggle) themeToggle.textContent = 'â˜€ï¸ äº®è‰²';
        } else {
          // Default to dark theme (Dracula)
          document.body.classList.remove('light-theme');
          if (themeToggle) themeToggle.textContent = 'ğŸŒ™ æš—è‰²';
        }
      }

      // Load theme on page load
      loadTheme();

      // Check setup status on page load
      checkSetupStatus().then(needsSetup => {
        if (!needsSetup) {
          // Load version first
          loadVersion();

          // Only load data if setup is complete
          initStatusRefresh(); // This will load config and start auto-refresh
          loadChannelData();

          // Auto-check for updates after 2 seconds
          setTimeout(autoCheckUpdates, 2000);
        }
      });

      // Add event listener for switch buttons using data attributes
      document.addEventListener('click', function (e) {
        if (e.target.closest('.switch-button')) {
          const button = e.target.closest('.switch-button');
          const channelId = button.dataset.channelId;
          const suggestedAreaId = button.dataset.suggestedAreaId ? parseInt(button.dataset.suggestedAreaId) : null;
          const title = button.dataset.title;
          const topicId = button.dataset.topicId;
          const status = button.dataset.status;

          switchToHolodexStream(channelId, suggestedAreaId, title, topicId, status);
        }
      });
    </script>
  </div> <!-- Close main-page -->
</body>

</html>